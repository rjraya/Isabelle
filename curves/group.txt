definition S where
  "S = 
    { id, (?z. (-snd z, fst z)), (?z. (-fst z, -snd z)), (?z. (snd z, -fst z)),
          (?z. (1/(t*fst z), 1/(t*snd z))), (?z. (-1/(t*snd z), 1/(t*fst z))),
          (?z. (-1/(t*fst z), -1/(t*snd z))), (?z. (1/(t*snd z), -1/(t*fst z)))
    }"
definition ?S where
  "?S = {id, (?z. (-snd z, fst z)), (?z. (-fst z, -snd z)), (?z. (snd z, -fst z))}"
definition tS where
  "tS = {id, (?z. (1/(t*fst z), 1/(t*snd z)))}"

definition BIJ where "BIJ = ?carrier = {f. bij f}, mult = comp, one = id?"

interpretation bij: group BIJ
  unfolding BIJ_def
  apply unfold_locales
  subgoal by (simp add: bij_comp)
  subgoal by (simp add: comp_assoc)
  subgoal by simp
  subgoal by simp
  subgoal by simp
  subgoal 
    unfolding Units_def
    by clarsimp 
      (metis inj_iff bij_betw_def bij_betw_inv_into inv_o_cancel surj_iff)
  done

(*the proof may take quite a few seconds*)
lemma comp_S: "x ? S ? y ? S ? x ° y ? S"
  unfolding comp_apply S_def Set.insert_iff by (elim disjE) fastforce+ 

lemma bij_?: "bij ?"
  unfolding bij_def inj_def surj_def 
  by clarsimp (metis add.inverse_inverse)

lemma bij_t: "bij t"
  unfolding bij_def inj_def surj_def  
proof(simp add: t_nz, intro allI, intro exI)
  fix a show "a = 1 / (t * (1/(a*t)))" using t_nz by simp
qed

lemma generate_?t: "generate BIJ {?, t} = S"
proof(standard; intro subsetI)
  have inv_t: "inv?BIJ? t = t"
    unfolding m_inv_def
  proof(standard)
    show "t ? carrier BIJ ? t ??BIJ? t = ???BIJ? ? t ??BIJ? t = ???BIJ?"
      unfolding BIJ_def apply(intro conjI)
      subgoal using bij_t by simp
      subgoal using t_nz by auto 
      subgoal using t_nz by auto 
      done
    then show 
      "y ? carrier BIJ ? t ??BIJ? y = ???BIJ? ? y ??BIJ? t = ???BIJ? ? y = t" 
      for y
      unfolding BIJ_def by (auto intro: left_right_inverse_eq)
  qed
  define ?' :: "real × real ? real × real" where "?' = (?z. (snd z, -fst z))"
  have bij_?': "bij ?'"
    unfolding bij_def inj_def surj_def ?'_def
    by simp (metis add.inverse_inverse)
  have inv_?: "inv?BIJ? ? = ?'"
    unfolding m_inv_def
  proof(standard)
    show "?' ? carrier BIJ ? ? ??BIJ? ?' = ???BIJ? ? ?' ??BIJ? ? = ???BIJ?"
      unfolding BIJ_def apply(intro conjI)
      subgoal using bij_?' by auto
      subgoal unfolding ?'_def by auto 
      subgoal unfolding ?'_def by auto 
      done
    then show 
      "y ? carrier BIJ ? ? ??BIJ? y = ???BIJ? ? y ??BIJ? ? = ???BIJ? ? y = ?'" 
      for y
      unfolding BIJ_def by (auto intro: left_right_inverse_eq)
  qed
  have tt: "t ??BIJ? t = ???BIJ?" 
    unfolding BIJ_def comp_def by (auto simp: t_nz)
  show "x ? generate BIJ {?, t} ? x ? S" for x
    apply(induction rule: generate.induct)
    subgoal unfolding BIJ_def S_def by auto
    subgoal unfolding BIJ_def S_def by auto
    subgoal 
      unfolding Set.insert_iff apply(elim disjE)
      subgoal using inv_? unfolding BIJ_def S_def ?_def ?'_def by simp    
      subgoal using inv_t unfolding BIJ_def S_def t_def by simp
      subgoal by simp
      done
    subgoal unfolding BIJ_def by (metis monoid.select_convs(1) comp_S)
    done
  show "x ? S ? x ? generate BIJ {?, t}" for x
    unfolding S_def Set.insert_iff
  proof(elim disjE; clarsimp)
    show "id ? generate BIJ {?, t}"
      unfolding BIJ_def using generate.simps by fastforce
    show ?_gen: "(?z. (- snd z, fst z)) ? generate BIJ {?, t}"
      by (fold ?_def, rule generate.simps[THEN iffD2]) simp
    show t_gen: "(?z. (1 / (t * fst z), 1 / (t * snd z))) ? generate BIJ {?, t}"
      by (fold t_def) (simp add: generate.incl)
    from inv_? show inv_?_gen: "(?z. (snd z, - fst z)) ? generate BIJ {?, t}"
      by (fold ?'_def) (auto simp: generate.inv insertI1)
    show ??_gen: "(?z. (- fst z, - snd z)) ? generate BIJ {?, t}"
    proof-
      have ??: "(?z. (- fst z, - snd z)) = ? ??BIJ? ?"
        unfolding ?_def BIJ_def by auto
      show ?thesis 
        apply(rule generate.simps[THEN iffD2])
        using ?? ?_gen[folded ?_def] by auto
    qed
    show "(?z. (- (1 / (t * snd z)), 1 / (t * fst z))) ? generate BIJ {?, t}"
    proof-
      have ?t: "(?z. (- (1 / (t * snd z)), 1 / (t * fst z))) = ? ??BIJ? t"
        unfolding ?_def t_def BIJ_def by auto
      show ?thesis 
        apply(rule generate.simps[THEN iffD2])
        using ?t ?_gen[folded ?_def] t_gen[folded t_def] by auto
    qed
    show 
      "(?z. (- (1 / (t * fst z)), - (1 / (t * snd z)))) ? generate BIJ {?, t}"
    proof-
      have ??t: 
        "(?z. (- (1 / (t * fst z)), - (1 / (t * snd z)))) = 
        (?z. (- fst z, - snd z)) ??BIJ? t"
        unfolding t_def BIJ_def by auto
      show ?thesis 
        apply(rule generate.simps[THEN iffD2])
        using ??t ??_gen t_gen[folded t_def] by auto
    qed
    show "(?z. (1 / (t * snd z), - (1 / (t * fst z)))) ? generate BIJ {?, t}"
    proof-
      have inv_?_t: 
        "(?z. (1 / (t * snd z), - (1 / (t * fst z)))) = 
        (?z. (snd z, - fst z)) ??BIJ? t"
        unfolding t_def BIJ_def by auto
      show ?thesis 
        apply(rule generate.simps[THEN iffD2])
        using inv_?_t inv_?_gen t_gen[folded t_def] by auto
    qed
  qed 
qed

lemma "group (BIJ?carrier := (generate BIJ {?, t})?)"
proof-
  have ?t_ss_BIJ: "{?, t} ? carrier BIJ" 
    using bij_? bij_t unfolding BIJ_def by simp
  interpret ?t: subgroup "(generate BIJ {?, t})" BIJ 
    using ?t_ss_BIJ by (rule bij.generate_is_subgroup)
  show ?thesis by (rule ?t.subgroup_is_group[OF bij.group_axioms])
qed

lemma id_pair_def: "(?x. x) = (?z. (fst z, snd z))" by simp

lemma distinct_single: "distinct [x] = True" by simp

lemma ne_ff'_gg'_imp_ne_fgf'g':
  assumes "f ? f' ? g ? g'"
  shows 
    "(?z. (f (fst z) (snd z), g (fst z) (snd z))) ? 
    (?z. (f' (fst z) (snd z), g' (fst z) (snd z)))"
  using assms
proof(rule disjE)
  assume "f ? f'"
  then obtain x y where "f x y ? f' x y" by blast  
  then show ?thesis by (metis (hide_lams) fst_eqD snd_eqD)
next
  assume "g ? g'"
  then obtain x y where "g x y ? g' x y" by blast  
  then show ?thesis by (metis (hide_lams) fst_eqD snd_eqD)
qed

lemma id_ne_hyp: "(?a. a) ? (?a. 1/(t*a))" 
proof(rule ccontr, simp)
  assume id_eq_hyp: "(?a. a) = (?a. 1/(t*a))"
  {
    fix a :: real assume "a > 0"
    define b where "b = sqrt(a)"
    from ‹a > 0› have "a = b*b" and "b > 0" unfolding b_def by auto
    from id_eq_hyp have "b = 1/(t*b)" by metis
    with ‹b > 0› have "b div b =(1/(t*b)) div b" by simp
    with ‹b > 0› have "1 = (1/(t*a))" unfolding ‹a = b*b› by simp
    with ‹a > 0› nz_t have "t*a = 1" by simp
  }
  note ta_eq_one = this
  define t2 where "t2 = (if t > 0 then 2/t else -2/t)" 
  with nz_t have "t2 > 0" unfolding t2_def by auto
  from nz_t have "t*t2 = 2 ? t*t2 = -2" unfolding t2_def by auto
  from ta_eq_one ‹t2 > 0› this show False by auto
qed

lemma id_ne_mhyp: "(?a. a) ? (?a. -1/(t*a))"
proof(rule ccontr, simp)
  assume id_eq_hyp: "(?a. a) = (?a. -(1/(t*a)))"
  {
    fix a :: real assume "a > 0"
    define b where "b = sqrt(a)"
    from ‹a > 0› have "a = b*b" and "b > 0" unfolding b_def by auto
    from id_eq_hyp have "b = -(1/(t*b))" by metis
    with ‹b > 0› have "b div b =-1/(t*b) div b" by simp
    with ‹b > 0› have "1 = -1/(t*a)" unfolding ‹a = b*b› by simp
    with ‹a > 0› nz_t have "t*a = -1" by (metis divide_eq_1_iff)
  }
  note ta_eq_one = this
  define t2 where "t2 = (if t > 0 then 2/t else -2/t)" 
  with nz_t have "t2 > 0" unfolding t2_def by auto
  from nz_t have "t*t2 = 2 ? t*t2 = -2" unfolding t2_def by auto
  from ta_eq_one ‹t2 > 0› this show False by auto
qed

lemma mid_ne_hyp: "(?a. -a) ? (?a. 1 / (t*a))"
  using id_ne_mhyp by (metis minus_divide_left minus_equation_iff)

lemma mid_ne_mhyp: "(?a. -a) ? (?a. -1 / (t*a))"
  using id_ne_hyp by (metis divide_minus_left minus_equation_iff)

lemma hyp_neq_hyp_1: "(?a. - 1/(t*a)) ? (?a. 1/(t*a))"
  using nz_t 
  by (metis divide_cancel_right id_ne_mhyp mult_cancel_right1 mult_left_cancel 
      one_neq_neg_one)

lemma distinct:
  "distinct 
    [
      id,
      (?z. (-snd z, fst z)),
      (?z. (-fst z, -snd z)),
      (?z. (snd z, -fst z)),
      (?z. (1/(t*fst z), 1/(t*snd z))),
      (?z. (-1/(t*snd z), 1/(t*fst z))),
      (?z. (-1/(t*fst z), -1/(t*snd z))),
      (?z. (1/(t*snd z), -1/(t*fst z)))
    ]"
  apply(unfold distinct_length_2_or_more)+
  unfolding 
    distinct_length_2_or_more
    distinct_single
    id_def id_pair_def
    HOL.simp_thms(21)
  by 
    (intro conjI) 
    (
      rule ne_ff'_gg'_imp_ne_fgf'g', 
      metis one_neq_neg_one id_ne_hyp id_ne_mhyp
      mid_ne_hyp mid_ne_mhyp hyp_neq_hyp_1
    )+ 

lemma "card S = 8"
  using distinct unfolding S_def using card_empty card_insert_disjoint by auto
