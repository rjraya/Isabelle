theory Hales
  imports Complex_Main "HOL-Algebra.Group" "HOL-Algebra.Bij"
          "HOL-Library.Bit" 
          
begin

section\<open>Edwards curves\<close>

locale curve_addition =
  fixes c d :: real
begin      

definition e :: "real \<Rightarrow> real \<Rightarrow> real" where
 "e x y = x^2 + c * y^2 - 1 - d * x^2 * y^2"

definition delta_plus :: "real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real" where
 "delta_plus x1 y1 x2 y2 = 1 + d * x1 * y1 * x2 * y2"

definition delta_minus :: "real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real" where
 "delta_minus x1 y1 x2 y2 = 1 - d * x1 * y1 * x2 * y2"

definition delta :: "real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real" where
 "delta x1 y1 x2 y2 = (delta_plus x1 y1 x2 y2) * 
                      (delta_minus x1 y1 x2 y2)"

fun add :: "real \<times> real \<Rightarrow> real \<times> real \<Rightarrow> real \<times> real" where
 "add (x1,y1) (x2,y2) =
    ((x1*x2 - c*y1*y2) div (1-d*x1*y1*x2*y2), 
     (x1*y2+y1*x2) div (1+d*x1*y1*x2*y2))"

lemma add_with_deltas:
 "add (x1,y1) (x2,y2) =
    ((x1*x2 - c*y1*y2) div (delta_minus x1 y1 x2 y2), 
     (x1*y2+y1*x2) div (delta_plus x1 y1 x2 y2))"
  unfolding delta_minus_def delta_plus_def
  by(simp add: algebra_simps)

lemma commutativity: "add z1 z2 = add z2 z1"
  by(cases "z1",cases "z2",simp add: algebra_simps)

lemma add_closure: 
  assumes "z3 = (x3,y3)" "z3 = add (x1,y1) (x2,y2)"
  assumes "delta_minus x1 y1 x2 y2 \<noteq> 0" "delta_plus x1 y1 x2 y2 \<noteq> 0"
  assumes "e x1 y1 = 0" "e x2 y2 = 0" 
  shows "e x3 y3 = 0" 
proof -
  have x3_expr: "x3 = (x1*x2 - c*y1*y2) div (delta_minus x1 y1 x2 y2)"
    using assms add_with_deltas by auto
  have y3_expr: "y3 = (x1*y2+y1*x2) div (delta_plus x1 y1 x2 y2)"
    using assms add_with_deltas by auto
  define prod where "prod = 
    -1 + x1^2 * x2^2 + c * x2^2 * y1^2 - d * x1^2 * x2^4 * y1^2 + 
     c * x1^2 * y2^2 - d * x1^4 * x2^2 * y2^2 + c^2 * y1^2 * y2^2 - 
     4 * c * d * x1^2 * x2^2 * y1^2 * y2^2 + 
     2 * d^2 * x1^2 * x2^2 * y1^2 * y2^2 + d^2 * x1^4 * x2^4 * y1^2 * y2^2 - 
     c^2 * d * x2^2 * y1^4 * y2^2 + c * d^2 * x1^2 * x2^4 * y1^4 * y2^2 - 
     c^2 * d * x1^2 * y1^2 * y2^4 + c * d^2 * x1^4 * x2^2 * y1^2 * y2^4 + 
     c^2 * d^2 * x1^2 * x2^2 * y1^4 * y2^4 - 
     d^4 * x1^4 * x2^4 * y1^4 * y2^4"    

  define e1 where "e1 = e x1 y1"
  define e2 where "e2 = e x2 y2"

(*
  Exception!

  have prod_eq_1: "\<exists> r1 r2. 
      (e x3 y3)*(delta x1 y1 x2 y2)\<^sup>2 - (r1 * e1 + r2 * e2) = 0"
    unfolding prod_def e1_def e2_def e_def delta_def
              delta_plus_def delta_minus_def x3_expr y3_expr
    apply(algebra add: assms(5,6))
*)
  have prod_eq_1: "\<exists> r1 r2. prod - (r1 * e1 + r2 * e2) = 0"
    unfolding prod_def e1_def e2_def e_def by algebra

  define a where "a = x1*x2 - c*y1*y2"
  define b where "b = x1*y2+y1*x2"

  have "(e x3 y3)*(delta x1 y1 x2 y2)\<^sup>2 =
         e (a div (delta_minus x1 y1 x2 y2))
           (b div (delta_plus x1 y1 x2 y2)) * (delta x1 y1 x2 y2)\<^sup>2"
    unfolding a_def b_def
    by (simp add: mult.commute mult.left_commute x3_expr y3_expr)
  also have "... = 
    ((a div delta_minus x1 y1 x2 y2)\<^sup>2 +
    c * (b div delta_plus x1 y1 x2 y2)\<^sup>2 -
    1 -
    d * (a div delta_minus x1 y1 x2 y2)\<^sup>2 *
   (b div delta_plus x1 y1 x2 y2)\<^sup>2) * (delta x1 y1 x2 y2)\<^sup>2"
    unfolding delta_plus_def delta_minus_def delta_def e_def by simp
  also have "... = 
    ((a div delta_minus x1 y1 x2 y2)\<^sup>2 * (delta x1 y1 x2 y2)\<^sup>2 +
    c * (b div delta_plus x1 y1 x2 y2)\<^sup>2 * (delta x1 y1 x2 y2)\<^sup>2 -
    1 * (delta x1 y1 x2 y2)\<^sup>2 -
    d * (a div delta_minus x1 y1 x2 y2)\<^sup>2 *
   (b div delta_plus x1 y1 x2 y2)\<^sup>2 * (delta x1 y1 x2 y2)\<^sup>2)"
    by(simp add: algebra_simps)
  also have "... = 
    ((a * delta_plus x1 y1 x2 y2)\<^sup>2 + c * (b * delta_minus x1 y1 x2 y2)\<^sup>2 -
     (delta x1 y1 x2 y2)\<^sup>2 - d * a\<^sup>2 * b\<^sup>2)"
   unfolding delta_def by(simp add: field_simps assms(3,4))+
  also have "... - prod = 0"
    unfolding prod_def delta_plus_def delta_minus_def delta_def a_def b_def by algebra
  finally have "(e x3 y3)*(delta x1 y1 x2 y2)\<^sup>2 = prod" by simp
  then have prod_eq_2: "(e x3 y3) = prod div (delta x1 y1 x2 y2)\<^sup>2"
    using assms(3,4) delta_def by auto

  have "e1 = 0" unfolding e1_def using assms(5) by simp
  moreover have "e2 = 0" unfolding e2_def using assms(6) by simp
  ultimately have "prod = 0" using prod_eq_1 by simp
  then show "e x3 y3 = 0" using prod_eq_2 by simp
qed
                      
lemma associativity: 
  assumes "z1' = (x1',y1')" "z3' = (x3',y3')"
  assumes "z1' = add (x1,y1) (x2,y2)" "z3' = add (x2,y2) (x3,y3)"
  assumes "delta_minus x1 y1 x2 y2 \<noteq> 0" "delta_plus x1 y1 x2 y2 \<noteq> 0"
          "delta_minus x2 y2 x3 y3 \<noteq> 0" "delta_plus x2 y2 x3 y3 \<noteq> 0"
          "delta_minus x1' y1' x3 y3 \<noteq> 0" "delta_plus x1' y1' x3 y3 \<noteq> 0"
          "delta_minus x1 y1 x3' y3' \<noteq> 0" "delta_plus x1 y1 x3' y3' \<noteq> 0"
  assumes "e x1 y1 = 0" "e x2 y2 = 0" "e x3 y3 = 0" 
  shows "add (add (x1,y1) (x2,y2)) (x3,y3) = add (x1,y1) (add (x2,y2) (x3,y3))" 
proof -
 define e1 where "e1 = e x1 y1"
 define e2 where "e2 = e x2 y2"
 define e3 where "e3 = e x3 y3"
 define Delta\<^sub>x where "Delta\<^sub>x = 
   (delta_minus x1' y1' x3 y3)*(delta_minus x1 y1 x3' y3')*
   (delta x1 y1 x2 y2)*(delta x2 y2 x3 y3)" 
 define Delta\<^sub>y where "Delta\<^sub>y =
   (delta_plus x1' y1' x3 y3)*(delta_plus x1 y1 x3' y3')*
   (delta x1 y1 x2 y2)*(delta x2 y2 x3 y3)" 
 define g\<^sub>x :: real where "g\<^sub>x = fst(add z1' (x3,y3)) - fst(add (x1,y1) z3')"
 define g\<^sub>y where "g\<^sub>y = snd(add z1' (x3,y3)) - snd(add (x1,y1) z3')"
 define gxpoly where "gxpoly = g\<^sub>x * Delta\<^sub>x"
  define gypoly where "gypoly = g\<^sub>y * Delta\<^sub>y"

  define gxpoly_expr where "gxpoly_expr = 
    d*x2* y2* (x1^2* x2* x3* y1-x1^2* x2* x3^3* y1-c* x1* x3* y1^2* y2+d* x1^3* x2^2* x3* y1^2* y2
    +c* x1* x3^3* y1^2* y2-d* x1^3* x2^2* x3^3* y1^2* y2-c* d* x1^2* x2* x3* y1^3* y2^2+c* d* x1^2* x2* x3^3* y1^3* y2^2
    -x1* x2* x3^2* y3+x1^3* x2* x3^2* y3+c* x1* x2* y1^2* y3-d* x1^3* x2^3* x3^2* y1^2* y3+c* x1^2* y1* y2* y3
    -c* x3^2* y1* y2* y3-c* d* x1^2* x2^2* y1^3* y2* y3+c^2* x3^2* y1^3* y2* y3-c* d* x1^3* x2* y1^2* y2^2* y3
    +d^2* x1^3* x2^3* x3^2* y1^2* y2^2* y3-c^2* d* x1^2* x3^2* y1^3* y2^3* y3+c* d^2* x1^2* x2^2* x3^2* y1^3* y2^3* y3
    -c* x2* x3* y1* y3^2+d* x1^2* x2^3* x3^3* y1* y3^2+c^2* x2* x3* y1^3* y3^2-c* d* x1^2* x2^3* x3* y1^3* y3^2
    +c* x1* x3* y2* y3^2-c* x1^3* x3* y2* y3^2-d* x1* x2^2* x3^3* y2* y3^2+d* x1^3* x2^2* x3^3* y2* y3^2
    +c* d* x2* x3^3* y1* y2^2* y3^2-d^2* x1^2* x2^3* x3^3* y1* y2^2* y3^2+c* d^2* x1^2* x2^3* x3* y1^3* y2^2* y3^2
    -c^2* d *x2* x3^3* y1^3* y2^2* y3^2+c^2* d* x1^3* x3* y1^2* y2^3* y3^2-c* d^2* x1^3 *x2^2* x3* y1^2* y2^3* y3^2
    -c^2* d* x1* x3^3* y1^2* y2^3* y3^2+c* d^2* x1* x2^2* x3^3* y1^2* y2^3* y3^2-c^2* x1* x2* y1^2* y3^3
    +c* d* x1* x2^3* x3^2* y1^2* y3^3-c^2* x1^2* y1* y2* y3^3+c* d* x2^2* x3^2* y1* y2* y3^3+c^2* d* x1^2* x2^2* y1^3* y2* y3^3
    -c^2* d* x2^2* x3^2* y1^3* y2* y3^3+c* d* x1* x2* x3^2* y2^2* y3^3-c* d *x1^3* x2* x3^2* y2^2* y3^3
    +c^2* d* x1^3* x2* y1^2* y2^2* y3^3-c* d^2* x1* x2^3* x3^2* y1^2* y2^2* y3^3+c^2* d* x1^2* x3^2* y1* y2^3* y3^3
    -c* d^2* x1^2* x2^2* x3^2* y1* y2^3* y3^3)"

  define gypoly_expr where "gypoly_expr = 
   -d* x2* y2* (x1* x2* x3* y1^2-x1* x2* x3^3* y1^2+x1^2* x3* y1* y2-x1^2* x3^3* y1* y2-d* x1^2* x2^2* x3* y1^3* y2
   +d* x1^2* x2^2* x3^3* y1^3* y2-d* x1^3* x2* x3* y1^2* y2^2+d* x1^3* x2* x3^3* y1^2 *y2^2-x1^2* x2* y1* y3
   +x2* x3^2* y1* y3-c* x2* x3^2* y1^3* y3+d* x1^2* x2^3* x3^2* y1^3* y3-x1* x3^2* y2* y3+x1^3* x3^2* y2* y3
   +c* x1* y1^2* y2* y3-d* x1^3* x2^2* y1^2* y2* y3+c* d* x1^2* x2* y1^3* y2^2* y3-d^2* x1^2* x2^3* x3^2* y1^3* y2^2* y3
   -c* d* x1^3* x3^2* y1^2* y2^3* y3+d^2* x1^3* x2^2* x3^2* y1^2* y2^3* y3-x1* x2* x3* y3^2+x1^3* x2* x3* y3^2
   -d* x1^3* x2^3* x3* y1^2* y3^2+d* x1* x2^3* x3^3* y1^2* y3^2-c* x3* y1* y2* y3^2+d *x2^2* x3^3* y1* y2* y3^2
   +c^2* x3* y1^3* y2* y3^2-c* d* x2^2* x3^3* y1^3* y2 *y3^2+d* x1* x2* x3^3* y2^2* y3^2-d* x1^3* x2* x3^3* y2^2* y3^2
   +d^2* x1^3* x2^3* x3 *y1^2* y2^2* y3^2-d^2* x1* x2^3* x3^3* y1^2* y2^2* y3^2+c* d* x1^2* x3^3* y1* y2^3* y3^2
   -d^2* x1^2* x2^2* x3^3* y1* y2^3* y3^2-c^2* d* x1^2* x3* y1^3* y2^3* y3^2+c* d^2* x1^2* x2^2* x3* y1^3* y2^3* y3^2
   +c* x1^2* x2* y1* y3^3-d* x1^2* x2^3* x3^2* y1* y3^3+d* x1* x2^2* x3^2* y2* y3^3-d* x1^3* x2^2* x3^2* y2* y3^3
   -c^2* x1* y1^2 *y2* y3^3+c* d *x1^3* x2^2* y1^2* y2* y3^3-c* d* x2* x3^2* y1* y2^2* y3^3+d^2* x1^2* x2^3* x3^2* y1* y2^2* y3^3
   -c^2* d* x1^2* x2* y1^3* y2^2* y3^3+c^2* d* x2* x3^2* y1^3* y2^2* y3^3+c^2* d* x1* x3^2* y1^2* y2^3* y3^3
   -c* d^2* x1* x2^2* x3^2* y1^2* y2^3* y3^3)"

  have x1'_expr: "x1' = (x1 * x2 - c * y1 * y2) / (1 - d * x1 * y1 * x2 * y2)"
    using assms(1,3) by auto
  have y1'_expr: "y1' = (x1 * y2 + y1 * x2) / (1 + d * x1 * y1 * x2 * y2)"
    using assms(1,3) by auto
  have x3'_expr: "x3' = (x2 * x3 - c * y2 * y3) / (1 - d * x2 * y2 * x3 * y3)"
    using assms(2,4) by auto
  have y3'_expr: "y3' = (x2 * y3 + y2 * x3) / (1 + d * x2 * y2 * x3 * y3)"
    using assms(2,4) by auto
  
  have non_unfolded_adds:
      "delta x1 y1 x2 y2 \<noteq> 0" using delta_def assms(5,6) by auto
  
  have gx_div: "\<exists> r1 r2 r3. gxpoly_expr = r1 * e1 + r2 * e2 + r3 * e3"
    unfolding gxpoly_expr_def e1_def e2_def e3_def e_def 
    by algebra

  have gy_div: "\<exists> r1 r2 r3. gypoly_expr = r1 * e1 + r2 * e2 + r3 * e3"
    unfolding gypoly_expr_def e1_def e2_def e3_def e_def 
    by algebra

  have simp1gx: "
    (x1' * x3 - c * y1' * y3) * delta_minus x1 y1 x3' y3' *
    (delta x1 y1 x2 y2 * delta x2 y2 x3 y3) = 
    ((x1 * x2 - c * y1 * y2) * x3 * delta_plus x1 y1 x2 y2 -
     c * (x1 * y2 + y1 * x2) * y3 * delta_minus x1 y1 x2 y2) *
    (delta_minus x2 y2 x3 y3 * delta_plus x2 y2 x3 y3 -
     d * x1 * y1 * (x2 * x3 - c * y2 * y3) * (x2 * y3 + y2 * x3))
  "
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply((subst delta_minus_def[symmetric])+,(subst delta_plus_def[symmetric])+)
    apply(subst (3) delta_minus_def)
    unfolding delta_def
    by(simp add: divide_simps assms(5-8))

  have simp2gx:
    "(x1 * x3' - c * y1 * y3') * delta_minus x1' y1' x3 y3 *
    (delta x1 y1 x2 y2 * delta x2 y2 x3 y3) = 
    (x1 * (x2 * x3 - c * y2 * y3) * delta_plus x2 y2 x3 y3 -
     c * y1 * (x2 * y3 + y2 * x3) * delta_minus x2 y2 x3 y3) *
    (delta_minus x1 y1 x2 y2 * delta_plus x1 y1 x2 y2 -
     d * (x1 * x2 - c * y1 * y2) * (x1 * y2 + y1 * x2) * x3 * y3)"
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply((subst delta_minus_def[symmetric])+,(subst delta_plus_def[symmetric])+)
    apply(subst (3) delta_minus_def)
    unfolding delta_def
    by(simp add: divide_simps assms(5-8))

  have "gxpoly = gxpoly_expr"
    unfolding gxpoly_def g\<^sub>x_def Delta\<^sub>x_def 
    apply(simp add: assms(1,2))
    apply(subst delta_minus_def[symmetric])+
    apply(simp add: divide_simps assms(9,11))
    apply(subst (3) left_diff_distrib)
    apply(simp add: simp1gx simp2gx)
    unfolding delta_minus_def delta_plus_def (* equality *)
    unfolding gxpoly_expr_def
    by algebra

  obtain r1x r2x r3x where "gxpoly = r1x * e1 + r2x * e2 + r3x * e3"
    using \<open>gxpoly = gxpoly_expr\<close> gx_div by auto
  then have "gxpoly = 0" 
    using e1_def assms(13-15) e2_def e3_def by auto
  have "Delta\<^sub>x \<noteq> 0" 
    using Delta\<^sub>x_def delta_def assms(7-11) non_unfolded_adds by auto
  then have "g\<^sub>x = 0" 
    using \<open>gxpoly = 0\<close> gxpoly_def by auto

  have simp1gy: "(x1' * y3 + y1' * x3) * local.delta_plus x1 y1 x3' y3' *
    (local.delta x1 y1 x2 y2 * local.delta x2 y2 x3 y3) = 
    ((x1 * x2 - c * y1 * y2) * y3 * local.delta_plus x1 y1 x2 y2 +
     (x1 * y2 + y1 * x2) * x3 * local.delta_minus x1 y1 x2 y2) *
    (local.delta_minus x2 y2 x3 y3 * local.delta_plus x2 y2 x3 y3 +
     d * x1 * y1 * (x2 * x3 - c * y2 * y3) * (x2 * y3 + y2 * x3))"
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply((subst delta_minus_def[symmetric])+,(subst delta_plus_def[symmetric])+)
    apply(subst (2) delta_plus_def)
    unfolding delta_def
    by(simp add: divide_simps assms(5-8))

  have simp2gy: "(x1 * y3' + y1 * x3') * local.delta_plus x1' y1' x3 y3 *
    (local.delta x1 y1 x2 y2 * local.delta x2 y2 x3 y3) = 
     (x1 * (x2 * y3 + y2 * x3) * local.delta_minus x2 y2 x3 y3 +
     y1 * (x2 * x3 - c * y2 * y3) * local.delta_plus x2 y2 x3 y3) *
    (local.delta_minus x1 y1 x2 y2 * local.delta_plus x1 y1 x2 y2 +
     d * (x1 * x2 - c * y1 * y2) * (x1 * y2 + y1 * x2) * x3 * y3)"
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply((subst delta_minus_def[symmetric])+,(subst delta_plus_def[symmetric])+)
    apply(subst (3) delta_plus_def)
    unfolding delta_def
    by(simp add: divide_simps assms(5-8))

  have "gypoly = gypoly_expr"
    unfolding gypoly_def g\<^sub>y_def Delta\<^sub>y_def 
    apply(simp add: assms(1,2))
    apply(subst delta_plus_def[symmetric])+
    apply(simp add: divide_simps assms(10,12))
    apply(subst left_diff_distrib)
    apply(simp add: simp1gy simp2gy)
    unfolding delta_minus_def delta_plus_def (* equality *)
    unfolding gypoly_expr_def
    by algebra

  obtain r1y r2y r3y where "gypoly = r1y * e1 + r2y * e2 + r3y * e3"
    using \<open>gypoly = gypoly_expr\<close> gy_div by auto
  then have "gypoly = 0" 
    using e1_def assms(13-15) e2_def e3_def by auto
  have "Delta\<^sub>y \<noteq> 0" 
    using Delta\<^sub>y_def delta_def assms(7-12) non_unfolded_adds by auto
  then have "g\<^sub>y = 0" 
    using \<open>gypoly = 0\<close> gypoly_def by auto

  show ?thesis 
    using \<open>g\<^sub>y = 0\<close> \<open>g\<^sub>x = 0\<close> 
    unfolding g\<^sub>x_def g\<^sub>y_def assms(3,4)
    by (simp add: prod_eq_iff)
qed

lemma neutral: "add z (1,0) = z" by(cases "z",simp)

lemma inverse:
  assumes "e a b = 0" "delta_plus a b a b \<noteq> 0" 
  shows "add (a,b) (a,-b) = (1,0)" 
  using assms by(simp add: delta_plus_def e_def,algebra) 

corollary 
  assumes "e a b = 0" "delta_plus a b a b \<noteq> 0" 
  shows "delta_minus a b a (-b) \<noteq> 0" 
  using inverse[OF assms] assms(1) unfolding e_def delta_def delta_plus_def delta_minus_def
  by(simp)
  

lemma affine_closure:
  assumes "delta x1 y1 x2 y2 = 0" "e x1 y1 = 0" "e x2 y2 = 0"
  shows "\<exists> b. (1/d = b^2 \<and> 1/d \<noteq> 0) \<or> (1/(c*d) = b^2 \<and> 1/(c*d) \<noteq> 0)" 
proof -
  define r where "r = (1 - c*d*y1^2*y2^2) * (1 - d*y1^2*x2^2)" 
  define e1 where "e1 = e x1 y1"
  define e2 where "e2 = e x2 y2"
  have "r = d^2 * y1^2 * y2^2 * x2^2 * e1 + (1 - d * y1^2) * delta x1 y1 x2 y2 - d * y1^2 * e2"
    unfolding r_def e1_def e2_def delta_def delta_plus_def delta_minus_def e_def
    by algebra 
  then have "r = 0" 
    using assms e1_def e2_def by simp
  then have cases: "(1 - c*d*y1^2*y2^2) = 0 \<or> (1 - d*y1^2*x2^2) = 0" 
    using r_def by auto
  have "d \<noteq> 0" using \<open>r = 0\<close> r_def by auto
  {assume "(1 - d*y1^2*x2^2) = 0"
  then have "1/d = y1^2*x2^2" "1/d \<noteq> 0"
    by(auto simp add: divide_simps \<open>d \<noteq> 0\<close>,argo)}
  note case1 = this
  {assume "(1 - c*d*y1^2*y2^2) = 0" "(1 - d*y1^2*x2^2) \<noteq> 0"
    then have "c \<noteq> 0" by auto
    then have "1/(c*d) = y1^2*y2^2" "1/(c*d) \<noteq> 0" 
      apply(simp add: divide_simps \<open>d \<noteq> 0\<close> \<open>c \<noteq> 0\<close>) 
      using \<open>(1 - c*d*y1^2*y2^2) = 0\<close> apply argo
      using \<open>c \<noteq> 0\<close> \<open>d \<noteq> 0\<close> by auto
  }
  note case2 = this
  
  show "\<exists> b. (1/d = b^2 \<and> 1/d \<noteq> 0) \<or> (1/(c*d) = b^2 \<and> 1/(c*d) \<noteq> 0)" 
    using cases case1 case2 by (metis power_mult_distrib)
qed

lemma delta_non_zero:
  fixes x1 y1 x2 y2
  assumes "e x1 y1 = 0" "e x2 y2 = 0"
  assumes "\<exists> b. 1/c = b^2" "\<not> (\<exists> b. b \<noteq> 0 \<and> 1/d = b^2)"
  shows "delta x1 y1 x2 y2 \<noteq> 0"
proof(rule ccontr)
  assume "\<not> delta x1 y1 x2 y2 \<noteq> 0"
  then have "delta x1 y1 x2 y2 = 0" by blast
  then have "\<exists> b. (1/d = b^2 \<and> 1/d \<noteq> 0) \<or> (1/(c*d) = b^2 \<and> 1/(c*d) \<noteq> 0)" 
   using affine_closure[OF \<open>delta x1 y1 x2 y2 = 0\<close> 
                            \<open>e x1 y1 = 0\<close> \<open>e x2 y2 = 0\<close>] by blast
  then obtain b where "(1/(c*d) = b^2 \<and> 1/(c*d) \<noteq> 0)"
   using \<open>\<not> (\<exists> b. b \<noteq> 0 \<and> 1/d = b^2)\<close> by fastforce
  then have "1/c \<noteq> 0" "c \<noteq> 0" "d \<noteq> 0" "1/d \<noteq> 0" by simp+
  then have "1/d = b^2 / (1/c)"
   apply(simp add: divide_simps)
   by (metis \<open>1 / (c * d) = b\<^sup>2 \<and> 1 / (c * d) \<noteq> 0\<close> eq_divide_eq semiring_normalization_rules(18))
  then have "\<exists> b. b \<noteq> 0 \<and> 1/d = b^2"
   using assms(3) 
   by (metis \<open>1 / d \<noteq> 0\<close> power_divide zero_power2)
  then show "False"
   using \<open>\<not> (\<exists> b. b \<noteq> 0 \<and> 1/d = b^2)\<close> by blast
qed

lemma group_law:
  assumes "\<exists> b. 1/c = b^2" "\<not> (\<exists> b. b \<noteq> 0 \<and> 1/d = b^2)"
  shows "comm_group \<lparr>carrier = {(x,y). e x y = 0}, mult = add, one = (1,0)\<rparr>" 
proof(unfold_locales)
  {fix x1 y1 x2 y2
  assume "e x1 y1 = 0" "e x2 y2 = 0"
  have "e (fst (add (x1,y1) (x2,y2))) (snd (add (x1,y1) (x2,y2))) = 0"
    apply(simp)
    using add_closure delta_non_zero[OF \<open>e x1 y1 = 0\<close> \<open>e x2 y2 = 0\<close> assms(1) assms(2)] 
          delta_def \<open>e x1 y1 = 0\<close> \<open>e x2 y2 = 0\<close> by auto}
  then show "
      \<And>x y. x \<in> carrier \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr> \<Longrightarrow>
             y \<in> carrier \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr> \<Longrightarrow>
           x \<otimes>\<^bsub>\<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub> y
           \<in> carrier \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>" by auto
next
  {fix x1 y1 x2 y2 x3 y3 
   assume "e x1 y1 = 0" "e x2 y2 = 0" "e x3 y3 = 0" 
   then have "delta x1 y1 x2 y2 \<noteq> 0" "delta x2 y2 x3 y3 \<noteq> 0"
     using assms(1,2) delta_non_zero by blast+
   fix x1' y1' x3' y3'
   assume "(x1',y1') = add (x1,y1) (x2,y2)"
          "(x3',y3') = add (x2,y2) (x3,y3)"
   then have "e x1' y1' = 0" "e x3' y3' = 0"
     using add_closure \<open>delta x1 y1 x2 y2 \<noteq> 0\<close> \<open>delta x2 y2 x3 y3 \<noteq> 0\<close> 
           \<open>e x1 y1 = 0\<close> \<open>e x2 y2 = 0\<close> \<open>e x3 y3 = 0\<close> delta_def by fastforce+
   then have "delta x1' y1' x3 y3 \<noteq> 0" "delta x1 y1 x3' y3' \<noteq> 0"
     using assms delta_non_zero \<open>e x3 y3 = 0\<close> apply blast
    by (simp add: \<open>e x1 y1 = 0\<close> \<open>e x3' y3' = 0\<close> assms delta_non_zero)

  have "add (add (x1,y1) (x2,y2)) (x3,y3) =
        add (x1,y1) (local.add (x2,y2) (x3,y3))"
    using associativity 
    by (metis \<open>(x1', y1') = add (x1, y1) (x2, y2)\<close> \<open>(x3', y3') = add (x2, y2) (x3, y3)\<close> \<open>delta x1 y1 x2 y2 \<noteq> 0\<close> 
              \<open>delta x1 y1 x3' y3' \<noteq> 0\<close> \<open>delta x1' y1' x3 y3 \<noteq> 0\<close> \<open>delta x2 y2 x3 y3 \<noteq> 0\<close> \<open>e x1 y1 = 0\<close> 
              \<open>e x2 y2 = 0\<close> \<open>e x3 y3 = 0\<close> delta_def mult_eq_0_iff)}

  then show "
    \<And>x y z.
       x \<in> carrier \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr> \<Longrightarrow>
       y \<in> carrier \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr> \<Longrightarrow>
       z \<in> carrier \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr> \<Longrightarrow>
       x \<otimes>\<^bsub>\<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub>
       y \<otimes>\<^bsub>\<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub>
       z =
       x \<otimes>\<^bsub>\<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub>
      (y \<otimes>\<^bsub>\<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub>
       z)" by auto
next
  show "
   \<one>\<^bsub>\<lparr>carrier = {(x, y). e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub>
    \<in> carrier \<lparr>carrier = {(x, y). e x y = 0}, mult = local.add, one = (1, 0)\<rparr>"
    by (simp add: e_def)
next
  show "
   \<And>x. x \<in> carrier \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr> \<Longrightarrow>
        \<one>\<^bsub>\<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub> \<otimes>\<^bsub>\<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub> x = x"
    by (simp add: commutativity neutral)
next
  show "\<And>x. x \<in> carrier \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr> \<Longrightarrow>
             x \<otimes>\<^bsub>\<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub>
         \<one>\<^bsub>\<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub> = x"
    by (simp add: neutral)
next
  show "\<And>x y. x \<in> carrier \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr> \<Longrightarrow>
              y \<in> carrier \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr> \<Longrightarrow>
           x \<otimes>\<^bsub>\<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub> y =
           y \<otimes>\<^bsub>\<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>\<^esub> x"
    using commutativity by auto
next
  show "
   carrier \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>
   \<subseteq> Units \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add, one = (1, 0)\<rparr>"
  proof(simp,standard)
    fix z
    assume "z \<in> {(x, y). local.e x y = 0}"
    show "z \<in> Units
        \<lparr>carrier = {(x, y). local.e x y = 0}, mult = local.add,
           one = (1, 0)\<rparr>" 
      unfolding Units_def 
    proof(simp, cases "z", rule conjI) 
      fix x y
      assume "z = (x,y)" 
      from this \<open>z \<in> {(x, y). local.e x y = 0}\<close>
      show "case z of (x, y) \<Rightarrow> local.e x y = 0" by blast  
      then obtain x y where "z = (x,y)" "e x y = 0" by blast
      have "e x (-y) = 0" 
        using \<open>e x y = 0\<close> unfolding e_def by simp
      have "add (x,y) (x,-y) = (1,0)" 
        using inverse[OF \<open>e x y = 0\<close> ] delta_non_zero[OF \<open>e x y = 0\<close> \<open>e x y = 0\<close> assms] delta_def by fastforce        
      then have "add (x,-y) (x,y) = (1,0)" by simp
      show "\<exists>a b. e a b = 0 \<and>
                  add (a, b) z = (1, 0) \<and> 
                  add z (a, b) = (1, 0)" 
        using \<open>add (x, y) (x, - y) = (1, 0)\<close> 
              \<open>e x (- y) = 0\<close> \<open>z = (x, y)\<close> by fastforce
    qed
  qed
qed
end

section\<open>Projective curves\<close>
(* Generalize for c \<noteq> 1 *)
locale ext_curve_addition = curve_addition +
  assumes c_eq_1: "c = 1" 
  assumes t_intro: "\<exists> b'. d = (b')^2"
  assumes t_ineq: "sqrt(d)^2 \<noteq> 1" "sqrt(d) \<noteq> 0"
begin

definition t where "t = sqrt(d)"
definition e' where "e' x y = x^2 + y^2 - 1 - t^2 * x^2 * y^2"

lemma c_d_pos: "d \<ge> 0" using t_intro by auto

lemma delta_plus_self: "delta_plus x0 y0 x0 y0 \<noteq> 0" 
    unfolding delta_plus_def
    apply(subst (1) mult.assoc,subst (2) mult.assoc,subst (1) mult.assoc)
    apply(subst power2_eq_square[symmetric])
    using mult_nonneg_nonneg[OF c_d_pos zero_le_power2[of "x0*y0"]] by auto

lemma t_nz: "t \<noteq> 0" using t_def t_ineq(2) by auto

lemma d_nz: "d \<noteq> 0" using t_def t_nz by simp

lemma t_expr: "t^2 = d" "t^4 = d^2" using t_def t_intro by auto

lemma e_e'_iff: "e x y = 0 \<longleftrightarrow> e' x y = 0"
  unfolding e_def e'_def using c_eq_1 t_expr(1) by simp

lemma t_sq_n1: "t^2 \<noteq> 1"  using t_ineq(1) t_def by simp

lemma d_n1: "d \<noteq> 1" using t_sq_n1 t_expr by blast
 
text\<open>The case t^2 = 1 corresponds to a product of intersecting lines 
     which cannot be a group\<close>

lemma t_2_1_lines:
  "t^2 = 1 \<Longrightarrow> e' x y = - (1 - x^2) * (1 - y^2)" 
  unfolding e'_def by algebra

text\<open>The case t = 0 corresponds to a circle which has been treated before\<close>

lemma t_0_circle:
  "t = 0 \<Longrightarrow> e' x y = x^2 + y^2 - 1" 
  unfolding e'_def by auto

fun \<rho> :: "real \<times> real \<Rightarrow> real \<times> real" where 
  "\<rho> (x,y) = (-y,x)"
fun \<tau> :: "real \<times> real \<Rightarrow> real \<times> real" where 
  "\<tau> (x,y) = (1/(t*x),1/(t*y))"

lemma tau_sq: "(\<tau> \<circ> \<tau>) (x,y) = (x,y)" by(simp add: t_nz)

lemma tau_idemp: "\<tau> \<circ> \<tau> = id"
  using t_nz comp_def by auto 

fun i :: "real \<times> real \<Rightarrow> real \<times> real" where 
  "i (a,b) = (a,-b)" 

fun ext_add :: "real \<times> real \<Rightarrow> real \<times> real \<Rightarrow> real \<times> real" where
 "ext_add (x1,y1) (x2,y2) =
    ((x1*y1-x2*y2) div (x2*y1-x1*y2),
     (x1*y1+x2*y2) div (x1*x2+y1*y2))"

lemma ext_add_comm:
  "ext_add (x1,y1) (x2,y2) = ext_add (x2,y2) (x1,y1)"
  by(simp add: divide_simps,argo) 

lemma inversion_invariance_1:
  assumes "x1 \<noteq> 0" "y1 \<noteq> 0" "x2 \<noteq> 0" "y2 \<noteq> 0" 
  shows "add (\<tau> (x1,y1)) (x2,y2) = add (x1,y1) (\<tau> (x2,y2))"
  apply(simp)
  apply(subst c_eq_1)+
  apply(simp add: algebra_simps)
  apply(subst power2_eq_square[symmetric])+
  apply(subst t_expr)+
  apply(rule conjI)
  apply(simp add: divide_simps assms t_nz d_nz)
  apply(simp add: algebra_simps)
  apply(simp add: divide_simps assms t_nz d_nz)
  by(simp add: algebra_simps)

lemma inversion_invariance_2:
  assumes "x1 \<noteq> 0" "y1 \<noteq> 0" "x2 \<noteq> 0" "y2 \<noteq> 0" 
  shows "ext_add (\<tau> (x1,y1)) (x2,y2) = ext_add (x1,y1) (\<tau> (x2,y2))"
  apply(simp add: algebra_simps)
  apply(subst power2_eq_square[symmetric])+
  apply(subst t_expr)+
  apply(rule conjI)
  apply(simp add: divide_simps assms t_nz d_nz)
  apply(simp add: algebra_simps)
  apply(simp add: divide_simps assms t_nz d_nz)
  by(simp add: algebra_simps)

lemma rotation_invariance_1: 
  "add (\<rho> (x1,y1)) (x2,y2) = 
   \<rho> (fst (add (x1,y1) (x2,y2)),snd (add (x1,y1) (x2,y2)))"
  apply(simp)
  apply(subst c_eq_1)+
  by(simp add: algebra_simps divide_simps)

lemma rotation_invariance_2: 
  "ext_add (\<rho> (x1,y1)) (x2,y2) = 
   \<rho> (fst (ext_add (x1,y1) (x2,y2)),snd (ext_add (x1,y1) (x2,y2)))"
  by(simp add: algebra_simps divide_simps)

definition delta_x :: "real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real" where
  "delta_x x1 y1 x2 y2 = x2*y1 - x1*y2"
definition delta_y :: "real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real" where
  "delta_y x1 y1 x2 y2 = x1*x2 + y1*y2"
definition delta' :: "real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real \<Rightarrow> real" where
  "delta' x1 y1 x2 y2 = delta_x x1 y1 x2 y2 * delta_y x1 y1 x2 y2"


lemma ext_add_deltas:
  "ext_add (x1,y1) (x2,y2) =
    ((delta_x x2 y1 x1 y2) div (delta_x x1 y1 x2 y2),
     (delta_y x1 x2 y1 y2) div (delta_y x1 y1 x2 y2))"
  unfolding delta_x_def delta_y_def by(simp)

lemma rotation_invariance_3: 
  "delta x1 y1 (fst (\<rho> (x2,y2))) (snd (\<rho> (x2,y2))) = 
   delta x1 y1 x2 y2"
  by(simp add: delta_def delta_plus_def delta_minus_def,argo)

lemma rotation_invariance_4: 
  "delta' x1 y1 (fst (\<rho> (x2,y2))) (snd (\<rho> (x2,y2))) = 
   - delta' x1 y1 x2 y2"
  by(simp add: delta'_def delta_x_def delta_y_def,argo)

lemma inverse_rule_1:
  "(\<tau> \<circ> i \<circ> \<tau>) (x,y) = i (x,y)" by (simp add: t_nz)
lemma inverse_rule_2:
  "(\<rho> \<circ> i \<circ> \<rho>) (x,y) = i (x,y)" by simp
lemma inverse_rule_3:
  "i (add (x1,y1) (x2,y2)) = add (i (x1,y1)) (i (x2,y2))"
  by(simp add: divide_simps)
lemma inverse_rule_4:
  "i (ext_add (x1,y1) (x2,y2)) = ext_add (i (x1,y1)) (i (x2,y2))"
  by(simp add: algebra_simps divide_simps)

(* Coherence and closure *)

lemma coherence_1:
  assumes "delta_x x1 y1 x2 y2 \<noteq> 0" "delta_minus x1 y1 x2 y2 \<noteq> 0" 
  assumes "e' x1 y1 = 0" "e' x2 y2 = 0"
  shows "delta_x x1 y1 x2 y2 * delta_minus x1 y1 x2 y2 *
         (fst (ext_add (x1,y1) (x2,y2)) - fst (add (x1,y1) (x2,y2)))
         = x2 * y2 * e' x1 y1 - x1 * y1 * e' x2 y2"
  apply(simp)  
  apply(subst (2) delta_x_def[symmetric])
  apply(subst delta_minus_def[symmetric])
  apply(simp add: c_eq_1 assms(1,2) divide_simps)
  unfolding delta_minus_def delta_x_def e'_def
  apply(subst t_expr)+
  by(simp add: power2_eq_square field_simps)  
  
lemma coherence_2:
  assumes "delta_y x1 y1 x2 y2 \<noteq> 0" "delta_plus x1 y1 x2 y2 \<noteq> 0" 
  assumes "e' x1 y1 = 0" "e' x2 y2 = 0"
  shows "delta_y x1 y1 x2 y2 * delta_plus x1 y1 x2 y2 *
         (snd (ext_add (x1,y1) (x2,y2)) - snd (add (x1,y1) (x2,y2)))
         = - x2 * y2 * e' x1 y1 - x1 * y1 * e' x2 y2"
  apply(simp)  
  apply(subst (2) delta_y_def[symmetric])
  apply(subst delta_plus_def[symmetric])
  apply(simp add: c_eq_1 assms(1,2) divide_simps)
  unfolding delta_plus_def delta_y_def e'_def
  apply(subst t_expr)+
  by(simp add: power2_eq_square  field_simps)
  
lemma coherence:
  assumes "delta x1 y1 x2 y2 \<noteq> 0" "delta' x1 y1 x2 y2 \<noteq> 0" 
  assumes "e' x1 y1 = 0" "e' x2 y2 = 0"
  shows "ext_add (x1,y1) (x2,y2) = add (x1,y1) (x2,y2)"
  using coherence_1 coherence_2 delta_def delta'_def assms by auto

lemma ext_add_closure:
  assumes "delta' x1 y1 x2 y2 \<noteq> 0"
  assumes "e' x1 y1 = 0" "e' x2 y2 = 0" 
  assumes "(x3,y3) = ext_add (x1,y1) (x2,y2)"
  shows "e' x3 y3 = 0"
proof -
  have deltas_nz: "delta_x x1 y1 x2 y2 \<noteq> 0"
                  "delta_y x1 y1 x2 y2 \<noteq> 0"
    using assms(1) delta'_def by auto

  define closure1 where "closure1 =
    2 - t^2 + t^2 * x1^2 - 2 * x2^2 - t^2 * x1^2 * x2^2 + 
    t^2 * x2^4 + t^2 * y1^2 + t^4 * x1^2 * y1^2 - 
    t^2 * x2^2 * y1^2 - 2 * y2^2 - t^2 * x1^2 * y2^2 + 
    (4 * t^2 - 2 * t^4) * x2^2 * y2^2 - t^2 * y1^2 * y2^2 + 
    t^2 * y2^4"

  define closure2 where "closure2 = 
    -2 + t^2 + (2 - 2 * t^2) * x1^2 + t^2 * x1^4 + t^2 * x2^2 -
    t^2 * x1^2 * x2^2 + (2 - 2 * t^2) * y1^2 - t^2 * x2^2 * y1^2 + 
    t^2 * y1^4 + t^2 * y2^2 - t^2 * x1^2 * y2^2 + t^4 * x2^2 * y2^2 - 
    t^2 * y1^2 * y2^2"

  define p where "p = 
    -1 * t^4 * (x1^2 * x2^4 * y1^2 -x1^4 * x2^2 * y1^2 + 
    t^2 * x1^4 * y1^4 - x1^2 * x2^2 * y1^4 + x1^4 * x2^2 * y2^2 - 
    x1^2 * x2^4 * y2^2 - x1^4 * y1^2 * y2^2 + 4 * x1^2 * x2^2 * y1^2 * y2^2 - 
    2 * t^2 * x1^2 * x2^2 * y1^2 * y2^2 - x2^4 * y1^2 * y2^2 - x1^2 * y1^4 * y2^2 + 
    x2^2 * y1^4 * y2^2 - x1^2 * x2^2 * y2^4 + t^2 * x2^4 * y2^4 + x1^2 * y1^2 * y2^4 - 
    x2^2 * y1^2 * y2^4)"

  have v3: "x3 = fst (ext_add (x1,y1) (x2,y2))"
           "y3 = snd (ext_add (x1,y1) (x2,y2))"
    using assms(4) by simp+

  have "t^4 * (delta_x x1 y1 x2 y2)^2 * (delta_y x1 y1 x2 y2)^2 * e' x3 y3 = p"
    unfolding e'_def v3
    apply(simp)
    apply(subst (2) delta_x_def[symmetric])+
    apply(subst (2) delta_y_def[symmetric])+
    apply(subst power_divide)+
    apply(simp add: divide_simps deltas_nz)
    unfolding p_def delta_x_def delta_y_def
    by algebra    
  also have "... = closure1 * e' x1 y1 +  closure2 * e' x2 y2"
    unfolding p_def e'_def closure1_def closure2_def by algebra
  finally have "t^4 * (delta_x x1 y1 x2 y2)^2 * (delta_y x1 y1 x2 y2)^2 * e' x3 y3 =
                closure1 * e' x1 y1 +  closure2 * e' x2 y2" 
    by blast

  then show "e' x3 y3 = 0"
    using assms(2,3) deltas_nz t_nz by auto  
qed


end

locale projective_curve =
 ext_curve_addition
begin
  definition "e_aff = {(x,y). e' x y = 0}" 
  definition "e_circ = {(x,y). x \<noteq> 0 \<and> y \<noteq> 0 \<and> (x,y) \<in> e_aff}"

  lemma "group (BijGroup (Reals \<times> Reals))"
    using group_BijGroup by blast

  lemma bij_\<rho>: "bij_betw \<rho> ((Reals - {0}) \<times> (Reals - {0})) 
                           ((Reals - {0}) \<times> (Reals - {0}))"
    unfolding bij_betw_def inj_on_def image_def
    apply(rule conjI,safe,auto)
    by (metis Reals_minus_iff add.inverse_neutral equation_minus_iff member_remove remove_def)

lemma bij_\<tau>: "bij_betw \<tau> ((Reals - {0}) \<times> (Reals - {0})) 
                         ((Reals - {0}) \<times> (Reals - {0}))"
    unfolding bij_betw_def inj_on_def image_def
    apply(rule conjI,safe)
    apply(simp add: t_nz)+
    apply(metis Reals_of_real mult.right_neutral real_scaleR_def scaleR_conv_of_real)
       apply (simp add: t_nz)
    apply (metis Reals_of_real mult.right_neutral real_scaleR_def scaleR_conv_of_real)
     apply (simp add: t_nz)
    apply(simp add: t_nz)
  proof -
    fix a :: real and b :: real
    assume a1: "a \<noteq> 0"
    assume a2: "(\<forall>x\<in>\<real> - {0}. a \<noteq> 1 / (t * x)) \<or> (\<forall>y\<in>\<real> - {0}. b \<noteq> 1 / (t * y))"
    obtain bb :: bool where
      f3: "(\<not> bb) = (\<forall>A_x. A_x \<notin> \<real> - {0} \<or> 1 / (t * A_x) \<noteq> a)"
      by (metis (full_types))
    have f4: "\<forall>R r ra. ((ra::real) = r \<or> ra \<in> R - {r}) \<or> ra \<notin> R"
      by blast
    have f5: "\<forall>r. (r::real) \<in> \<real>"
      by (metis (no_types) Reals_of_real mult.right_neutral real_scaleR_def scaleR_conv_of_real)
then have f6: "\<forall>r. (r = 0 \<or> bb) \<or> 1 / t / r \<noteq> a"
  using f4 f3 by (metis (no_types) divide_divide_eq_left)
  have f7: "\<forall>r ra. (ra::real) / (ra / r) = r \<or> ra = 0"
    by auto
  obtain bba :: bool where
    f8: "(\<not> bba) = (\<forall>X1. X1 \<notin> \<real> - {0} \<or> 1 / (t * X1) \<noteq> b)"
    by moura
  then have f9: "\<forall>r. (r = 0 \<or> bba) \<or> 1 / t / r \<noteq> b"
    using f5 f4 by (metis (no_types) divide_divide_eq_left)
  have "\<forall>r. (r::real) * 0 = 0 \<or> r = 0"
    by linarith
  then have bb
    using f7 f6 a1 by (metis divide_eq_0_iff mult.right_neutral t_nz)
  then show "b = 0"
    using f9 f8 f7 f3 a2 a1 by (metis divide_eq_0_iff t_nz)
qed

definition G where
  "G \<equiv> {id,\<rho>,\<rho> \<circ> \<rho>,\<rho> \<circ> \<rho> \<circ> \<rho>,\<tau>,\<tau> \<circ> \<rho>,\<tau> \<circ> \<rho> \<circ> \<rho>,\<tau> \<circ> \<rho> \<circ> \<rho> \<circ> \<rho>}"

lemma g_no_fp:
  assumes "g \<in> G" "p \<in> e_circ" "g p = p" 
  shows "g = id"
proof -
  obtain x y where p_def: "p = (x,y)" by fastforce
  {assume "g = \<rho> \<or> g = \<rho> \<circ> \<rho> \<or> g = \<rho> \<circ> \<rho> \<circ> \<rho>"
  then consider (1) "g = \<rho>" | (2) "g = \<rho> \<circ> \<rho>" | (3) "g = \<rho> \<circ> \<rho> \<circ> \<rho>" by blast    
  note cases = this
  from cases have "x = 0" 
    apply(cases)
    using assms(3) p_def by(simp)+
  from cases have "y = 0" 
    apply(cases)
    using assms(3) p_def by(simp)+
  have "p \<notin> e_circ" using e_circ_def \<open>x = 0\<close> \<open>y = 0\<close> p_def by blast}
  note rotations = this
  {assume "g = \<tau> \<or> g = \<tau> \<circ> \<rho> \<or> g = \<tau> \<circ> \<rho> \<circ> \<rho> \<or> g = \<tau> \<circ> \<rho> \<circ> \<rho> \<circ> \<rho>"
  then consider (1) "g = \<tau>" | (2) "g = \<tau> \<circ> \<rho>" | (3) "g = \<tau> \<circ> \<rho> \<circ> \<rho>" | (4) "g = \<tau> \<circ> \<rho> \<circ> \<rho> \<circ> \<rho>" by blast
  note cases = this
  from cases have "2*t*x*y = 0 \<or> (t*x^2 \<in> {-1,1} \<and> t*y^2 \<in> {-1,1})"
    apply(cases)
    using assms(3) p_def 
    apply(simp,metis eq_divide_eq mult.left_commute power2_eq_square)
    using assms(3) p_def apply auto[1]
    using assms(3) p_def apply(simp)
    apply (smt c_d_pos real_sqrt_ge_0_iff t_def zero_le_divide_1_iff zero_le_mult_iff)
    using assms(3) p_def by auto[1]
  then have "t = 0 \<or> x = 0 \<or> y = 0 \<or>
    (t * x\<^sup>2 = - 1 \<or> t * x\<^sup>2 = 1) \<and> (t * y\<^sup>2 = - 1 \<or> t * y\<^sup>2 = 1)" 
    unfolding e'_def by(simp)
  then consider (1) "t = 0" | (2) "x = 0" | (3) "y = 0" |
             (4) "t * x\<^sup>2 = - 1 \<and> t * y\<^sup>2 = - 1" |
             (5) "t * x\<^sup>2 = - 1 \<and> t * y\<^sup>2 = 1" |
             (6) "t * x\<^sup>2 = 1 \<and> t * y\<^sup>2 = - 1" |
             (7) "t * x\<^sup>2 = 1 \<and> t * y\<^sup>2 = 1" by blast
  then have "e' x y = 2 * (1 - t) / t \<or> e' x y = 2 * (-1 - t) / t"
    unfolding e'_def
    apply(cases)
          apply(simp add: t_nz)
    using assms(2) unfolding e_circ_def p_def apply blast
    using assms(2) unfolding e_circ_def p_def apply blast
    apply (metis abs_of_nonneg c_d_pos c_eq_1 nonzero_mult_div_cancel_left one_neq_neg_one power2_eq_1_iff power2_minus real_sqrt_abs real_sqrt_ge_0_iff t_def t_intro t_nz zero_le_mult_iff zero_le_one zero_le_power_eq_numeral)
    apply (metis abs_of_nonneg c_d_pos c_eq_1 one_neq_neg_one power2_eq_1_iff power2_minus real_sqrt_abs real_sqrt_ge_0_iff t_def t_intro zero_le_mult_iff zero_le_one zero_le_power_eq_numeral)
    apply (metis abs_of_nonneg c_d_pos c_eq_1 one_neq_neg_one power2_eq_1_iff power2_minus real_sqrt_abs real_sqrt_ge_0_iff t_def t_intro zero_le_mult_iff zero_le_one zero_le_power_eq_numeral)
    proof -
      assume as: "t * x\<^sup>2 = 1 \<and> t * y\<^sup>2 = 1"
      then have "t\<^sup>2 * x\<^sup>2 * y\<^sup>2 = 1" by algebra
      then have "x\<^sup>2 + y\<^sup>2 - 1 - t\<^sup>2 * x\<^sup>2 * y\<^sup>2 = x\<^sup>2 + y\<^sup>2 - 2" by simp
      also have "... = 2 / t - 2" 
      proof -
        have "x\<^sup>2 = 1 / t" "y\<^sup>2 = 1 / t" using as t_nz 
          by(simp add: divide_simps,simp add: mult.commute)+
        then show ?thesis by simp
      qed
      also have "... = 2 * (1-t) / t"   
        using t_nz by(simp add: divide_simps)
      finally show "x\<^sup>2 + y\<^sup>2 - 1 - t\<^sup>2 * x\<^sup>2 * y\<^sup>2 = 2 * (1 - t) / t \<or>
                    x\<^sup>2 + y\<^sup>2 - 1 - t\<^sup>2 * x\<^sup>2 * y\<^sup>2 = 2 * (- 1 - t) / t" by blast
    qed
  then have "e' x y \<noteq> 0" 
    using t_sq_n1 t_nz by auto
  then have "p \<notin> e_circ" 
    unfolding e_circ_def e_aff_def p_def by blast}
  note symmetries = this
  from rotations symmetries 
  show ?thesis using G_def assms(1,2) by blast
qed

definition symmetries where 
  "symmetries = {\<tau>,\<tau> \<circ> \<rho>,\<tau> \<circ> \<rho> \<circ> \<rho>,\<tau> \<circ> \<rho> \<circ> \<rho> \<circ> \<rho>}"

definition rotations where
  "rotations = {id,\<rho>,\<rho> \<circ> \<rho>,\<rho> \<circ> \<rho> \<circ> \<rho>}"

lemma tau_rot_sym:
  assumes "r \<in> rotations"
  shows "\<tau> \<circ> r \<in> symmetries"
  using assms unfolding rotations_def symmetries_def by auto

definition e_aff_0 where
  "e_aff_0 = {((x1,y1),(x2,y2)). (x1,y1) \<in> e_aff \<and> 
                                 (x2,y2) \<in> e_aff \<and> 
                                 delta x1 y1 x2 y2 \<noteq> 0 }"

definition e_aff_1 where
  "e_aff_1 = {((x1,y1),(x2,y2)). (x1,y1) \<in> e_aff \<and> 
                                 (x2,y2) \<in> e_aff \<and> 
                                 delta' x1 y1 x2 y2 \<noteq> 0 }"

lemma dich_lem_1:
  assumes "(p, q) \<notin> e_aff_0" "(p, q) \<notin> e_aff_1"
  assumes "p = (x1,y1)" "q = (x2,y2)" "\<tau> q = (a0,b0)" "p = (a1,b1)"
  assumes "delta_minus a1 b1 (fst q) (snd q) = 0"
  assumes "p \<in> e_aff" "q \<in> e_aff" 
  shows "(\<exists>g\<in>symmetries. q = (g \<circ> i) p) \<or> (p, q) \<in> e_aff_0 \<or> (p, q) \<in> e_aff_1"
proof -
  have "delta x1 y1 x2 y2 = 0"
    using assms(3,4,6,7) delta_def by auto
  from assms(2) have "delta' x1 y1 x2 y2 = 0"
    using assms(8,9) unfolding assms(3,4) e_aff_1_def by fast
  have "x1 \<noteq> 0" "y1 \<noteq> 0" "x2 \<noteq> 0" "y2 \<noteq> 0" 
    using \<open>delta x1 y1 x2 y2 = 0\<close> 
    unfolding delta_def delta_plus_def delta_minus_def by auto
  then have "p \<in> e_circ" "q \<in> e_circ"
    unfolding e_circ_def using assms by blast+
  have a0_nz: "a0 \<noteq> 0" "b0 \<noteq> 0"
    using \<open>\<tau> q = (a0, b0)\<close> \<open>x2 \<noteq> 0\<close> \<open>y2 \<noteq> 0\<close> comp_apply assms(4) tau_sq by auto 
  have a1_nz: "a1 \<noteq> 0" "b1 \<noteq> 0"
    using \<open>p = (a1, b1)\<close> \<open>x1 \<noteq> 0\<close> \<open>y1 \<noteq> 0\<close> assms(3) by auto
  define \<delta>' :: "real \<Rightarrow> real \<Rightarrow> real" where 
    "\<delta>'= (\<lambda> x0 y0. x0 * y0 * delta_minus a1 b1 (1/(t*x0)) (1/(t*y0)))" 
  define \<delta>_plus :: "real \<Rightarrow> real \<Rightarrow> real" where
    "\<delta>_plus = (\<lambda> x0 y0. t * x0 * y0 * delta_x a1 b1 (1/(t*x0)) (1/(t*y0)))"
  define \<delta>_minus :: "real \<Rightarrow> real \<Rightarrow> real" where
    "\<delta>_minus = (\<lambda> x0 y0. t * x0 * y0 * delta_y a1 b1 (1/(t*x0)) (1/(t*y0)))"
  from assms have t1: "delta_minus a1 b1 (fst q) (snd q) = 0" by auto
  show ?thesis 
  proof(cases "\<delta>_plus a0 b0 = 0")
    case True
      then have cas1: "delta_minus a1 b1 (fst q) (snd q) = 0"
                      "\<delta>_plus a0 b0 = 0" using t1 by auto
      have \<delta>'_expr: "\<delta>' a0 b0 = a0*b0 - a1*b1"
       unfolding \<delta>'_def delta_minus_def 
       apply(simp add: algebra_simps a0_nz a1_nz)
       apply(subst power2_eq_square[symmetric],subst t_expr(1))
       by(simp add: d_nz)
    then have eq1': "a0*b0 - a1*b1 = 0" 
    proof -
      have "(fst q) = (1 / (t * a0))" 
           "(snd q) = (1 / (t * b0))"
        using assms(4,5) tau_sq by force+
      then have "\<delta>' a0 b0 = a0 * b0 * delta_minus a1 b1 (fst q) (snd q)"
        unfolding \<delta>'_def by auto
      then show ?thesis using \<delta>'_expr cas1 by auto
    qed
    then have eq1: "a0 = a1 * (b1 / b0)"  
      using a0_nz(2) by(simp add: divide_simps) 

    have "0 = \<delta>_plus a0 b0"
      using cas1 by auto
    also have "\<delta>_plus a0 b0 = -a0*a1+b0*b1"
      unfolding \<delta>_plus_def delta_x_def 
      by(simp add: algebra_simps t_nz a0_nz)
    also have "... = b0*b1 - a1^2 * (b1 / b0)" 
      by(simp add: divide_simps a0_nz eq1 power2_eq_square[symmetric])
    also have "... = (b1 / b0) * (b0^2 - a1^2)"
      apply(simp add: divide_simps a0_nz)
      by(simp add: algebra_simps power2_eq_square[symmetric])
    finally have "(b1 / b0) * (b0^2 - a1^2) = 0" by auto
    then have eq2: "(b0^2 - a1^2) = 0" 
    by(simp add: a0_nz a1_nz)

    have "a0^2 - b1^2 = a1^2 * (b1^2 / b0^2) - b1^2"
      by(simp add: algebra_simps eq1 power2_eq_square)
    also have "... = (b1^2 / b0^2) * (a1^2 - b0^2)"
      by(simp add: divide_simps a0_nz right_diff_distrib')
    also have "... = 0" 
      using eq2 by auto
    finally have eq3: "a0^2 - b1^2 = 0" by blast

    from eq2 have pos1: "a1 = b0 \<or> a1 = -b0" by algebra
    from eq3 have pos2: "a0 = b1 \<or> a0 = -b1" by algebra
    have "(a0 = b1 \<and> a1 = b0) \<or> (a0 = -b1 \<and> a1 = -b0)"
      using pos1 pos2 eq2 eq3 eq1' by fastforce 
    then have "(a0,b0) = (b1,a1) \<or> (a0,b0) = (-b1,-a1)" by auto        
    then have "(a0,b0) \<in> {(b1,a1),(-b1,-a1)}" by simp
    moreover have "{(b1,a1),(-b1,-a1)} \<subseteq> {i p, (\<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> \<rho> \<circ> i) p}"
      using \<open>p = (a1, b1)\<close> assms(3) by auto
    ultimately have "(a0,b0) \<in> {i p, (\<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> \<rho> \<circ> i) p}"
      by blast
    then have "(\<exists> g \<in> rotations. \<tau> q = (g \<circ> i) p)"
      unfolding rotations_def by (simp add: \<open>\<tau> q = (a0, b0)\<close>)
    then obtain g where "g \<in> rotations \<and> \<tau> q = (g \<circ> i) p"
      by blast
    then have "q = (\<tau> \<circ> g \<circ> i) p"
      using tau_sq \<open>\<tau> q = (a0, b0)\<close> assms(4) by auto
    then show ?thesis
      unfolding symmetries_def rotations_def 
      using tau_rot_sym \<open>g \<in> rotations \<and> \<tau> q = (g \<circ> i) p\<close> symmetries_def by blast     
next
  case False
    then have cas2: "delta_minus a1 b1 (fst q) (snd q) = 0"
                    "\<delta>_minus a0 b0 = 0"               
      using t1 apply blast
      using False \<delta>_minus_def \<delta>_plus_def \<open>delta' x1 y1 x2 y2 = 0\<close> \<open>p = (a1, b1)\<close> 
            delta'_def assms(3,4,5) by auto
    have \<delta>'_expr: "\<delta>' a0 b0 = a0*b0 - a1*b1"
      unfolding \<delta>'_def delta_minus_def 
      apply(simp add: algebra_simps a0_nz a1_nz)
      apply(subst power2_eq_square[symmetric],subst t_expr(1))
      by(simp add: d_nz)
    then have eq1': "a0*b0 - a1*b1 = 0" 
    proof -
      have "(fst q) = (1 / (t * a0))" 
          "(snd q) = (1 / (t * b0))"
        using assms(4,5) tau_sq by auto
      then have "\<delta>' a0 b0 = a0 * b0 * delta_minus a1 b1 (fst q) (snd q)"
        unfolding \<delta>'_def by auto
      then show ?thesis using \<delta>'_expr cas2 by auto 
    qed
    then have eq1: "a0 = a1 * (b1 / b0)"  
      using a0_nz(2) by(simp add: divide_simps) 

    have "0 = \<delta>_minus a0 b0" using cas2 by auto
    also have "\<delta>_minus a0 b0 = a0 * b1 + a1 * b0"
      unfolding \<delta>_minus_def delta_y_def by(simp add: algebra_simps t_nz a0_nz)            
    also have "... = a1 * (b1 / b0) * b1 + a1 * b0" by(simp add: eq1)
    also have "... = (a1^2 - b0^2)" 
      apply(simp add: divide_simps)
      by (smt \<open>a0 * b1 + a1 * b0 = a1 * (b1 / b0) * b1 + a1 * b0\<close> a1_nz(1) a1_nz(2) calculation eq1' mult_nonpos_nonneg no_zero_divisors zero_le_mult_iff)
    also have "... = b0*b1 - a1^2 * (b1 / b0)" 
      apply(simp add: divide_simps)
      using calculation semiring_normalization_rules(29) by fastforce
    also have "... = (b1 / b0) * (b0^2 - a1^2)"
      by(simp add: divide_simps a0_nz right_diff_distrib' semiring_normalization_rules(29))
    finally have "(b1 / b0) * (b0^2 - a1^2) = 0" by auto
    then have eq2: "(b0^2 - a1^2) = 0" 
      by(simp add: a0_nz a1_nz)

    have "a0^2 - b1^2 = a1^2 * (b1^2 / b0^2) - b1^2"
      by(simp add: algebra_simps eq1 power2_eq_square)
    also have "... = (b1^2 / b0^2) * (a1^2 - b0^2)"
      by(simp add: divide_simps a0_nz right_diff_distrib')
    also have "... = 0" 
      using eq2 by auto
    finally have eq3: "a0^2 - b1^2 = 0" by blast

    from eq2 have pos1: "a1 = b0 \<or> a1 = -b0" by algebra
    from eq3 have pos2: "a0 = b1 \<or> a0 = -b1" by algebra
    have "(a0 = b1 \<and> a1 = b0) \<or> (a0 = -b1 \<and> a1 = -b0)"
      using pos1 pos2 eq2 eq3 eq1' by fastforce 
    then have "(a0,b0) = (b1,a1) \<or> (a0,b0) = (-b1,-a1)" by auto        
    then have "(a0,b0) \<in> {(b1,a1),(-b1,-a1)}" by simp
    moreover have "{(b1,a1),(-b1,-a1)} \<subseteq> {i p, (\<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> \<rho> \<circ> i) p}"
      using \<open>p = (a1, b1)\<close> assms(3) by auto
    ultimately have "(a0,b0) \<in> {i p, (\<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> \<rho> \<circ> i) p}"
      by blast
    then have "(\<exists> g \<in> rotations. \<tau> q = (g \<circ> i) p)"
      unfolding rotations_def by (simp add: \<open>\<tau> q = (a0, b0)\<close>)
    then obtain g where "g \<in> rotations \<and> \<tau> q = (g \<circ> i) p"
      by blast
    then have "q = (\<tau> \<circ> g \<circ> i) p"
      using tau_sq \<open>\<tau> q = (a0, b0)\<close> assms(4) by auto
    then show ?thesis
      unfolding symmetries_def rotations_def 
      using tau_rot_sym \<open>g \<in> rotations \<and> \<tau> q = (g \<circ> i) p\<close> symmetries_def by blast  
qed
qed

lemma dichotomy_1:
  assumes "p \<in> e_aff" "q \<in> e_aff" 
  shows "(p \<in> e_circ \<and> (\<exists> g \<in> symmetries. q = (g \<circ> i) p)) \<or> (p,q) \<in> e_aff_0 \<or> (p,q) \<in> e_aff_1" 
proof -
  obtain x1 y1 where p_def: "p = (x1,y1)" by fastforce
  obtain x2 y2 where q_def: "q = (x2,y2)" by fastforce

  consider (1) "(p,q) \<in> e_aff_0" |
           (2) "(p,q) \<in> e_aff_1" |
           (3) "(p,q) \<notin> e_aff_0 \<and> (p,q) \<notin> e_aff_1" by blast
  then show ?thesis
  proof(cases)
    case 1 then show ?thesis by blast  
  next
    case 2 then show ?thesis by simp
  next
    case 3
    then have "delta x1 y1 x2 y2 = 0"
      unfolding p_def q_def  e_aff_0_def e_aff_1_def using assms 
      by (simp add: assms p_def q_def)
    from 3 have "delta' x1 y1 x2 y2 = 0"
      unfolding p_def q_def  e_aff_0_def e_aff_1_def using assms 
      by (simp add: assms p_def q_def)
    have "x1 \<noteq> 0" "y1 \<noteq> 0" "x2 \<noteq> 0" "y2 \<noteq> 0" 
      using \<open>delta x1 y1 x2 y2 = 0\<close> 
      unfolding delta_def delta_plus_def delta_minus_def by auto
    then have "p \<in> e_circ" "q \<in> e_circ"
      unfolding e_circ_def using assms p_def q_def by blast+
    have "(\<exists> g \<in> symmetries. q = (g \<circ> i) p)" 
    proof -
      obtain a0 b0 where tq_expr: "\<tau> q = (a0,b0)" by fastforce
      obtain a1 b1 where "p = (a1,b1)" by fastforce
      have a0_nz: "a0 \<noteq> 0" "b0 \<noteq> 0"
        using \<open>\<tau> q = (a0, b0)\<close> \<open>x2 \<noteq> 0\<close> \<open>y2 \<noteq> 0\<close> comp_apply q_def tau_sq by auto 
      have a1_nz: "a1 \<noteq> 0" "b1 \<noteq> 0"
        using \<open>p = (a1, b1)\<close> \<open>x1 \<noteq> 0\<close> \<open>y1 \<noteq> 0\<close> p_def by auto
      define \<delta>' :: "real \<Rightarrow> real \<Rightarrow> real" where 
        "\<delta>'= (\<lambda> x0 y0. x0 * y0 * delta_minus a1 b1 (1/(t*x0)) (1/(t*y0)))" 
      define p\<delta>' :: "real \<Rightarrow> real \<Rightarrow> real" where 
        "p\<delta>'= (\<lambda> x0 y0. x0 * y0 * delta_plus a1 b1 (1/(t*x0)) (1/(t*y0)))" 
      define \<delta>_plus :: "real \<Rightarrow> real \<Rightarrow> real" where
        "\<delta>_plus = (\<lambda> x0 y0. t * x0 * y0 * delta_x a1 b1 (1/(t*x0)) (1/(t*y0)))"
      define \<delta>_minus :: "real \<Rightarrow> real \<Rightarrow> real" where
        "\<delta>_minus = (\<lambda> x0 y0. t * x0 * y0 * delta_y a1 b1 (1/(t*x0)) (1/(t*y0)))"
      show ?thesis
      proof(cases "delta_minus a1 b1 (fst q) (snd q) = 0")
        case True
        then show ?thesis using "3" \<open>p = (a1, b1)\<close> assms(1,2) dich_lem_1 q_def by auto
      next
        case False  
        then have t1: "delta_plus a1 b1 (fst q) (snd q) = 0" 
          using \<open>delta x1 y1 x2 y2 = 0\<close> \<open>p = (a1, b1)\<close> delta_def p_def q_def by auto
        then show ?thesis 
        proof(cases "\<delta>_minus a0 b0 = 0")
          case True
          then have cas1: "delta_plus a1 b1 (fst q) (snd q) = 0"
                          "\<delta>_minus a0 b0 = 0" using t1 by auto
          have \<delta>'_expr: "p\<delta>' a0 b0 = a0 * b0 + a1 * b1"
            unfolding p\<delta>'_def delta_plus_def 
            by(simp add: algebra_simps a0_nz a1_nz power2_eq_square[symmetric] t_expr d_nz)
          then have eq1': "a0 * b0 + a1 * b1 = 0" 
          proof -
            have "(fst q) = (1 / (t * a0))" 
                 "(snd q) = (1 / (t * b0))"
              using tq_expr q_def tau_sq by auto
            then have "p\<delta>' a0 b0 = a0 * b0 * delta_plus a1 b1 (fst q) (snd q)"
               using cas1 \<delta>'_expr unfolding p\<delta>'_def by presburger
            then show ?thesis using \<delta>'_expr cas1 by fastforce
          qed
          then have eq1: "a0 = - (a1 * b1) / b0"  
            using a0_nz(2) by(simp add: divide_simps) 
        
          have "0 = \<delta>_minus a0 b0"
            using cas1 by auto
          also have "\<delta>_minus a0 b0 = a0 * b1 + a1 * b0"
            unfolding \<delta>_minus_def delta_y_def 
            by(simp add: algebra_simps t_nz a0_nz)
          also have "... = a1 * b0 - b1^2 * (a1 / b0)" 
            by(simp add: divide_simps a0_nz eq1 power2_eq_square[symmetric])
          also have "... = (a1 / b0) * (b0^2 - b1^2)"
            apply(simp add: divide_simps a0_nz)
            by(simp add: algebra_simps power2_eq_square[symmetric])
          finally have "(a1 / b0) * (b0^2 - b1^2) = 0" by auto
          then have eq2: "(b0^2 - b1^2) = 0" 
            by(simp add: a0_nz a1_nz)
          
          have "a0^2 - a1^2 = b1^2 * (a1^2 / b0^2) - a1^2"
            by(simp add: algebra_simps eq1 power2_eq_square)
          also have "... = (a1^2 / b0^2) * (b1^2 - b0^2)"
            by(simp add: divide_simps a0_nz right_diff_distrib')
          also have "... = 0" 
            using eq2 by auto
          finally have eq3: "a0^2 - a1^2 = 0" by blast
          
          from eq2 have pos1: "b0 = b1 \<or> b0 = -b1" by algebra
          from eq3 have pos2: "a0 = a1 \<or> a0 = -a1" by algebra
          have "(a0 = a1 \<and> b0 = -b1) \<or> (a0 = -a1 \<and> b0 = b1)"
            using pos1 pos2 eq2 eq3 eq1' by fastforce 
          then have "(a0,b0) = (a1,-b1) \<or> (a0,b0) = (-a1,b1)" by auto        
          then have "(a0,b0) \<in> {(a1,-b1),(-a1,b1)}" by simp
          moreover have "{(a1,-b1),(-a1,b1)} \<subseteq> {i p, (\<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> \<rho> \<circ> i) p}"
            using \<open>p = (a1, b1)\<close> p_def by auto
          ultimately have "(a0,b0) \<in> {i p, (\<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> \<rho> \<circ> i) p}"
            by blast
          then have "(\<exists> g \<in> rotations. \<tau> q = (g \<circ> i) p)"
            unfolding rotations_def by (simp add: \<open>\<tau> q = (a0, b0)\<close>)
          then obtain g where "g \<in> rotations \<and> \<tau> q = (g \<circ> i) p"
            by blast
          then have "q = (\<tau> \<circ> g \<circ> i) p"
            using tau_sq \<open>\<tau> q = (a0, b0)\<close> q_def by auto
          then show "(\<exists> g \<in> symmetries. q = (g \<circ> i) p)"
            unfolding symmetries_def rotations_def 
            using tau_rot_sym \<open>g \<in> rotations \<and> \<tau> q = (g \<circ> i) p\<close> symmetries_def by blast     
        next
            case False
              then have cas2: "delta_plus a1 b1 (fst q) (snd q) = 0"
                               "\<delta>_plus a0 b0 = 0"               
                using t1 apply blast
                using False \<delta>_minus_def \<delta>_plus_def \<open>delta' x1 y1 x2 y2 = 0\<close> \<open>p = (a1, b1)\<close> delta'_def p_def q_def tq_expr by auto
              have \<delta>'_expr: "p\<delta>' a0 b0 = a0*b0 + a1*b1"
                unfolding p\<delta>'_def delta_plus_def 
                apply(simp add: algebra_simps a0_nz a1_nz)
                apply(subst power2_eq_square[symmetric],subst t_expr(1))
                by(simp add: d_nz)
              then have eq1': "a0*b0 + a1*b1 = 0" 
              proof -
                have "(fst q) = (1 / (t * a0))" 
                    "(snd q) = (1 / (t * b0))"
                  using tq_expr q_def tau_sq by auto
                then have "p\<delta>' a0 b0 = a0 * b0 * delta_plus a1 b1 (fst q) (snd q)"
                  unfolding p\<delta>'_def by auto
                then show ?thesis using \<delta>'_expr cas2 by auto 
              qed
              then have eq1: "a0 = - (a1 * b1) / b0"  
                using a0_nz(2) by(simp add: divide_simps)  
  
              have "0 = \<delta>_plus a0 b0" using cas2 by auto
              also have "\<delta>_plus a0 b0 = b0 * b1 - a0 * a1"
                unfolding \<delta>_plus_def delta_x_def by(simp add: algebra_simps t_nz a0_nz)  
              (* b0 * b1 + a1^2 (b1 / b0) *)
              also have "... = b0 * b1 + a1^2 * (b1 / b0)" by(simp add: eq1 power2_eq_square)
              also have "... = (b1 / b0) * (b0^2 + a1^2)" 
                by(simp add: algebra_simps power2_eq_square) 
              finally have "(b1 / b0) * (b0^2 - a1^2) = 0" by auto
              then have eq2: "(b0^2 - a1^2) = 0" 
                by(simp add: a0_nz a1_nz)
      
              have "a0^2 - b1^2 = a1^2 * (b1^2 / b0^2) - b1^2"
                by(simp add: algebra_simps eq1 power2_eq_square)
              also have "... = (b1^2 / b0^2) * (a1^2 - b0^2)"
                by(simp add: divide_simps a0_nz right_diff_distrib')
              also have "... = 0" 
                using eq2 by auto
              finally have eq3: "a0^2 - b1^2 = 0" by blast
              thm eq1' eq2 eq3
              from eq2 have pos1: "a1 = b0 \<or> a1 = -b0" by algebra
              from eq3 have pos2: "a0 = b1 \<or> a0 = -b1" by algebra
              have "(a0 = b1 \<and> a1 = -b0) \<or> (a0 = -b1 \<and> a1 = b0)"
                using pos1 pos2 eq2 eq3 eq1' by fastforce 
              then have "(a0,b0) = (b1,-a1) \<or> (a0,b0) = (-b1,a1)" by auto        
              then have "(a0,b0) \<in> {(b1,-a1),(-b1,a1)}" by simp
              moreover have "{(b1,-a1),(-b1,a1)} \<subseteq> {i p, (\<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> \<rho> \<circ> i) p}"
                using \<open>p = (a1, b1)\<close> p_def apply(simp add: a0_nz a1_nz)
                using \<open>\<delta>_plus a0 b0 = b0 * b1 - a0 * a1\<close> \<open>a0 = b1 \<and> a1 = - b0 \<or> a0 = - b1 \<and> a1 = b0\<close> a1_nz(1) a1_nz(2) cas2(2) by auto
              ultimately have "(a0,b0) \<in> {i p, (\<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> i) p, (\<rho> \<circ> \<rho> \<circ> \<rho> \<circ> i) p}"
                by blast
              then have "(\<exists> g \<in> rotations. \<tau> q = (g \<circ> i) p)"
                unfolding rotations_def by (simp add: \<open>\<tau> q = (a0, b0)\<close>)
              then obtain g where "g \<in> rotations \<and> \<tau> q = (g \<circ> i) p"
                by blast
              then have "q = (\<tau> \<circ> g \<circ> i) p"
                using tau_sq \<open>\<tau> q = (a0, b0)\<close> q_def by auto
              then show "(\<exists> g \<in> symmetries. q = (g \<circ> i) p)"
                unfolding symmetries_def rotations_def 
                using tau_rot_sym \<open>g \<in> rotations \<and> \<tau> q = (g \<circ> i) p\<close> symmetries_def by blast  
          qed
        qed
      qed
      then show ?thesis 
        using \<open>p \<in> e_circ\<close> by blast
    qed
  qed

lemma dichotomy_2:
  assumes "add (x1,y1) (x2,y2) = (1,0)" 
          "((x1,y1),(x2,y2)) \<in> e_aff_0"
  shows "(x2,y2) = i (x1,y1)"
proof -
  have 1: "x1 = x2"
    using assms(1,2) unfolding e_aff_0_def e_aff_def delta_def delta_plus_def 
                               delta_minus_def e'_def
    apply(simp) 
    apply(simp add: c_eq_1 t_expr)
    by(algebra)

  have 2: "y1 = - y2"
    using assms(1,2) unfolding e_aff_0_def e_aff_def delta_def delta_plus_def 
                               delta_minus_def e'_def
    apply(simp) 
    apply(simp add: c_eq_1 t_expr)
    by(algebra)

  from 1 2 show ?thesis by simp
qed
  
lemma add_cancel_2:
  assumes "add (x0,y0) (x1,y1) = add (x0,y0) (i (x0,y0))"
          "((x0,y0),(x1,y1)) \<in> e_aff_0"
  shows "(x1,y1) = i (x0,y0)"
proof -
  have "e x0 y0 = 0" 
    using assms(2) unfolding e_aff_0_def e_aff_def
    apply(simp)
    using e_e'_iff by blast
  have "add (x0, y0) (i (x0, y0)) = (1,0)"
    using inverse[OF \<open>e x0 y0 = 0\<close> delta_plus_self] by fastforce
  then have "add (x0,y0) (x1,y1) = (1,0)" using assms(1) by argo
  then show ?thesis using dichotomy_2[OF _ assms(2)] by fast
qed
        
lemma dichotomy_3:
  assumes "ext_add (x1,y1) (x2,y2) = (1,0)" 
          "((x1,y1),(x2,y2)) \<in> e_aff_1"
  shows "(x2,y2) = i (x1,y1)"
proof -
  have 1: "x1 = x2"
    using assms(1,2) unfolding e_aff_1_def e_aff_def delta'_def delta_x_def 
                               delta_y_def e'_def
    apply(simp) 
    apply(simp add: c_eq_1 t_expr)
    by(algebra)

  have 2: "y1 = - y2"
    using assms(1,2) unfolding e_aff_1_def e_aff_def delta'_def delta_x_def 
                               delta_y_def e'_def
    apply(simp) 
    apply(simp add: c_eq_1 t_expr)
    by(algebra)

  from 1 2 show ?thesis by simp
qed

lemma add_cancel_3:
  assumes "ext_add (x0,y0) (x1,y1) = ext_add (x0,y0) (i (x0,y0))"
          "((x0,y0),(x1,y1)) \<in> e_aff_1"
  shows "(x1,y1) = i (x0,y0)"
proof -
 have "e x0 y0 = 0" 
    using assms(2) unfolding e_aff_1_def e_aff_def
    apply(simp)
    using e_e'_iff by blast
  have "x0 \<noteq> 0" "y0 \<noteq> 0"
    using assms unfolding e_aff_1_def e_aff_def e'_def delta'_def delta_x_def delta_y_def by force+    
  then have "ext_add (x0, y0) (i (x0, y0)) = (1,0)" by simp
  then have "ext_add (x0,y0) (x1,y1) = (1,0)" using assms(1) by argo
  then show ?thesis using dichotomy_3[OF _ assms(2)] by fast
qed

section \<open>Projective addition\<close>

definition gluing :: "(((real \<times> real) \<times> bit) \<times> ((real \<times> real) \<times> bit)) set" where
  "gluing = {(((x0,y0),l),((x1,y1),j)). 
               ((x0,y0) \<in> e_aff \<and> (x1,y1) \<in> e_aff) \<and>
               (((x0,y0) \<in> e_circ \<and> (x1,y1) = \<tau> (x0,y0) \<and> j = l+1) \<or>
                ((x0,y0) \<in> e_aff \<and> x0 = x1 \<and> y0 = y1 \<and> l = j))}"

lemma gluing_char:
  assumes "(((x0,y0),l),((x1,y1),j)) \<in> gluing"
  shows "((x0,y0) = (x1,y1) \<and> l = j) \<or> 
          ((x1,y1) = \<tau> (x0,y0) \<and> l = j+1)"
  using assms gluing_def by force+

lemma gluing_char_zero:
  assumes "(((x0,y0),l),((x1,y1),j)) \<in> gluing" "x0 = 0 \<or> y0 = 0"
  shows "(x0,y0) = (x1,y1) \<and> l = j"
proof - 
  consider (1) "x0 = 0" | (2) "y0 = 0" using assms by auto
  then show ?thesis
    apply(cases)
    using assms(1) unfolding gluing_def 
    by(simp add: e_circ_def)+
qed



definition "Bits = range Bit"
definition e_aff_bit :: "((real \<times> real) \<times> bit) set" where
 "e_aff_bit = e_aff \<times> Bits"

lemma eq_rel: "equiv e_aff_bit gluing"
  unfolding equiv_def
proof(intro conjI)
  show "refl_on e_aff_bit gluing"
    unfolding refl_on_def
  proof 
    show "(\<forall>x\<in>e_aff_bit. (x, x) \<in> gluing)"
      unfolding e_aff_bit_def gluing_def by auto
    have "range Bit = (UNIV::bit set)" 
      by (simp add: type_definition.Abs_image[OF type_definition_bit]) 
    show "gluing \<subseteq> e_aff_bit \<times> e_aff_bit" 
      unfolding e_aff_bit_def gluing_def Bits_def
      using \<open>range Bit = (UNIV::bit set)\<close> by auto
  qed
  
  show "sym gluing" 
    unfolding sym_def gluing_def
    by(auto simp add: e_circ_def t_nz)
  
  show "trans gluing"
    unfolding trans_def gluing_def
     by(auto simp add: e_circ_def t_nz)
 qed

lemma identity_equiv: "gluing `` {((1, 0), 0)} = {((1,0),0)}"
  unfolding Image_def apply(simp,standard)
proof -
  show "{y. (((1, 0), 0), y) \<in> gluing} \<subseteq> {((1, 0), 0)}" 
    using gluing_char_zero by(metis (mono_tags, lifting) i.cases insertI1 mem_Collect_eq subrelI)
  have "(1,0) \<in> e_aff" 
    unfolding e_aff_def e'_def by(simp)
  then have "((1, 0), 0) \<in> e_aff_bit"
    unfolding e_aff_bit_def Bits_def
    using zero_bit_def by blast
  show "{((1, 0), 0)} \<subseteq> {y. (((1, 0), 0), y) \<in> gluing}"
  apply(simp)
    using eq_rel unfolding equiv_def refl_on_def 
    using \<open>((1, 0), 0) \<in> e_aff_bit\<close> by blast
qed

definition e_proj where "e_proj = e_aff_bit // gluing"

lemma rho_circ: 
  assumes "p \<in> e_circ"
  shows "\<rho> p \<in> e_circ"
  using assms unfolding e_circ_def e_aff_def e'_def 
  by(simp split: prod.splits,argo) 

lemma i_circ:
  assumes "(x,y) \<in> e_circ"
  shows "i (x,y) \<in> e_circ"
  using assms unfolding e_circ_def e_aff_def e'_def by auto

lemma rot_circ:
  assumes "p \<in> e_circ" "tr \<in> rotations"
  shows "tr p \<in> e_circ"
proof -
  consider (1) "tr = id" | (2) "tr = \<rho>"  | (3) "tr = \<rho> \<circ> \<rho>" | (4) "tr = \<rho> \<circ> \<rho> \<circ> \<rho>"
    using assms(2) unfolding rotations_def by blast
  then show ?thesis by(cases,auto simp add: assms(1) rho_circ)          
qed
  
lemma \<tau>_circ:
  assumes "p \<in> e_circ"
  shows "\<tau> p \<in> e_circ"
  using assms unfolding e_circ_def 
  apply(simp split: prod.splits) 
  apply(simp add: divide_simps t_nz)
  unfolding e_aff_def e'_def
  apply(simp split: prod.splits) 
  apply(simp add: divide_simps t_nz)
  apply(subst power_mult_distrib)+
  apply(subst ring_distribs(1)[symmetric])+
  apply(subst (1) mult.assoc)
  apply(subst right_diff_distrib[symmetric])
  apply(simp add: t_nz)
  by(simp add: algebra_simps)

lemma eq_class_simp:
  assumes "X \<in> e_proj" "X \<noteq> {}"
  shows "X // gluing = {X}"
proof
  have "X \<in> e_aff_bit // gluing" using \<open>X \<in> e_proj\<close> unfolding e_proj_def by blast

  {
    fix x
    assume "x \<in> X"
    have "gluing `` {x} = X"
     by (metis (no_types, lifting)  Image_singleton_iff \<open>x \<in> X\<close> assms(1) e_proj_def eq_rel equiv_class_eq quotientE)
  }
  note simp_un = this
  show "X // gluing \<subseteq> {X}"
    unfolding quotient_def by(simp add: simp_un)
  show "{X} \<subseteq> X // gluing"
    unfolding quotient_def by(simp add: simp_un assms)
qed

lemma e_proj_elim_1:
  assumes "(x,y) \<in> e_aff"
  shows "{((x,y),l)} \<in> e_proj \<longleftrightarrow> x = 0 \<or> y = 0"
proof(standard)
  assume as: "{((x, y), l)} \<in> e_proj" 
   have "(x,y) \<in> e_aff"
      using as unfolding e_proj_def e_aff_bit_def 
      by (metis as e_aff_bit_def e_proj_def eq_rel in_quotient_imp_subset insert_subset mem_Sigma_iff)
  obtain x' y' l' where "{((x,y),l)} = gluing `` {((x',y'),l')}"
    using as unfolding e_proj_def quotient_def by force
  then have "x' = x" "y' = y" "l' = l"
    by (smt Image_singleton_iff eq_rel equiv_class_eq_iff insertI1 insert_absorb prod.inject singleton_insert_inj_eq')+
  then have fp: "{((x,y),l)} = gluing `` {((x,y),l)}"
    using \<open>{((x, y), l)} = gluing `` {((x', y'), l')}\<close> by auto
  then have root: "{((x, y), l)} = {ya. (((x, y), l), ya) \<in> gluing}"
    unfolding Image_def by simp
  show "x = 0 \<or> y = 0" 
  proof(rule ccontr)
    assume "\<not> (x = 0 \<or> y = 0)"
    then have "x \<noteq> 0" "y \<noteq> 0" by simp+
    then have "(x, y) \<in> e_circ" 
      unfolding e_circ_def using \<open>(x,y) \<in> e_aff\<close> by fastforce
    then have "\<tau> (x,y) \<in> e_circ" 
      using \<tau>_circ by blast
    then have "\<tau> (x,y) \<in> e_aff" by (simp add: e_circ_def)
    then have "(((x, y), l), (\<tau> (x,y),l+1)) \<in> gluing"
      unfolding gluing_def 
      using \<open>(x,y) \<in> e_circ\<close> \<open>(x,y) \<in> e_aff\<close> by force
    then show "False" using root 
      by (metis Pair_inject add_cancel_right_right bit.distinct(1) mem_Collect_eq singleton_iff)
  qed
next
  assume as1: "x = 0 \<or> y = 0"
  then show "{((x, y), l)} \<in> e_proj" 
  proof -
    have "(x,y) \<notin> e_circ" unfolding e_circ_def using as1 by auto
    have "{((x, y), l)} = gluing `` {((x, y), l)}"
      unfolding Image_def
    proof(simp,standard,simp)
      have "((x, y), l) \<in> e_aff_bit" 
        unfolding e_aff_bit_def Bits_def using assms 
        by (metis Bit_cases mem_Sigma_iff rangeI)
      then show "(((x, y), l), (x, y), l) \<in> gluing" 
        using eq_rel unfolding equiv_def refl_on_def by blast
      show "{ya. (((x, y), l), ya) \<in> gluing} \<subseteq> {((x, y), l)}"
      proof -
        {fix ya      
        assume as: "(((x, y), l), ya) \<in> gluing" 
        then have "ya = ((x, y), l)" 
          unfolding gluing_def using \<open>(x,y) \<notin> e_circ\<close> by auto}
        then show ?thesis by blast
      qed
    qed    
    then show ?thesis 
      by (metis (no_types, lifting) Image_singleton_iff e_proj_def eq_rel equiv_class_eq_iff insertI1 quotientI)
  qed
qed

lemma gluing_class:
  assumes "x \<noteq> 0" "y \<noteq> 0" "(x,y) \<in> e_aff"
  shows "gluing `` {((x,y), l)} = {((x,y), l), (\<tau> (x,y), l + 1)}"
proof - 
  have "(x,y) \<in> e_circ" using assms unfolding e_circ_def by blast
  then have "\<tau> (x,y) \<in> e_aff"
    using \<tau>_circ using e_circ_def by force
  show ?thesis
    unfolding gluing_def Image_def
    apply(simp split: prod.splits add: e_circ_def \<open>\<tau> (x,y) \<in> e_aff\<close> assms del: \<tau>.simps \<rho>.simps,safe)
    by(auto simp del: \<tau>.simps, simp add: assms,simp add: \<open>\<tau> (x,y) \<in> e_aff\<close> del: \<tau>.simps)
qed

(* TODO: remove gluing_class and integrate here *)
lemma e_proj_elim_2:
  assumes "(x,y) \<in> e_aff"
  shows "{((x,y),l),(\<tau> (x,y),l+1)} \<in> e_proj \<longleftrightarrow> x \<noteq> 0 \<and> y \<noteq> 0"
proof
  assume "x \<noteq> 0 \<and> y \<noteq> 0"
  then show "{((x, y), l), (\<tau> (x, y), l + 1)} \<in> e_proj"
    using gluing_class assms 
  proof -
    have f1: "(((x, y), l), (x, y), l) \<in> gluing" using \<open>x \<noteq> 0 \<and> y \<noteq> 0\<close> assms gluing_class by auto
    have "equiv (e_aff \<times> Bits) gluing" by (metis e_aff_bit_def eq_rel)
    then have "((x, y), l) \<in> e_aff \<times> Bits" using f1 by (meson equiv_class_eq_iff)
    then show ?thesis
      by (metis (no_types) \<open>x \<noteq> 0 \<and> y \<noteq> 0\<close> assms e_aff_bit_def e_proj_def gluing_class quotientI)
  qed
next
  assume "{((x, y), l), (\<tau> (x, y), l + 1)} \<in> e_proj" 
  then have "{((x, y), l)} \<notin> e_proj" 
    by (metis (no_types, hide_lams) add_cancel_right_right doubleton_eq_iff eq_class_simp insertI1 insert_not_empty quotientI singletonD snd_conv zero_neq_one)
  then show "x \<noteq> 0 \<and> y \<noteq> 0" 
    using e_proj_elim_1 assms by simp
qed

lemma e_proj_eq:
  assumes "p \<in> e_proj"
  shows "\<exists> x y l. (p = {((x,y),l)} \<or> p = {((x,y),l),(\<tau> (x,y),l+1)}) \<and> (x,y) \<in> e_aff"        
proof -
  obtain g where p_expr: "p = gluing `` {g}" "g \<in> e_aff_bit"
    using assms unfolding e_proj_def quotient_def by blast+
  then obtain x y l where g_expr: "g = ((x,y),l)" "(x,y) \<in> e_aff" 
    using e_aff_bit_def by auto
  then have p_simp: "p = gluing `` {((x,y),l)}" "((x,y),l) \<in> e_aff_bit" "(x,y) \<in> e_aff"
    using p_expr by simp+
  {fix x' y' l'
  assume "((x',y'), l') \<in> gluing `` {((x,y),l)}"
  then have "(x' = x \<and> y' = y \<and> l' = l) \<or>
        ((x',y') = \<tau> (x,y) \<and> l' = l + 1)" 
    unfolding gluing_def Image_def by auto}
  note pair_form = this
  have "p = {((x,y),l), (\<tau> (x,y), l+1)} \<or> p = {((x,y),l)}" 
  proof -
    have "((x,y),l) \<in> p" 
      using p_simp eq_rel unfolding equiv_def refl_on_def by blast
    then show ?thesis using pair_form p_simp by auto
  qed    
  then show ?thesis using p_simp by auto
qed


lemma rot_comp:
  assumes "t1 \<in> rotations" "t2 \<in> rotations"
  shows "t1 \<circ> t2 \<in> rotations"
  using assms unfolding rotations_def by auto


  
(*
function proj_add :: "(real \<times> real) \<times> bit \<Rightarrow> (real \<times> real) \<times> bit \<Rightarrow> (real \<times> real) \<times> bit" where
  "proj_add ((x1,y1),l) ((x2,y2),j) = ((add (x1,y1) (x2,y2)), l+j)" 
    if "delta x1 y1 x2 y2 \<noteq> 0 \<and> (x1,y1) \<in> e_aff \<and> (x2,y2) \<in> e_aff"
| "proj_add ((x1,y1),l) ((x2,y2),j) = ((ext_add (x1,y1) (x2,y2)), l+j)" 
    if "delta' x1 y1 x2 y2 \<noteq> 0 \<and> (x1,y1) \<in> e_aff \<and> (x2,y2) \<in> e_aff"
| "proj_add ((x1,y1),l) ((x2,y2),j) = undefined"
    if "delta x1 y1 x2 y2 = 0 \<and> delta' x1 y1 x2 y2 = 0 \<or> (x1,y1) \<notin> e_aff \<or> (x2,y2) \<notin> e_aff"
  apply(fast,fastforce)
  using coherence e_aff_def by auto

definition proj_add_class where
"proj_add_class c1 c2 = (case_prod proj_add) ` ({x. proj_add_dom x} \<inter> (c1 \<times> c2))"
*)
definition p_delta :: "(real \<times> real) \<times> bit \<Rightarrow> (real \<times> real) \<times> bit \<Rightarrow> real" where 
  "p_delta p1 p2 = 
    delta (fst (fst p1)) (snd (fst p1)) (fst (fst p2)) (snd (fst p2))"

definition p_delta' :: "(real \<times> real) \<times> bit \<Rightarrow> (real \<times> real) \<times> bit \<Rightarrow> real" where 
  "p_delta' p1 p2 = 
    delta' (fst (fst p1)) (snd (fst p1)) (fst (fst p2)) (snd (fst p2))"

partial_function (option) proj_add ::
  "(real \<times> real) \<times> bit \<Rightarrow> (real \<times> real) \<times> bit \<Rightarrow> ((real \<times> real) \<times> bit) option" where
  "
  proj_add p1 p2 =  
    (
      if (p_delta p1 p2 \<noteq> 0 \<and> fst p1 \<in> e_aff \<and> fst p2 \<in> e_aff) 
      then Some (add (fst p1) (fst p2), (snd p1) + (snd p2))
      else 
        (
          if (p_delta' p1 p2 \<noteq> 0 \<and> fst p1 \<in> e_aff \<and> fst p2 \<in> e_aff)   
          then Some (ext_add (fst p1) (fst p2), (snd p1) + (snd p2))
          else None
        )
    )
  "

lemma proj_add_inv:
  assumes "(x0,y0) \<in> e_aff"
  shows "proj_add ((x0,y0),l) (i (x0,y0),l) = Some ((1,0),0)"
proof -
  consider (1) "x0 = 0" | (2) "y0 = 0" | (3) "x0 \<noteq> 0" "y0 \<noteq> 0" by fast
  then show ?thesis
  proof(cases)
    case 1
    from assms 1 have "y0 = 1 \<or> y0 = -1" unfolding e_aff_def e'_def by(simp,algebra) 
    then consider (a) "y0 = 1" | (b) "y0 = -1" by blast
    then show ?thesis  
    proof(cases)
      case a
      then show ?thesis using 1 
        apply(simp add: proj_add.simps) 
        unfolding p_delta'_def delta'_def delta_x_def p_delta_def delta_def delta_minus_def delta_plus_def
        apply(simp add: c_eq_1)
        unfolding e_aff_def e'_def by(simp)
    next
      case b
      then show ?thesis using 1
        apply(simp add: proj_add.simps) 
        unfolding p_delta'_def delta'_def delta_x_def p_delta_def delta_def delta_minus_def delta_plus_def
        apply(simp add: c_eq_1)
        unfolding e_aff_def e'_def by(simp)
    qed
  next
    case 2
    from assms 2 have "x0 = 1 \<or> x0 = -1" unfolding e_aff_def e'_def by(simp,algebra) 
    then consider (a) "x0 = 1" | (b) "x0 = -1" by blast
    then show ?thesis  
    proof(cases)
      case a
      then show ?thesis using 2
        apply(simp add: proj_add.simps) 
        unfolding p_delta'_def delta'_def delta_x_def p_delta_def delta_def delta_minus_def delta_plus_def
        apply(simp add: c_eq_1)
        unfolding e_aff_def e'_def by(simp)
    next
      case b
      then show ?thesis using 2
        apply(simp add: proj_add.simps) 
        unfolding p_delta'_def delta'_def delta_x_def p_delta_def delta_def delta_minus_def delta_plus_def
        apply(simp add: c_eq_1)
        unfolding e_aff_def e'_def by(simp)
    qed
  next
    case 3
    have s_eaff: "(x0,-y0) \<in> e_aff" using assms unfolding e_aff_def e'_def by simp
    from 3 show ?thesis (* TODO: correct *)
      apply(simp add: proj_add.simps) 
      using delta_plus_self
      unfolding p_delta_def delta_def p_delta'_def delta'_def delta_x_def delta_y_def delta_plus_def delta_minus_def      
      apply(simp add: assms c_eq_1,safe)
      unfolding e_aff_def e'_def apply(simp add: t_expr)
          apply(simp add: field_simps power2_eq_square)
         apply(simp add: t_expr)
         apply(simp add: field_simps power2_eq_square)
      using assms s_eaff unfolding e_aff_def e'_def apply(simp add: t_expr )
      apply (simp add: power2_eq_square)
      apply (smt mult_cancel_left1 semiring_normalization_rules(16) semiring_normalization_rules(18) t_expr(1) t_sq_n1)
       using assms s_eaff unfolding e_aff_def e'_def apply(simp add: t_expr )
       using assms s_eaff unfolding e_aff_def e'_def by(simp add: t_expr )
  qed
qed

lemma proj_add_comm:
  "proj_add ((x0,y0),l) ((x1,y1),j) = proj_add ((x1,y1),j) ((x0,y0),l)"
proof -
  have delta_equiv:  
       "(p_delta ((x0,y0),l) ((x1,y1),j) \<noteq> 0) = (p_delta ((x1,y1),j) ((x0,y0),l) \<noteq> 0)"
       "(p_delta' ((x0,y0),l) ((x1,y1),j) \<noteq> 0) = (p_delta' ((x1,y1),j) ((x0,y0),l) \<noteq> 0)"
    unfolding p_delta_def p_delta'_def delta_def delta_plus_def 
              delta_minus_def delta'_def delta_x_def delta_y_def
    by argo+
  consider 
   (1) "p_delta ((x0,y0),l) ((x1,y1),j) \<noteq> 0 \<and> fst ((x0,y0),l)  \<in> e_aff \<and> fst ((x1,y1),j) \<in> e_aff" |
   (2) "p_delta' ((x0,y0),l) ((x1,y1),j) \<noteq> 0 \<and> fst ((x0,y0),l)  \<in> e_aff \<and> fst ((x1,y1),j) \<in> e_aff" |
   (3) "(p_delta ((x0,y0),l) ((x1,y1),j) = 0 \<and> p_delta' ((x0,y0),l) ((x1,y1),j) = 0) \<or> 
        fst ((x0,y0),l) \<notin> e_aff \<or> fst ((x1,y1),j) \<notin> e_aff" by blast
  then show ?thesis
  proof(cases)
    case 1
    then show ?thesis 
      by(simp add: commutativity delta_equiv proj_add.simps del: add.simps ext_add.simps)  
  next
    case 2
    then show ?thesis 
      by(simp add: commutativity ext_add_comm delta_equiv proj_add.simps del: add.simps ext_add.simps)  
  next
    case 3
    then show ?thesis 
      using "3" proj_add.simps delta_equiv(1) delta_equiv(2) by auto
  qed    
qed


definition "proj_add_class c1 c2 =
  (((case_prod (\<lambda> x y. the (proj_add x y))) ` 
   (Map.dom (case_prod proj_add) \<inter> (c1 \<times> c2))) 
   // gluing)"

definition "proj_addition c1 c2 = the_elem(proj_add_class c1 c2)"

lemma gluing_cases:
  assumes "x \<in> e_proj"
  obtains x0 y0 l where "x = {((x0,y0),l)} \<or> x = {((x0,y0),l),(\<tau> (x0,y0),l+1)}"
proof -
  obtain x0 y0 l where "x = gluing `` {((x0,y0),l)}"
    using assms 
    by (metis e_proj_def prod.exhaust_sel quotientE)
  have "x = {((x0,y0),l)} \<or> x = {((x0,y0),l),(\<tau> (x0,y0),l+1)}"
     using e_proj_eq 
     by (smt Image_singleton_iff \<open>x = gluing `` {((x0, y0), l)}\<close> assms doubleton_eq_iff e_proj_def eq_rel equiv_class_eq_iff equiv_class_self insertI1 gluing_char singletonD)
  then show ?thesis 
     using \<open>x = {((x0, y0), l)} \<or> x = {((x0, y0), l), (\<tau> (x0, y0), l + 1)}\<close> add.assoc that by auto
qed

lemma gluing_cases_explicit:
  assumes "x \<in> e_proj" "x = gluing `` {((x0,y0),l)}"
  shows "x = {((x0,y0),l)} \<or> x = {((x0,y0),l),(\<tau> (x0,y0),l+1)}"
proof -
  have "x = {((x0,y0),l)} \<or> x = {((x0,y0),l),(\<tau> (x0,y0),l+1)}"
     using e_proj_eq 
     by (smt Image_singleton_iff \<open>x = gluing `` {((x0, y0), l)}\<close> assms doubleton_eq_iff e_proj_def eq_rel equiv_class_eq_iff equiv_class_self insertI1 gluing_char singletonD)
  then show ?thesis by blast
qed


lemma sum_opp:
  assumes "(x0,y0) \<in> e_aff"
  shows "proj_add ((x0, y0), l) ((\<tau> \<circ> i) (x0, y0), l + 1) = Some (\<tau> (1,0),1) \<or> 
         proj_add ((x0, y0), l) ((\<tau> \<circ> i) (x0, y0), l + 1) = None"
proof -
  consider (1) "p_delta ((x0, y0), l) ((\<tau> \<circ> i) (x0, y0), l + 1) \<noteq> 0" "(x0, y0) \<in> e_aff \<and> ((\<tau> \<circ> i) (x0, y0)) \<in> e_aff" |
           (2) "p_delta ((x0, y0), l) ((\<tau> \<circ> i) (x0, y0), l + 1) = 0" "p_delta' ((x0, y0), l) ((\<tau> \<circ> i) (x0, y0), l + 1) \<noteq> 0" "(x0, y0) \<in> e_aff \<and> ((\<tau> \<circ> i) (x0, y0)) \<in> e_aff" |
           (3) "(p_delta ((x0, y0), l) ((\<tau> \<circ> i) (x0, y0), l + 1) = 0 \<and> p_delta' ((x0, y0), l) ((\<tau> \<circ> i) (x0, y0), l + 1) = 0)
               \<or> (x0,y0) \<notin> e_aff \<or> ((\<tau> \<circ> i) (x0, y0)) \<notin> e_aff" by satx
  then show ?thesis
  proof(cases)
    case 1
    then have "proj_add ((x0, y0), l) ((\<tau> \<circ> i) (x0, y0), l + 1) = 
               Some (add (x0, y0) ((\<tau> \<circ> i) (x0, y0)), 1)"
      by (simp add: proj_add.simps)
    also have "... =  Some (\<tau> (1,0),1)"
      apply(simp add: t_nz field_simps)
      apply(subst power2_eq_square[symmetric])+
      apply(simp add: t_expr d_nz c_eq_1)
      using \<open>(x0,y0) \<in> e_aff\<close> unfolding e_aff_def e'_def by(safe,simp)
    finally show ?thesis by blast
  next
    case 2
    have "x0 \<noteq> 0" "y0 \<noteq> 0" 
      using "2"(1) curve_addition.delta_def curve_addition.delta_minus_def curve_addition.delta_plus_def projective_curve.p_delta_def projective_curve_axioms by auto+
    from 2 have "proj_add ((x0, y0), l) ((\<tau> \<circ> i) (x0, y0), l + 1) =
               Some (ext_add (x0, y0) ((\<tau> \<circ> i) (x0, y0)), 1)"
      by (simp add: proj_add.simps)
    also have "... =  Some (\<tau> (1,0),1)"
      apply(simp add: t_nz field_simps)
      apply(subst power2_eq_square[symmetric])+
      apply(simp add: t_expr d_nz c_eq_1 \<open>x0 \<noteq> 0\<close> \<open>y0 \<noteq> 0\<close>)
      using \<open>(x0,y0) \<in> e_aff\<close> unfolding e_aff_def e'_def 
      apply(simp)
      apply(simp add: t_expr(1))
      by(simp add: power2_eq_square algebra_simps)
    finally show ?thesis by blast
  next
    case 3
    then have "proj_add ((x0, y0), l) ((\<tau> \<circ> i) (x0, y0), l + 1) = None"
      using proj_add.simps by auto
    then show ?thesis
      by(simp add: assms del: \<tau>.simps)
  qed
qed

lemma proj_add_class_inv:
  assumes "x \<in> e_proj"
  shows "(\<exists> y. y \<in> e_proj \<and> proj_add_class x y = {gluing `` {((1, 0), 0)}})"  
  apply(simp add: identity_equiv)
proof -
  obtain x0 y0 l where x_form: "x = {((x0,y0),l)} \<or> x = {((x0,y0),l),(\<tau> (x0,y0),l+1)}"
    using gluing_cases[OF assms] by blast
  then have "(x0,y0) \<in> e_aff"
      using assms unfolding e_proj_def e_aff_bit_def 
      by (metis assms e_aff_bit_def e_proj_def eq_rel in_quotient_imp_subset insert_subset mem_Sigma_iff)
  then have "(x0,-y0) \<in> e_aff"
    unfolding e_aff_def e'_def by(simp)  
  from x_form consider (1) "x = {((x0,y0),l)}" | (2) "x = {((x0,y0),l),(\<tau> (x0,y0),l+1)}" by fast
  then show "\<exists>y. y \<in> e_proj \<and> proj_add_class x y = {{((1, 0), 0)}}"
  proof(cases)
    case 1    
    have add_eq: "proj_add ((x0, y0), l) ((x0, - y0), l) = Some ((1,0),0)"
      using proj_add_inv[OF \<open>(x0,y0) \<in> e_aff\<close>] by simp
    then have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter> {((x0, y0), l)} \<times> {((x0, - y0), l)}) = 
          {(((x0, y0), l),((x0, - y0), l))}" by force      
    have " proj_add_class {((x0, y0), l)} {((x0, -y0), l)} = {{((1, 0), 0)}}"
      unfolding proj_add_class_def apply(subst dom_eq,simp add: add_eq)
      by (simp add: identity_equiv singleton_quotient)
    have "{((x0, -y0), l)} \<in> e_proj"
      using e_proj_elim_1[OF \<open>(x0,y0) \<in> e_aff\<close>] e_proj_elim_1[OF \<open>(x0,-y0) \<in> e_aff\<close>] "1" assms by auto
    show ?thesis 
      using "1" \<open>proj_add_class {((x0, y0), l)} {((x0, - y0), l)} = {{((1, 0), 0)}}\<close> \<open>{((x0, - y0), l)} \<in> e_proj\<close> by auto
  next
    case 2
    from e_proj_elim_2[OF \<open>(x0,y0) \<in> e_aff\<close>] have "x0 \<noteq> 0" "y0 \<noteq> 0"
      using "2" assms by blast+
    then have "(x0,y0) \<in> e_circ" unfolding e_circ_def using \<open>(x0,y0) \<in> e_aff\<close> by blast
    then have "(x0,-y0) \<in> e_circ" using i_circ by auto
    then have "\<tau> (x0,-y0) \<in> e_circ" using \<tau>_circ by blast
    then have "\<tau> (x0,-y0) \<in> e_aff" using e_circ_def by force
    then have "{((x0, -y0), l),(\<tau> (x0, -y0), l+1)} \<in> e_proj" 
      using e_proj_elim_2[OF  \<open>(x0, - y0) \<in> e_aff\<close>] \<open>x0 \<noteq> 0\<close> \<open>y0 \<noteq> 0\<close> by fastforce
    have "\<tau> (x0,y0) \<in> e_aff" 
      using \<open>(x0, y0) \<in> e_circ\<close> \<tau>_circ e_circ_def by auto
    have add_1: "proj_add ((x0,y0),l) ((x0, -y0), l) = Some ((1, 0), 0)"
      using \<open>(x0, y0) \<in> e_aff\<close> proj_add_inv by auto
    have add_2: "proj_add (\<tau> (x0,y0),l+1) (\<tau> (x0, -y0), l+1) = Some ((1, 0), 0)"
    proof -
      have "\<tau> (x0, y0) \<in> e_circ" by (meson \<open>(x0, y0) \<in> e_circ\<close> projective_curve.\<tau>_circ projective_curve_axioms)
      then show ?thesis using e_circ_def proj_add_inv by force
    qed
    have add_3: "proj_add (\<tau> (x0,y0),l+1) ((x0, -y0), l) = None"
      apply(simp del: \<tau>.simps add: proj_add.simps \<open>(x0, y0) \<in> e_aff\<close> \<open>\<tau> (x0,y0) \<in> e_aff\<close>)
      unfolding p_delta'_def delta'_def p_delta_def delta_def
                delta_x_def delta_y_def delta_plus_def delta_minus_def
      by(simp add: \<open>x0 \<noteq> 0\<close> \<open>y0 \<noteq> 0\<close> t_nz power2_eq_square[symmetric] t_expr d_nz)
    have add_4: "proj_add ((x0, y0), l) (\<tau> (x0, -y0), l+1) = None"
      apply(simp del: \<tau>.simps add: proj_add.simps \<open>(x0, y0) \<in> e_aff\<close> \<open>\<tau> (x0,y0) \<in> e_aff\<close>)
      unfolding p_delta'_def delta'_def p_delta_def delta_def
                delta_x_def delta_y_def delta_plus_def delta_minus_def
      by(simp add: \<open>x0 \<noteq> 0\<close> \<open>y0 \<noteq> 0\<close> t_nz power2_eq_square[symmetric] t_expr d_nz)
    have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
     {((x0, y0), l), (\<tau> (x0, y0), l + 1)} \<times> {((x0, - y0), l), (\<tau> (x0, - y0), l + 1)}) =
        {(((x0,y0),l),((x0, -y0), l)),((\<tau> (x0,y0),l+1),(\<tau> (x0, -y0), l+1))}"
      using add_1 add_2 add_3 add_4 by fastforce
    have add_eq: "(\<lambda>(x, y). the (proj_add x y)) `
    {(((x0, y0), l), (x0, - y0), l), ((\<tau> (x0, y0), l + 1), \<tau> (x0, - y0), l + 1)} = 
     {((1, 0), 0)}"
      using add_1 add_2 by auto
    have "proj_add_class {((x0,y0),l),(\<tau> (x0,y0),l+1)} {((x0, -y0), l),(\<tau> (x0, -y0), l+1)} = 
          {{((1, 0), 0)}}" 
      unfolding proj_add_class_def apply(subst dom_eq, subst add_eq)
      by (simp add: identity_equiv singleton_quotient)
    then show ?thesis 
      using "2" \<open>{((x0, - y0), l), (\<tau> (x0, - y0), l + 1)} \<in> e_proj\<close> by blast
  qed
qed

lemma proj_add_class_comm:
  "proj_add_class c1 c2 = proj_add_class c2 c1"
proof - 
  {fix c1 c2
  have "(\<lambda>(x, y). the (proj_add x y)) ` (dom (\<lambda>(x, y). proj_add x y) \<inter> c1 \<times> c2)
      \<subseteq> (\<lambda>(x, y). the (proj_add x y)) ` (dom (\<lambda>(x, y). proj_add x y) \<inter> c2 \<times> c1)"
  proof 
    {fix x y
    assume "(x, y) \<in> (\<lambda>(x, y). the (proj_add x y)) ` (dom (\<lambda>(x, y). proj_add x y) \<inter> c1 \<times> c2)"
    then obtain d0 d1 where d_expr: 
      "(d0,d1) \<in> dom (\<lambda>(x, y). proj_add x y) \<inter> c1 \<times> c2"
      "(x,y) = the (proj_add d0 d1)"
      unfolding image_def by fast
    then have 1: "(x,y) = the (proj_add d1 d0)"             
      using proj_add_comm prod.collapse[symmetric] by metis
    have 2: "(d1,d0) \<in> dom (\<lambda>(x, y). proj_add x y) \<inter> c2 \<times> c1"
    proof -
      from d_expr have d_ins: "(d0,d1) \<in> dom (\<lambda>(x, y). proj_add x y)"
                              "(d0,d1) \<in> c1 \<times> c2" by auto
      have 1: "(d1,d0) \<in> c2 \<times> c1" using d_ins(2) by simp
      have 2: "(d1,d0) \<in> dom (\<lambda>(x, y). proj_add x y)" 
        using d_expr \<open>(x,y) = the (proj_add d1 d0)\<close> d_ins(1)
        unfolding dom_def 
        by(simp,metis prod.collapse proj_add_comm)
      then show ?thesis using 1 by blast
    qed        
    then have "(x, y) \<in> (\<lambda>(x, y). the (proj_add x y)) ` (dom (\<lambda>(x, y). proj_add x y) \<inter> c2 \<times> c1)"
      unfolding image_def 
      apply(simp) using "1" by force}
  then show "\<And>x. x \<in> (\<lambda>(x, y). the (proj_add x y)) `
             (dom (\<lambda>(x, y). proj_add x y) \<inter> c1 \<times> c2) \<Longrightarrow>
         x \<in> (\<lambda>(x, y). the (proj_add x y)) `
              (dom (\<lambda>(x, y). proj_add x y) \<inter> c2 \<times> c1)" 
    by (metis prod.collapse)
  qed}
  note sub = this
  from sub[of c1 c2] sub[of c2 c1] 
  show ?thesis 
   unfolding proj_add_class_def using subset_antisym by metis
qed

lemma rot_tau_com:
  assumes "tr \<in> rotations"
  shows "tr \<circ> \<tau> = \<tau> \<circ> tr"
  using assms unfolding rotations_def by(auto)

thm (latex) rot_tau_com

lemma rot_com:
  assumes "r \<in> rotations" "r' \<in> rotations"
  shows "r' \<circ> r = r \<circ> r'" 
  using assms unfolding rotations_def by force

lemma rot_inv:
  assumes "r \<in> rotations"
  shows "\<exists> r' \<in> rotations. r' \<circ> r = id" 
  using assms unfolding rotations_def by force

lemma rot_aff:
  assumes "r \<in> rotations" "p \<in> e_aff"
  shows "r p \<in> e_aff"
  using assms unfolding rotations_def e_aff_def e'_def
  by(auto simp add: semiring_normalization_rules(16))

lemma group_lem:
  assumes "r' \<in> rotations" "r \<in> rotations"
  assumes "(r' \<circ> i) (x,y) = (\<tau> \<circ> r) (i (x, y))"
  shows "\<exists> r''. r'' \<in> rotations \<and> i (x,y) = (\<tau> \<circ> r'') (i (x,y))" 
proof -
  obtain r'' where "r'' \<circ> r' = id" "r'' \<in> rotations" using rot_inv assms(1) by blast
  then have "i (x,y) = (r'' \<circ> \<tau> \<circ> r) (i (x, y))"
    using assms(3) by (simp,metis pointfree_idE)
  then have "i (x,y) = (\<tau> \<circ> r'' \<circ> r) (i (x, y))"
    using rot_tau_com[OF \<open>r'' \<in> rotations\<close>] by simp
  then show ?thesis using rot_comp[OF \<open>r'' \<in> rotations\<close> assms(2)] by auto    
qed

lemma tau_not_id: "\<tau> \<noteq> id"
  apply(simp add: fun_eq_iff) 
  by (metis c_eq_1 eq_divide_eq_1 mult_cancel_left2 one_power2 t_def t_ineq(1))

lemma sym_not_id:
  assumes "r \<in> rotations"
  shows "\<tau> \<circ> r \<noteq> id"
  using assms unfolding rotations_def 
  apply(subst fun_eq_iff,simp)
  apply(auto)
  using tau_not_id apply auto[1]
  apply (metis d_nz)
  apply (metis eq_divide_eq_1 minus_mult_minus mult.right_neutral ring_normalization_rules(1) semiring_normalization_rules(29) t_expr(1) t_sq_n1)
  by (metis d_nz)

lemma covering:
  assumes "p \<in> e_proj" "q \<in> e_proj"
  shows "proj_add_class p q \<noteq> {}"
proof -
  have "p \<in> e_aff_bit // gluing"
    using assms(1) unfolding e_proj_def by blast
  from e_proj_eq[OF assms(1)] e_proj_eq[OF assms(2)]
  obtain x y l x' y' l' where 
    p_q_expr: "p = {((x, y), l)} \<or> p = {((x, y), l), (\<tau> (x, y), l + 1)} " 
    "q = {((x', y'), l')} \<or> q = {((x', y'), l'), (\<tau> (x', y'), l' + 1)}"
    "(x,y) \<in> e_aff" "(x',y') \<in> e_aff" 
    by blast
  then have gluings: "p = (gluing `` {((x,y),l)})" 
                     "q = (gluing `` {((x',y'),l')})"
    using assms(1) assms(2) unfolding e_proj_def 
    using Image_singleton_iff equiv_class_eq_iff[OF eq_rel] insertI1 quotientE
    by metis+
  consider 
     "(x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))" 
   | "((x, y), x', y') \<in> e_aff_0" 
   | "((x, y), x', y') \<in> e_aff_1"
    using dichotomy_1[OF \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close>] by blast
  then show ?thesis 
  proof(cases)
    case 1
    then obtain r where eq: "(x',y') = (\<tau> \<circ> r) (i (x,y))" "r \<in> rotations"
      unfolding symmetries_def rotations_def by force
    then have "\<tau> \<in> G" unfolding G_def by auto
    have "i (x,y) \<in> e_circ"
      using 1 unfolding e_circ_def e_aff_def e'_def by auto
    then have "(\<tau> \<circ> r \<circ> i) (x, y) \<in> e_circ" 
      using i_circ rho_circ rot_circ \<tau>_circ eq(2) by auto
    have "\<tau> (x',y') \<noteq> (\<tau> \<circ> r \<circ> i) (x,y)"
      unfolding eq(1) 
      using g_no_fp[OF \<open>\<tau> \<in> G\<close> \<open>(\<tau> \<circ> r \<circ> i) (x, y) \<in> e_circ\<close>] 
      apply(simp)
      by (metis \<tau>.simps c_eq_1 d_nz divide_divide_eq_left fst_conv id_apply mult.assoc mult_cancel_right1 power2_eq_square semiring_normalization_rules(11) t_expr(1) t_sq_n1)
    have "\<tau> (x',y') \<in> e_aff" 
      using \<open>(\<tau> \<circ> r \<circ> i) (x, y) \<in> e_circ\<close> eq e_circ_def \<tau>_circ by auto
    
    have "\<tau> (x',y') \<in> e_circ" 
      using \<tau>_circ \<open>(\<tau> \<circ> r \<circ> i) (x, y) \<in> e_circ\<close> eq(1) by auto 
    then have "(\<tau> (x',y'),l'+1) \<in> (gluing `` {((x',y'),l')})"
      unfolding gluing_def Image_def 
      apply(simp split: prod.splits del: \<tau>.simps,safe)
      apply (simp add: p_q_expr(4))
      using \<open>\<tau> (x', y') \<in> e_aff\<close> apply auto[1]
      using \<open>(\<tau> \<circ> r \<circ> i) (x, y) \<in> e_circ\<close> eq(1) by auto
    then have sc: "(gluing `` {((x',y'),l')}) = (gluing `` {(\<tau> (x',y'),l'+1)})"
      by (meson Image_singleton_iff eq_rel equiv_class_eq_iff)
    have "proj_add_class p q =
          proj_add_class (gluing `` {((x,y),l)}) (gluing `` {((x',y'),l')})"
      using gluings by simp
    also have "... = 
          proj_add_class (gluing `` {((x,y),l)}) (gluing `` {(\<tau> (x',y'),l'+1)})"
      using sc by simp
    finally have eq_simp: "proj_add_class p q = proj_add_class (gluing `` {((x,y),l)}) (gluing `` {(\<tau> (x',y'),l'+1)})"
      by blast

    consider
      "(x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. \<tau> (x', y') = (g \<circ> i) (x, y))" 
    | "((x, y), \<tau> (x', y')) \<in> e_aff_0" 
    | "((x, y), \<tau> (x', y')) \<in> e_aff_1"
      using dichotomy_1[OF \<open>(x,y) \<in> e_aff\<close> \<open>\<tau> (x', y') \<in> e_aff\<close>] by blast  
    then show ?thesis
    proof(cases)
      case 1
      define q' where "q' = \<tau> (x',y')"
      from 1 have "(x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. q' = (g \<circ> i) (x, y))"
        by(simp add: q'_def)  
      then obtain r' where eq1: "q' = (\<tau> \<circ> r') (i (x,y))" "r' \<in> rotations"
        unfolding symmetries_def rotations_def by force
      then have "\<tau> (x',y') = (\<tau> \<circ> r') (i (x,y))" 
        by(simp add: q'_def)  
      then have "(x',y') = (r' \<circ> i) (x,y)" 
        using tau_sq apply(simp del: \<tau>.simps) by (metis surj_pair)
      then have "(r' \<circ> i) (x,y) = (\<tau> \<circ> r) (i (x, y))"
        using eq by simp
      then obtain r'' where eq2: "i (x,y) = (\<tau> \<circ> r'') (i (x,y))" "r'' \<in> rotations"
        using group_lem[OF \<open>r' \<in> rotations\<close> \<open>r \<in> rotations\<close>] by blast
      have "\<tau> \<circ> r'' \<in> G" 
        using G_def \<open>r'' \<in> rotations\<close> rotations_def 
        apply(simp) 
        using G_def \<open>(r' \<circ> i) (x, y) = (\<tau> \<circ> r) (i (x, y))\<close> symmetries_def tau_rot_sym by auto
      have "i (x,y) \<in> e_circ" 
        using \<open>i (x, y) \<in> e_circ\<close> by auto
      have "\<tau> \<circ> r'' \<noteq> id"
        using sym_not_id[OF \<open>r'' \<in> rotations\<close>] by blast
      then have "False"
        using g_no_fp[OF \<open>\<tau> \<circ> r'' \<in> G\<close> \<open>i (x,y) \<in> e_circ\<close> eq2(1)[symmetric]]
        by blast
      then show ?thesis by blast
    next
      case 2
      define x'' where "x'' = fst (\<tau> (x',y'))"
      define y'' where "y'' = snd (\<tau> (x',y'))"
      from 2 have "delta x y x'' y'' \<noteq> 0"
        unfolding e_aff_0_def using x''_def y''_def by simp 
      then obtain v where add_some: "proj_add ((x,y),l) ((x'',y''),l'+1) = Some v"
        using proj_add.simps[of "((x,y),l)" "((x'',y''),l'+1)"] p_q_expr
        unfolding p_delta_def 
        using \<open>\<tau> (x', y') \<in> e_aff\<close> fst_conv x''_def y''_def by auto
      have in_set: "(((x,y),l),((x'',y''),l'+1)) \<in> (dom (\<lambda>(x, y). proj_add x y) \<inter> p \<times> q)"
        unfolding dom_def using p_q_expr 
        apply(simp del: \<tau>.simps)
        apply(rule conjI)
        apply (metis add_some surjective_pairing)
        apply(rule conjI)     
        apply blast
        using \<open>(\<tau> (x', y'), l' + 1) \<in> gluing `` {((x', y'), l')}\<close> gluings(2) x''_def y''_def by auto
      then show ?thesis 
        unfolding proj_add_class_def 
        using add_some in_set by blast
    next
      case 3
      define x'' where "x'' = fst (\<tau> (x',y'))"
      define y'' where "y'' = snd (\<tau> (x',y'))"
      from 3 have "delta' x y x'' y'' \<noteq> 0"
        unfolding e_aff_1_def using x''_def y''_def by simp 
      then obtain v where add_some: "proj_add ((x,y),l) ((x'',y''),l'+1) = Some v"
        using proj_add.simps[of "((x,y),l)" "((x'',y''),l'+1)"] p_q_expr
        unfolding p_delta'_def 
        using \<open>\<tau> (x', y') \<in> e_aff\<close> fst_conv x''_def y''_def 
        by (metis prod.collapse snd_conv)
      have in_set: "(((x,y),l),((x'',y''),l'+1)) \<in> (dom (\<lambda>(x, y). proj_add x y) \<inter> p \<times> q)"
        unfolding dom_def using p_q_expr 
        apply(simp del: \<tau>.simps)
        apply(rule conjI)
        apply (metis add_some surjective_pairing)
        apply(rule conjI)     
        apply blast
        using \<open>(\<tau> (x', y'), l' + 1) \<in> gluing `` {((x', y'), l')}\<close> gluings(2) x''_def y''_def by auto
      then show ?thesis 
        unfolding proj_add_class_def 
        using add_some in_set by blast
  qed
  next
    case 2
    then have "delta x y x' y' \<noteq> 0" 
      unfolding e_aff_0_def by simp
    then obtain v where add_some: "proj_add ((x,y),l) ((x',y'),l') = Some v"
      using proj_add.simps[of "((x,y),l)" "((x',y'),l')"] p_q_expr
      unfolding p_delta_def by auto
    then have in_set: "(((x,y),l),((x',y'),l')) \<in> (dom (\<lambda>(x, y). proj_add x y) \<inter> p \<times> q)"
      unfolding dom_def using p_q_expr by fast
    then show ?thesis 
      unfolding proj_add_class_def 
      using add_some in_set by blast
  next
    case 3
    then have "delta' x y x' y' \<noteq> 0" 
      unfolding e_aff_1_def by simp
    then obtain v where add_some: "proj_add ((x,y),l) ((x',y'),l') = Some v"
      using proj_add.simps[of "((x,y),l)" "((x',y'),l')"] p_q_expr
      unfolding p_delta'_def by fastforce
    then have in_set: "(((x,y),l),((x',y'),l')) \<in> (dom (\<lambda>(x, y). proj_add x y) \<inter> p \<times> q)"
      unfolding dom_def using p_q_expr by fast
    then show ?thesis 
      unfolding proj_add_class_def 
      using add_some in_set by blast
  qed
qed

lemma wd_d_nz:
  assumes "g \<in> symmetries" "(x', y') = (g \<circ> i) (x, y)" "(x,y) \<in> e_circ"
  shows "delta x y x' y' = 0"
  using assms unfolding symmetries_def e_circ_def delta_def delta_minus_def delta_plus_def
  by(auto,auto simp add: divide_simps t_nz t_expr(1) power2_eq_square[symmetric] d_nz)

lemma wd_d'_nz:
  assumes "g \<in> symmetries" "(x', y') = (g \<circ> i) (x, y)" "(x,y) \<in> e_circ"
  shows "delta' x y x' y' = 0"
  using assms unfolding symmetries_def e_circ_def delta'_def delta_x_def delta_y_def
  by(auto)

(* This kind of lemma may vary with different fields *)
lemma e_aff_x0:
  assumes "x = 0" "(x,y) \<in> e_aff"
  shows "y = 1 \<or> y = -1"
  using assms unfolding e_aff_def e'_def
  by(simp,algebra)

lemma e_aff_y0:
  assumes "y = 0" "(x,y) \<in> e_aff"
  shows "x = 1 \<or> x = -1"
  using assms unfolding e_aff_def e'_def
  by(simp,algebra) 

lemma add_ext_add:
  assumes "x1 \<noteq> 0" "y1 \<noteq> 0" "x2 \<noteq> 0" "y2 \<noteq> 0"
  shows "ext_add (x1,y1) (x2,y2) = \<tau> (add (\<tau> (x1,y1)) (x2,y2))"
  apply(simp)
  apply(rule conjI)
  apply(simp add: c_eq_1)
  apply(simp add: divide_simps t_nz power2_eq_square[symmetric] assms t_expr(1) d_nz)
  apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1)) 
  apply(simp add: divide_simps t_nz power2_eq_square[symmetric] assms t_expr(1) d_nz)
  by(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1)) 

corollary add_ext_add_2:
  assumes "x1 \<noteq> 0" "y1 \<noteq> 0" "x2 \<noteq> 0" "y2 \<noteq> 0"
  shows "add (x1,y1) (x2,y2) = \<tau> (ext_add (\<tau> (x1,y1)) (x2,y2))"
proof -
  obtain x1' y1' where tau_expr: "\<tau> (x1,y1) = (x1',y1')" by simp
  then have p_nz: "x1' \<noteq> 0" "y1' \<noteq> 0" 
    using assms(1) tau_sq apply auto[1]
    using \<open>\<tau> (x1, y1) = (x1', y1')\<close> assms(2) tau_sq by auto
  have "add (x1,y1) (x2,y2) = add (\<tau> (x1', y1')) (x2, y2)"
    using tau_expr tau_idemp 
    by (metis comp_apply id_apply)
  also have "... = \<tau> (ext_add (x1', y1') (x2, y2))"
    using add_ext_add[OF p_nz assms(3,4)] tau_idemp by simp
  also have "... = \<tau> (ext_add (\<tau> (x1, y1)) (x2, y2))"
    using tau_expr tau_idemp by auto
  finally show ?thesis by blast
qed

lemma gluing_inv:
  assumes "x \<noteq> 0" "y \<noteq> 0" "(x,y) \<in> e_aff"
  shows "gluing `` {((x,y),j)} = gluing `` {(\<tau> (x,y),j+1)}"
proof
  have tr: "\<tau> (x,y) \<in> e_aff" "\<tau> (x,y) \<in> e_circ"
      using e_circ_def assms \<tau>_circ by fastforce+ 
  show "gluing `` {((x,y), j)} \<subseteq> gluing `` {(\<tau> (x,y), j + 1)}"
  proof     
    {fix p b
    assume as: "(p, b) \<in> gluing `` {((x,y), j)}"
    then have "(p,b) \<in> e_aff_bit"
      unfolding e_aff_bit_def gluing_def 
      using as e_aff_bit_def eq_rel equiv_class_eq_iff by fastforce   
    have in_glue: "(((x,y), j), p, b) \<in> gluing" using as by blast
    have "(p = (x,y) \<and> b = j) \<or> (p = \<tau> (x,y) \<and> b = j+1)"
      using gluing_char in_glue 
      by (smt add.assoc add.commute add.left_neutral add.right_neutral bit_add_eq_1_iff prod.collapse)
    then consider
      (1) "p = (x,y)" "b = j" |
      (2) "p = \<tau> (x,y)" "b = j+1" by blast
    then have "((\<tau> (x,y), j + 1), p, b) \<in> gluing" 
      apply(cases)
      using tr unfolding gluing_def by(simp add: t_nz assms)+
    then have "(p, b) \<in> gluing `` {(\<tau> (x,y), j + 1)}" by auto}
    then show "\<And>xa. xa \<in> gluing `` {((x, y), j)} \<Longrightarrow>
          xa \<in> gluing `` {(\<tau> (x, y), j + 1)}" by auto
  qed

  show "gluing `` {(\<tau> (x, y), j + 1)} \<subseteq> gluing `` {((x, y), j)}"
  proof     
    {fix p b
    assume as: "(p, b) \<in> gluing `` {(\<tau> (x, y), j + 1)}"
    then have "(p,b) \<in> e_aff_bit"
      unfolding e_aff_bit_def gluing_def 
      using as e_aff_bit_def eq_rel equiv_class_eq_iff by fastforce  
    obtain x' y' where p_expr: "p = (x',y')" by fastforce
    obtain xt yt where tau_expr: "\<tau> (x,y) = (xt,yt)" by simp
    have in_glue: "((\<tau> (x, y), j + 1), p, b) \<in> gluing" using as by blast
    then have in_glue_coord: "(((xt,yt), j + 1), (x',y'), b) \<in> gluing" 
      using \<open>p = (x',y')\<close> \<open>\<tau> (x,y) = (xt,yt)\<close> by auto
    have "(p = (x,y) \<and> b = j) \<or> (p = \<tau> (x,y) \<and> b = j+1)"
      using gluing_char[OF in_glue_coord] p_expr tau_expr 
      apply(simp add: algebra_simps del: \<tau>.simps)
      using pointfree_idE tau_idemp by force
    then consider
      (1) "p = (x,y)" "b = j" |
      (2) "p = \<tau> (x,y)" "b = j+1" by blast
    then have "(((x,y), j), p, b) \<in> gluing" 
      apply(cases)
      using \<open>(p, b) \<in> e_aff_bit\<close> eq_rel equiv_class_eq_iff apply fastforce
      using tr unfolding gluing_def by(simp add: e_circ_def assms)
    then have "(p, b) \<in> gluing `` {((x,y), j)}" by blast}
    then show "\<And>xa. xa \<in> gluing `` {(\<tau> (x, y), j + 1)} \<Longrightarrow>
          xa \<in> gluing `` {((x, y), j)}" by auto
  qed
qed 

(*lemma 
  assumes "gluing `` {((x0,y0),l)} \<in> e_proj" "gluing `` {((x1,y1),j)} \<in> e_proj"
          "x0 = 0 \<or> y0 = 0 \<or> x1 = 0 \<or> y1 = 0" "(x0,y0) \<in> e_aff" "(x1,y1) \<in> e_aff"
  shows "card (proj_add_class p q) = 1"
proof -
  consider (1) "x0 = 0" | (2) "y0 = 0" | (3) "x1 = 0" | (4) "y1 = 0" using assms by blast
  then show ?thesis
  proof(cases)
    case 1
    have x_expr: "y0 = 1 \<or> y0 = -1"
      using e_aff_x0[OF 1 assms(4)]  by simp
    have "(0, y0) \<in> e_aff \<and> (x1, y1) \<in> e_aff" 
      using assms 1 by blast
    have "delta x0 y0 x1 y1 \<noteq> 0" 
      unfolding delta_def delta_plus_def delta_minus_def
      using 1 by simp
    have d_0_nz: "delta 0 y0 x1 y1 \<noteq> 0" 
      unfolding delta_def delta_plus_def delta_minus_def by auto
    have "(0, 1 / (t * y0)) \<notin> e_aff"
            using \<open>(x0,y0) \<in> e_aff\<close> 1 unfolding e_aff_def e'_def 
            apply(simp add: divide_simps t_sq_n1 t_nz,safe)
            by (simp add: power_mult_distrib t_sq_n1)
    have v1: "proj_add ((0, y0), l) ((x1, y1), j) = Some ((- (c * y0 * y1), y0 * x1), l + j)"
      apply(simp add: proj_add.simps \<open>(x0,y0) \<in> e_aff\<close> p_delta_def d_0_nz)
      using \<open>(0, y0) \<in> e_aff \<and> (x1, y1) \<in> e_aff\<close> by simp
    have v2: "proj_add ((0, y0), l) (\<tau> (x1, y1), j + 1) = Some v"
      apply(simp add: proj_add.simps \<open>(x0,y0) \<in> e_aff\<close> p_delta_def d_0_nz t_nz)
      
    have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                  {(((0, y), l), (x', 0), l'),
                   (((x, y), l), \<tau> (x', 0), l' + 1)}) = 
                {(((x, y), l), (x', 0), l')}" 
            using v1 v2 by auto
          show ?thesis 
            unfolding 2 apply(simp add: bb t_nz del: \<tau>.simps)
            unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
            unfolding quotient_def by auto
    then show ?thesis 
      
      sorry
  next
    case 2
    then show ?thesis sorry
  next
    case 3
    then show ?thesis sorry
  next
    case 4
    then show ?thesis sorry
  qed

have x_expr: "x' = 1 \<or> x' = -1"
            using e_aff_y0[OF bb \<open>(x',y') \<in> e_aff\<close>] by simp
          have "delta x y x' y' \<noteq> 0" 
            unfolding delta_def delta_plus_def delta_minus_def
            using bb by simp
          have d_0_nz: "delta x y x' 0 \<noteq> 0" 
            unfolding delta_def delta_plus_def delta_minus_def by auto
          have "(1 / (t * x'),0) \<notin> e_aff"
            unfolding e_aff_def e'_def 
            using \<open>(x',y') \<in> e_aff\<close> bb unfolding e_aff_def e'_def 
            apply(simp add: divide_simps t_sq_n1 t_nz,safe)
            by (simp add: power_mult_distrib t_sq_n1)
          have v1: "proj_add ((x, y), l) ((x', 0), l') = Some ((x * x', y * x'), l + l')"
            apply(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> p_delta_def d_0_nz)
            using b bb unfolding e_aff_0_def by simp
          have v2: "proj_add ((x, y), l) (\<tau> (x', 0), l' + 1) = None"
            apply(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> p_delta_def d_0_nz)
            by(simp add: \<open>(1 / (t * x'),0) \<notin> e_aff\<close>)
          have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                  {(((x, y), l), (x', 0), l'),
                   (((x, y), l), \<tau> (x', 0), l' + 1)}) = 
                {(((x, y), l), (x', 0), l')}" 
            using v1 v2 by auto
          show ?thesis 
            unfolding 2 apply(simp add: bb t_nz del: \<tau>.simps)
            unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
            unfolding quotient_def by auto
*)

lemma eq_class_image:
  assumes "(x,y) \<in> e_aff" 
  shows "(gluing `` {((x,y), l)}) // gluing = 
         {gluing `` {((x,y), l)}}"
proof(rule eq_class_simp)
  have "((x,y),l) \<in> e_aff_bit" 
    using assms unfolding e_aff_bit_def Bits_def 
    by (metis Bit_cases SigmaI image_eqI)
  then have "gluing `` {((x, y), l)} \<in> e_aff_bit // gluing"
    by (simp add: quotientI)
  show "gluing `` {((x, y), l)} \<noteq> {}" 
    using \<open>gluing `` {((x, y), l)} \<in> e_aff_bit // gluing\<close> e_proj_def e_proj_eq 
    by fastforce
  show "gluing `` {((x, y), l)} \<in> e_proj"
    using \<open>gluing `` {((x, y), l)} \<in> e_aff_bit // gluing\<close> unfolding e_proj_def
    by blast
qed

lemma e_points:
  assumes "(x,y) \<in> e_aff"
  shows "gluing `` {((x,y),l)} \<in> e_proj"
  by (metis assms e_proj_def e_proj_elim_1 e_proj_elim_2 eq_rel in_quotient_imp_subset insert_subset quotientI)

lemma e_class:
  assumes "gluing `` {(p,l)} \<in> e_proj"
  shows "p \<in> e_aff"
  by (smt assms e_aff_bit_def e_points e_proj_def e_proj_elim_1 e_proj_elim_2 eq_equiv_class eq_rel equiv_class_eq_iff gluing_cases_explicit in_quotient_imp_subset insert_subset mem_Sigma_iff projective_curve.e_proj_eq projective_curve_axioms)

lemma proj_add_class_identity:
  assumes "x \<in> e_proj"
  shows "proj_add_class (gluing `` {((1, 0), 0)}) x = {x}"
proof -
  have "((1,0),0) \<in> e_aff_bit"
    unfolding e_aff_bit_def e_aff_def e'_def Bits_def
    using zero_bit_def by fastforce
  have "(((1, 0), 0), ((1, 0), 0)) \<in> gluing"
    using eq_rel \<open>((1,0),0) \<in> e_aff_bit\<close>
    unfolding equiv_def refl_on_def by blast
  have gluing_one: "gluing `` {((1, 0), 0)} = {((1,0),0)}"
    unfolding Image_def apply(simp)
    using gluing_char_zero \<open>(((1, 0), 0), ((1, 0), 0)) \<in> gluing\<close> by fast
  { fix e1 e2 b
    assume "((e1,e2),b) \<in> x"
    then have "((e1,e2),b) \<in> e_aff_bit"
      using assms unfolding e_proj_def
      using eq_rel in_quotient_imp_subset by blast
    have 1: "p_delta ((1,0),0) ((e1,e2),b) \<noteq> 0"
      unfolding p_delta_def delta_def delta_plus_def delta_minus_def by auto
    have 2: "(e1,e2) \<in> e_aff" "(1,0) \<in> e_aff" 
      using \<open>((e1,e2),b) \<in> e_aff_bit\<close> \<open>((1,0),0) \<in> e_aff_bit\<close> unfolding e_aff_bit_def by blast+   
    have "proj_add ((1,0),0) ((e1,e2),b) = Some ((e1,e2),b)"
      using 1 2 by(simp add: proj_add.simps)
  }
  note sol = this
  from sol have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter> {((1, 0), 0)} \<times> x) = {((1, 0), 0)} \<times> x"
    using assms unfolding dom_def by fast
  from sol have add_eq: "(\<lambda>(x, y). the (proj_add x y)) ` ({((1, 0), 0)} \<times> x) = 
                x" by force
  have "x \<noteq> {}"
    using assms
    by (metis e_proj_def empty_iff eq_rel equiv_class_self quotientE)
  show ?thesis
    apply(simp add: gluing_one)
    unfolding proj_add_class_def
    by(simp add: dom_eq add_eq eq_class_simp[OF assms \<open>x \<noteq> {}\<close>])    
qed

lemma "gluing `` {((1, 0), 0)} = {((1,0),0)}"
  unfolding Image_def apply(simp,standard)
proof -
  show "{y. (((1, 0), 0), y) \<in> gluing} \<subseteq> {((1, 0), 0)}" 
    using gluing_char_zero by(metis (mono_tags, lifting) i.cases insertI1 mem_Collect_eq subrelI)
  have "(1,0) \<in> e_aff" 
    unfolding e_aff_def e'_def by(simp)
  then have "((1, 0), 0) \<in> e_aff_bit"
    unfolding e_aff_bit_def Bits_def
    using zero_bit_def by blast
  show "{((1, 0), 0)} \<subseteq> {y. (((1, 0), 0), y) \<in> gluing}"
  apply(simp)
    using eq_rel unfolding equiv_def refl_on_def 
    using \<open>((1, 0), 0) \<in> e_aff_bit\<close> by blast
qed

lemma b_cc_case:
  assumes closure_lem: "add (x, y) (\<tau> (x', y')) \<in> e_aff"
  assumes x_y_aff: "(x,y) \<in> e_aff" "\<tau> (x', y') \<in> e_aff" "\<tau> (x', y') \<in> e_circ"
  assumes cc: "x' \<noteq> 0" "y' \<noteq> 0"
  assumes eq: "x' * y' \<noteq> - x * y" "x' * y' \<noteq> x * y" 
  assumes b: "\<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))"
  shows "
  fst (add (x,y) (\<tau> (x',y'))) = 0 \<or> 
  snd (add (x,y) (\<tau> (x',y'))) = 0 \<Longrightarrow>
  (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))"
proof -
  assume as: "fst (add (x,y) (\<tau> (x',y'))) = 0 \<or> snd (add (x,y) (\<tau> (x',y'))) = 0"
  define r1 where "r1 = fst(add (x,y) (\<tau> (x',y')))"
  define r2 where "r2 = snd(add (x,y) (\<tau> (x',y')))"
  from closure_lem have "(r1,r2) \<in> e_aff" using r1_def r2_def by simp
  have cases: "r1 = 0 \<or> r2 = 0" 
    using as r1_def r2_def by presburger
  {assume "r1 = 0" 
  then have "r2 = 1 \<or> r2 = -1"
      using \<open>(r1,r2) \<in> e_aff\<close> unfolding e_aff_def e'_def 
      by(simp,algebra)}
  note case1 = this
  {assume "r2 = 0" 
  then have "r1 = 1 \<or> r1 = -1"
      using \<open>(r1,r2) \<in> e_aff\<close> unfolding e_aff_def e'_def 
      by(simp,algebra)}
  note case2 = this
  from case1 case2 cases obtain g where r_expr: "g \<in> rotations" "(r1,r2) = g (1,0)"
    unfolding rotations_def by force

  have e_eq: "e x y = 0"
    using \<open>(x,y) \<in> e_aff\<close> e_e'_iff unfolding e_aff_def by simp
  have d_eq: "delta_plus x y x y \<noteq> 0"
      unfolding delta_plus_def
      apply(subst (1) mult.assoc,subst (2) mult.assoc,subst (1) mult.assoc)
      apply(subst power2_eq_square[symmetric])
      using mult_nonneg_nonneg[OF c_d_pos zero_le_power2[of "x*y"]] by auto
  from r_expr have "add (x,y) (\<tau> (x',y')) = g (1,0)" 
    using r1_def r2_def by simp
  also have "... = g (add (x,y) (i (x,y)))"
    using inverse[OF e_eq d_eq] by fastforce
  also have "... = add (x,y) ((g \<circ> i) (x,y))"
    using \<open>g \<in> rotations\<close> unfolding rotations_def
    apply(auto)
    apply(simp add: c_eq_1)+
    apply(simp add: divide_simps)
    apply(simp add: c_eq_1)+
    by(simp add: algebra_simps divide_simps)
  finally have add_eq: "add (x,y) (\<tau> (x',y')) = add (x,y) ((g \<circ> i) (x,y))"
    by blast
  obtain g' where "g' \<in> rotations" "g \<circ> g' = id"
    using rot_inv[OF \<open>g \<in> rotations\<close>] rot_com[OF \<open>g \<in> rotations\<close>] by auto
  then have "add (x,y) (g' (\<tau> (x',y'))) = add (x,y) (i (x,y))"
  proof -
    have 1: "g'(add (x, y) (\<tau> (x', y'))) = add (x, y) (g' (\<tau> (x', y')))"
      using \<open>g' \<in> rotations\<close> unfolding rotations_def 
      apply(auto)
      by(simp add: c_eq_1 divide_simps t_nz cc algebra_simps)+
    have "g'(add (x,y) ((g \<circ> i) (x,y))) = add (x,y) ((g' \<circ> (g \<circ> i)) (x,y))"
      using \<open>g \<in> rotations\<close> \<open>g' \<in> rotations\<close> unfolding rotations_def
      by(metis \<open>g (add (x, y) (i (x, y))) = add (x, y) ((g \<circ> i) (x, y))\<close> \<open>g \<circ> g' = id\<close> \<open>g' \<in> rotations\<close> comp_apply pointfree_idE r_expr(1) rot_com)
    also have "... = add (x,y) (i (x,y))"
      using \<open>g \<circ> g' = id\<close> rot_com[OF \<open>g \<in> rotations\<close> \<open>g' \<in> rotations\<close>] 
      by(simp del: add.simps add: pointfree_idE) 
    finally have "g'(add (x,y) ((g \<circ> i) (x,y))) = add (x,y) (i (x,y))"
      by blast
    then show ?thesis using add_eq 1 by presburger
  qed
  then have "g' (\<tau> (x', y')) = i (x,y)" 
  proof -
    define x2 where "x2 = fst(g' (\<tau> (x', y')))" 
    define y2 where "y2 = snd(g' (\<tau> (x', y')))"
    have 1: "delta x y x2 y2 \<noteq> 0" 
      unfolding delta_def delta_plus_def delta_minus_def x2_def y2_def
      using \<open>g' \<in> rotations\<close> unfolding rotations_def apply(auto)
      using \<open>x' * y' \<noteq> - x * y\<close> by(simp add: \<open>x' * y' \<noteq> x * y\<close> divide_simps cc t_nz 
                                    algebra_simps power2_eq_square[symmetric] t_expr(1) d_nz)+
    have "(x2,y2) \<in> e_aff" 
      using rot_aff[OF \<open>g' \<in> rotations\<close> \<open>\<tau> (x', y') \<in> e_aff\<close>]
      unfolding x2_def y2_def by simp
    have "((x,y),(x2,y2)) \<in> e_aff_0"
      unfolding e_aff_0_def 
      using \<open>(x,y) \<in> e_aff\<close> \<open>(x2,y2) \<in> e_aff\<close> \<open>delta x y x2 y2 \<noteq> 0\<close> 
      by blast
    then show ?thesis
      using add_cancel_2[OF _ \<open>((x,y),(x2,y2)) \<in> e_aff_0\<close>  ] 
      unfolding x2_def y2_def apply(simp del: \<tau>.simps add.simps)
      using \<open>add (x, y) (g' (\<tau> (x', y'))) = add (x, y) (i (x, y))\<close> by auto
  qed
  then have "\<tau> (x', y') = g (i (x,y))"   
    by (metis \<open>g \<circ> g' = id\<close> pointfree_idE)
  then have "(x',y') = \<tau> (g (i (x,y)))" 
    by (metis pointfree_idE tau_idemp)
  then have "False" 
    using b
    by (metis (no_types, hide_lams) \<open>\<tau> (x', y') = g (i (x, y))\<close> \<open>\<tau> (x', y') \<in> e_circ\<close> \<open>g' (\<tau> (x', y')) = i (x, y)\<close> \<open>g' \<in> rotations\<close> comp_apply group_add_class.minus_comp_minus i.simps i_circ id_apply r_expr(1) rot_circ tau_rot_sym)
  then have "fst (add (x,y) (\<tau> (x',y'))) = 0 \<or> snd (add (x,y) (\<tau> (x',y'))) = 0 \<Longrightarrow>
             (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))" by blast
note case1 = this 
 
then show ?thesis 
  using case1 case2 
  unfolding r2_def r1_def 
  apply(simp del: \<tau>.simps add.simps) 
  using \<open>fst (add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (add (x, y) (\<tau> (x', y'))) = 0\<close> by blast              
qed

lemma proj_add_eqs_1: 
  assumes "p = {((x, y), l)}" "q = {((x', y'), l')}" "p \<in> e_proj" "q \<in> e_proj"
  shows "p_delta ((x, y), l) ((x', y'), l') \<noteq> 0 \<Longrightarrow> the_elem (proj_add_class p q) = {(add (x,y) (x',y'),l+l')}"
        "p_delta ((x, y), l) ((x', y'), l') = 0 \<Longrightarrow> p_delta' ((x, y), l) ((x', y'), l') \<noteq> 0 \<Longrightarrow>
         the_elem (proj_add_class p q) = {(ext_add (x,y) (x',y'),l+l')}"
proof -
  have as: "(x,y) \<in> e_aff" "(x',y') \<in> e_aff"
    using assms e_proj_eq by(blast)+
  then have zeros: "x = 0 \<or> y = 0" "x' = 0 \<or> y' = 0"
    using e_proj_elim_1 assms by presburger+
  from assms have "proj_add_class p q = proj_add_class {((x, y), l)} {((x', y'), l')}" by auto
  {assume as': "p_delta ((x, y), l) ((x', y'), l') \<noteq> 0"
   then have v_expr: "proj_add ((x, y), l) ((x', y'), l') = Some (add (x,y) (x',y'),l+l')"
     by (simp add: as(1) as(2) proj_add.simps) 
   have add_closure: "add (x,y) (x',y') \<in> e_aff"
     apply(cases "delta x y x' y' \<noteq> 0")
     using as add_closure e_e'_iff unfolding delta_def e_aff_def apply(simp)
     unfolding e'_def apply(simp add: c_eq_1 t_expr) 
     using delta_minus_def delta_plus_def zeros(2) by auto    
   have add_zeros: "fst (add (x,y) (x',y')) = 0 \<or> snd (add (x,y) (x',y')) = 0"
     using zeros by fastforce
   show "the_elem (proj_add_class p q) = {(add (x,y) (x',y'),l+l')}"
     unfolding proj_add_class_def assms(1,2) image_def dom_def apply(simp add: v_expr del: \<tau>.simps add.simps)
     using add_closure add_zeros e_proj_elim_1 eq_class_simp by auto}

  {assume as': "p_delta ((x, y), l) ((x', y'), l') = 0"
               "p_delta' ((x, y), l) ((x', y'), l') \<noteq> 0"
   then have v_expr: "proj_add ((x, y), l) ((x', y'), l') = Some (ext_add (x,y) (x',y'),l+l')"
     by (simp add: as(1) as(2) proj_add.simps)                    
   have add_closure: "ext_add (x,y) (x',y') \<in> e_aff"
     using as' delta'_def delta_x_def delta_y_def p_delta'_def zeros(1) zeros(2) by auto  
   have add_zeros: "fst (ext_add (x,y) (x',y')) = 0 \<or> snd (ext_add (x,y) (x',y')) = 0"
     using zeros by fastforce
   show "the_elem (proj_add_class p q) = {(ext_add (x,y) (x',y'),l+l')}"
     unfolding proj_add_class_def assms(1,2) image_def dom_def apply(simp add: v_expr del: \<tau>.simps add.simps)
     using add_closure add_zeros e_proj_elim_1 eq_class_simp by auto}
qed  

lemma well_defined_1: 
  assumes "p = {((x, y), l)}" "q = {((x', y'), l')}" "p \<in> e_proj" "q \<in> e_proj"
  shows "the_elem (proj_add_class p q) \<in> e_proj"
proof -
  have as: "(x,y) \<in> e_aff" "(x',y') \<in> e_aff"
    using assms e_proj_eq by(blast)+
  then have zeros: "x = 0 \<or> y = 0" "x' = 0 \<or> y' = 0"
    using e_proj_elim_1 assms by presburger+
  from assms have "proj_add_class p q = proj_add_class {((x, y), l)} {((x', y'), l')}" by auto
  then obtain xc yc ll where v_expr: "proj_add ((x, y), l) ((x', y'), l') = Some ((xc,yc),ll)"
    using covering[OF assms(3-4)] unfolding proj_add_class_def by auto
  then consider (1) "(xc,yc) = add (x,y) (x',y')" "p_delta ((x, y), l) ((x', y'), l') \<noteq> 0" |
                (2) "(xc,yc) = ext_add (x,y) (x',y')"  "p_delta ((x, y), l) ((x', y'), l') = 0" 
    using proj_add.simps by (metis (no_types, lifting) fst_conv not_None_eq option.inject)
  then have "(xc,yc) \<in> e_aff"
  proof(cases)
    case 1
    then show ?thesis 
      apply(cases "delta x y x' y' \<noteq> 0")
      using as add_closure e_e'_iff unfolding delta_def e_aff_def apply(simp)
      apply(simp)
      unfolding e'_def apply(simp add: c_eq_1 t_expr) 
      using delta_minus_def delta_plus_def zeros(2) by auto[1]    
  next
    case 2
    then have "delta' x y x' y' = 0"
      using delta'_def delta_x_def delta_y_def zeros(1) zeros(2) by auto
    from 2 have "delta x y x' y' = 0" 
      unfolding p_delta_def by(simp)
    then show ?thesis 
      using 2                           
      by (metis \<open>delta' x y x' y' = 0\<close> fst_conv not_None_eq p_delta'_def proj_add.simps snd_conv v_expr)
  qed     
   
  have s_map: "(\<lambda>(x, y). the (proj_add x y)) ` (dom (\<lambda>(x, y). proj_add x y) \<inter> p \<times> q) = {((xc,yc),ll)}"
    unfolding image_def dom_def assms(1-2) by(simp add: v_expr) 
  then have proj_eq: "proj_add_class p q = {gluing `` {((xc,yc),ll)}}"
    by (simp add: proj_add_class_def singleton_quotient)

  have "{((xc, yc), ll)} // gluing = {gluing `` {((xc,yc),ll)}}"
    by (simp add: singleton_quotient)
  then show "the_elem (proj_add_class p q) \<in> e_proj"
    unfolding proj_add_class_def 
    apply(simp add: s_map) 
    by (simp add: \<open>(xc, yc) \<in> e_aff\<close> e_points)
qed  

lemma proj_add_eqs_2:
  assumes "p = {((x, y), l)}" "q = {((x', y'), l'), (\<tau> (x', y'), l' + 1)}" 
          "(x,y) \<in> e_aff" "(x',y') \<in> e_aff" "p \<in> e_proj" "q \<in> e_proj"
  shows "(x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)) \<Longrightarrow>
         the_elem (proj_add_class p q) = {((x,y),l)}"
        "((x, y), x', y') \<in> e_aff_0 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))
          \<Longrightarrow> x' = 0 \<Longrightarrow> False"
        "((x, y), x', y') \<in> e_aff_0 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))
          \<Longrightarrow> y' = 0 \<Longrightarrow> False"
        "((x, y), x', y') \<in> e_aff_0 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))
          \<Longrightarrow> x' \<noteq> 0 \<Longrightarrow> y' \<noteq> 0 \<Longrightarrow> x = 0 \<Longrightarrow> the_elem(proj_add_class p q) = {(add (x, y) (\<tau> (x', y')), l + l' + 1), (\<tau> (add (x, y) (\<tau> (x', y'))), l + l')}"
        "((x, y), x', y') \<in> e_aff_0 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))
          \<Longrightarrow> x' \<noteq> 0 \<Longrightarrow> y' \<noteq> 0 \<Longrightarrow> y = 0 \<Longrightarrow> the_elem(proj_add_class p q) = {(\<tau> (add (x, y) (\<tau> (x', y'))), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}"
        "((x, y), x', y') \<in> e_aff_0 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))
          \<Longrightarrow> x' \<noteq> 0 \<Longrightarrow> y' \<noteq> 0 \<Longrightarrow> x \<noteq> 0 \<Longrightarrow> y \<noteq> 0 \<Longrightarrow> 
          p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l)\<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff \<Longrightarrow>
          the_elem(proj_add_class p q) = {(add (x, y) (\<tau> (x', y')),l+l'),(\<tau> (add (x, y) (\<tau> (x', y'))),l+l'+1)}"
        "((x, y), x', y') \<in> e_aff_0 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))
          \<Longrightarrow> x' \<noteq> 0 \<Longrightarrow> y' \<noteq> 0 \<Longrightarrow> x \<noteq> 0 \<Longrightarrow> y \<noteq> 0 \<Longrightarrow> 
          p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l) \<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff \<Longrightarrow>
         False"
        "((x, y), x', y') \<in> e_aff_0 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))
          \<Longrightarrow> x' \<noteq> 0 \<Longrightarrow> y' \<noteq> 0 \<Longrightarrow> x \<noteq> 0 \<Longrightarrow> y \<noteq> 0 \<Longrightarrow> 
          p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<and> p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0
                   \<or> fst ((x, y), l) \<notin> e_aff \<or> fst (\<tau> (x', y'), l' + 1) \<notin> e_aff \<Longrightarrow>
         False"
         "((x, y), x', y') \<in> e_aff_1 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow> ((x, y), x', y') \<notin> e_aff_0 \<Longrightarrow>
          x' = 0 \<Longrightarrow>  
         False"
         "((x, y), x', y') \<in> e_aff_1 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow> ((x, y), x', y') \<notin> e_aff_0 \<Longrightarrow>
          y' = 0 \<Longrightarrow>  
         False"
         "((x, y), x', y') \<in> e_aff_1 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow> ((x, y), x', y') \<notin> e_aff_0 \<Longrightarrow>
          x' \<noteq> 0 \<Longrightarrow> y' \<noteq> 0 \<Longrightarrow> x = 0 \<Longrightarrow>  
         the_elem(proj_add_class p q) = {(\<tau> (ext_add (x, y) (\<tau> (x', y'))), l + l'), (ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}"
        "((x, y), x', y') \<in> e_aff_1 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow> ((x, y), x', y') \<notin> e_aff_0 \<Longrightarrow>
          x' \<noteq> 0 \<Longrightarrow> y' \<noteq> 0 \<Longrightarrow> y = 0 \<Longrightarrow>  
         the_elem(proj_add_class p q) = {(\<tau> (add (x, y) (\<tau> (x', y'))), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}"
        "((x, y), x', y') \<in> e_aff_1 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow> ((x, y), x', y') \<notin> e_aff_0 \<Longrightarrow>
          x' \<noteq> 0 \<Longrightarrow> y' \<noteq> 0 \<Longrightarrow> x \<noteq> 0 \<Longrightarrow> y \<noteq> 0 \<Longrightarrow> p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l)\<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff \<Longrightarrow> 
         False"
        "((x, y), x', y') \<in> e_aff_1 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow> ((x, y), x', y') \<notin> e_aff_0 \<Longrightarrow>
          x' \<noteq> 0 \<Longrightarrow> y' \<noteq> 0 \<Longrightarrow> x \<noteq> 0 \<Longrightarrow> y \<noteq> 0 \<Longrightarrow> p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l) \<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff \<Longrightarrow> 
         False"
        "((x, y), x', y') \<in> e_aff_1 \<Longrightarrow> \<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow> ((x, y), x', y') \<notin> e_aff_0 \<Longrightarrow>
          x' \<noteq> 0 \<Longrightarrow> y' \<noteq> 0 \<Longrightarrow> x \<noteq> 0 \<Longrightarrow> y \<noteq> 0 \<Longrightarrow> p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<and> p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0
                   \<or> fst ((x, y), l) \<notin> e_aff \<or> fst (\<tau> (x', y'), l' + 1) \<notin> e_aff \<Longrightarrow> 
         False"
(*
(aaa) "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l)\<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff" |
            (bbb) "p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l) \<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff" |
            (ccc) "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<and> p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0
                   \<or> fst ((x, y), l) \<notin> e_aff \<or> fst (\<tau> (x', y'), l' + 1) \<notin> e_aff" 
 
*)
proof -
  {assume a: "(x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))"
  then obtain g where "g \<in> symmetries" "(x', y') = (g \<circ> i) (x, y)" by auto        
  then have "delta x y x' y' = 0" "delta' x y x' y' = 0" using wd_d_nz wd_d'_nz a by auto 
  then have one_none: "proj_add ((x, y), l) ((x', y'), l') = None"
    using proj_add.simps unfolding p_delta_def p_delta'_def by auto
  have "(dom (\<lambda>(x, y). proj_add x y) \<inter> {((x, y), l)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}) \<noteq> {}"
    using covering[OF assms(5,6)] unfolding assms(1,2) proj_add_class_def by blast
  then have s_simp: 
    "(dom (\<lambda>(x, y). proj_add x y) \<inter> 
      {((x, y), l)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}) 
     = {(((x, y), l),(\<tau> (x', y'), l' + 1))}" 
    using one_none by auto
  show "the_elem (proj_add_class p q) = {((x,y),l)}"
    using a assms(1) assms(5) e_circ_def e_proj_elim_1 by auto}
  {assume b: "((x, y), x', y') \<in> e_aff_0" "\<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))" 
  then have ld_nz: "delta x y x' y' \<noteq> 0" unfolding e_aff_0_def by auto    
  {assume aa: "x' = 0"
    show "False" 
    using covering aa assms(2) assms(4) assms(6) e_proj_elim_2 by blast}
  {assume bb: "y' = 0"
   then show "False"
     using assms(2) assms(4) assms(6) bb e_proj_elim_2 by blast}
  {assume cc: "x' \<noteq> 0" "y' \<noteq> 0"       
   have "(x',y') \<in> e_circ" unfolding e_circ_def using cc \<open>(x',y') \<in> e_aff\<close> by blast
   then have "\<tau> (x', y') \<in> e_circ" using cc \<tau>_circ by blast
   then have "\<tau> (x', y') \<in> e_aff" unfolding e_circ_def by force 

   have v1: "proj_add ((x, y), l) ((x', y'), l') = Some (add (x, y) (x', y'), l + l')"
     by(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> p_delta_def ld_nz del: add.simps)
   {assume z1: "x = 0"
   then have y_expr: "y = 1 \<or> y = -1"
     using \<open>(x,y) \<in> e_aff\<close> unfolding e_aff_def e'_def 
     by(simp,algebra)
   then have "y*y = 1" by auto
   have "add (x, y) (x', y') = \<rho> (y*x',y*y')"
     by(simp add: z1,simp add: c_eq_1)
   then have v1_def: "proj_add ((x, y), l) ((x', y'), l') = 
                      Some (\<rho> (y*x',y*y'), l + l')"
     using v1 by simp
   have "delta x y (fst (\<tau> (x',y'))) (snd (\<tau> (x',y'))) \<noteq> 0"
     unfolding delta_def delta_plus_def delta_minus_def
     using z1 by simp
   then have v2: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
                  Some (add (x, y) (\<tau> (x', y')), l+l'+1)"
     using proj_add.simps p_delta_def 
     using \<open>\<tau> (x', y') \<in> e_aff\<close> assms(3) by auto 
   have "add (x, y) (\<tau> (x', y')) = \<rho> (y*(fst (\<tau> (x', y'))),y*(snd (\<tau> (x', y'))))"
      by(simp add: z1, simp add: c_eq_1)
    then have "add (x, y) (\<tau> (x', y')) = (\<rho> \<circ> \<tau>) (y*x',y*y')"
      apply(simp)
      apply(rule conjI)
      by(simp add: divide_simps t_nz cc y_expr \<open>y*y = 1\<close>)+
    then have v2_def: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) =
                  Some (\<tau> (\<rho> (y*x',y*y')), l+l'+1)"
      using v2 rot_tau_com rotations_def by auto
    have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
          {(((0, y), l), (x', y'), l'),
           (((0, y), l), \<tau> (x', y'), l' + 1)}) = 
        {(((0, y), l), (x', y'), l'), (((0, y), l), \<tau> (x', y'), l' + 1)}" 
      using v1_def v2_def z1 by auto
    have rho_aff: "\<rho> (y * x', y * y') \<in> e_aff"
        using \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> unfolding e_aff_def e'_def
        apply(cases "y = 1")
        apply(simp add: z1,argo) 
        using y_expr by(simp add: z1,argo) 
    have eq: "{(\<rho> (y * x', y * y'), l + l'), (\<tau> (\<rho> (y * x', y * y')), l + l' + 1)}
              = gluing `` {(\<rho> (y * x', y * y'), l + l')}"
    proof -
      have coord: "fst (\<rho> (y * x', y * y')) \<noteq> 0" "snd (\<rho> (y * x', y * y')) \<noteq> 0" 
        using y_expr cc by auto
      show ?thesis
        using gluing_class[OF coord(1) coord(2)] rho_aff by simp
    qed
    have "\<rho> (y * x', y * y') = \<tau> (add (x, y) (\<tau> (x', y')))"
      using pointfree_idE tau_idemp v2 v2_def by fastforce
    then have "gluing `` {(\<tau> (add (x, y) (\<tau> (x', y'))), l + l')} =
          {(\<tau> (add (x, y) (\<tau> (x', y'))), l + l'),(add (x, y) (\<tau> (x', y')), l + l' + 1)}"
      by (metis eq option.sel v2 v2_def)    
    show "the_elem (proj_add_class p q) =
    {(add (x, y) (\<tau> (x', y')), l + l' + 1), (\<tau> (add (x, y) (\<tau> (x', y'))), l + l')}"
       unfolding assms(1,2) apply(simp add: t_nz z1 del: \<tau>.simps)
       unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
       apply(subst z1[symmetric])+
       apply(subst v1_def,subst v2_def,simp del: \<tau>.simps \<rho>.simps)
       apply(subst eq) 
       by (metis (no_types, lifting) \<open>\<rho> (y * x', y * y') = \<tau> (add (x, y) (\<tau> (x', y')))\<close> \<open>gluing `` {(\<tau> (add (x, y) (\<tau> (x', y'))), l + l')} = {(\<tau> (add (x, y) (\<tau> (x', y'))), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}\<close> \<rho>.simps eq_class_image insert_commute rho_aff the_elem_eq)}
   {assume z2: "y = 0"
   then have x_expr: "x = 1 \<or> x = -1"
      using \<open>(x,y) \<in> e_aff\<close> unfolding e_aff_def e'_def 
      by(simp,algebra)
    then have "x*x = 1" by auto
    have "add (x, y) (x', y') = (x*x',x*y')"
      by(simp add: z2)
    then have v1_def: "proj_add ((x, y), l) ((x', y'), l') = 
                       Some ((x*x',x*y'), l + l')"
      using v1 by simp
    have "delta x y (fst (\<tau> (x',y'))) (snd (\<tau> (x',y'))) \<noteq> 0"
      unfolding delta_def delta_plus_def delta_minus_def
      using z2 by simp
    then have v2: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
               Some (add (x, y) (\<tau> (x', y')), l+l'+1)"
      using proj_add.simps p_delta_def 
      using \<open>\<tau> (x', y') \<in> e_aff\<close> assms(3) by auto 
    have "add (x, y) (\<tau> (x', y')) = (x*(fst (\<tau> (x', y'))),x*(snd (\<tau> (x', y'))))"
      by(simp add: z2)
    then have "add (x, y) (\<tau> (x', y')) = \<tau> (x*x',x*y')"
      apply(simp)
      apply(rule conjI)
      by(simp add: divide_simps t_nz cc x_expr \<open>x*x = 1\<close>)+
    then have v2_def: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) =
                  Some (\<tau> (x*x',x*y'), l+l'+1)"
      using v2 rot_tau_com rotations_def by auto
    have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
          {(((x, 0), l), (x', y'), l'),
           (((x, 0), l), \<tau> (x', y'), l' + 1)}) = 
        {(((x, 0), l), (x', y'), l'), (((x, 0), l), \<tau> (x', y'), l' + 1)}" 
      using v1_def v2_def z2 by auto
    have rho_aff: "(x * x', x * y') \<in> e_aff"
        using \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> unfolding e_aff_def e'_def
        apply(cases "x = 1")
        apply(simp)
        using x_expr by(simp add: z2)
    have eq: "{((x * x', x * y'), l + l'), (\<tau> (x * x', x * y'), l + l' + 1)}
              = gluing `` {((x * x', x * y'), l + l')}"
    proof -
      have coord: "fst ((x * x', x * y')) \<noteq> 0" "snd ((x * x', x * y')) \<noteq> 0" 
        using x_expr cc by auto
      show ?thesis
        using gluing_class[OF coord(1) coord(2)] rho_aff by simp
    qed
    have eq': "add (x, y) (\<tau> (x', y')) = \<tau> (x * x', x * y')"
         "\<tau> (add (x, y) (\<tau> (x', y'))) = (x * x', x * y')"
      using \<open>add (x, y) (\<tau> (x', y')) = \<tau> (x * x', x * y')\<close> apply blast
      using \<open>add (x, y) (\<tau> (x', y')) = \<tau> (x * x', x * y')\<close> pointfree_idE tau_idemp by fastforce
    show "the_elem(proj_add_class p q) = {(\<tau> (add (x, y) (\<tau> (x', y'))), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}"
      unfolding assms(1,2) apply(simp add: t_nz z2 del: \<tau>.simps)
      unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
      apply(subst z2[symmetric])+
      apply(subst v1_def,subst v2_def,simp del: \<tau>.simps \<rho>.simps)
      apply(subst eq)  
      using \<open>\<tau> (add (x, y) (\<tau> (x', y'))) = (x * x', x * y')\<close> \<open>add (x, y) (\<tau> (x', y')) = \<tau> (x * x', x * y')\<close> c_eq_1 eq projective_curve.eq_class_image projective_curve_axioms rho_aff by auto
    }
    {assume z3: "x \<noteq> 0" "y \<noteq> 0"
      {assume aaa: "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l)\<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff"       
      from aaa have aaa_simp: 
        "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
         Some (add (x, y) (\<tau> (x', y')), l+l'+1)" 
        using proj_add.simps by simp
      have "x' * y' \<noteq> - x * y" 
        using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
        apply(simp add: t_nz cc divide_simps)
        apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1) d_nz)
        by(simp add: ring_distribs(1)[symmetric] d_nz)               
      have "x' * y' \<noteq> x * y"
        using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
        apply(simp add: t_nz cc divide_simps)
        by(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1))

      have closure_lem: "add (x, y) (\<tau> (x', y')) \<in> e_aff"
      proof -
        obtain x1 y1 where z2_d: "\<tau> (x', y') = (x1,y1)" by fastforce
        define z3 where "z3 = add (x,y) (x1,y1)"
        obtain x2 y2 where z3_d: "z3 = (x2,y2)" by fastforce
        have "delta x y x1 y1 \<noteq> 0"
          using aaa z2_d unfolding p_delta_def by auto
        then have dpm: "delta_minus x y x1 y1 \<noteq> 0" "delta_plus x y x1 y1 \<noteq> 0"
          unfolding delta_def by auto
        have "(x1,y1) \<in> e_aff"
          unfolding z2_d[symmetric]
          using \<open>\<tau> (x', y') \<in> e_aff\<close> by auto
        have e_eq: "e x y = 0" "e x1 y1 = 0"
          using \<open>(x,y) \<in> e_aff\<close> \<open>(x1,y1) \<in> e_aff\<close> e_e'_iff  unfolding e_aff_def by(auto)
          
        have "e x2 y2 = 0" 
          using add_closure[OF z3_d z3_def dpm ] 
          using add_closure[OF z3_d z3_def dpm e_eq] by simp
        then show ?thesis 
          unfolding e_aff_def using e_e'_iff z3_d z3_def z2_d by simp
      qed      
                   
      have add_nz: 
        "fst (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
        "snd (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
        using b_cc_case[OF closure_lem assms(3) \<open>\<tau> (x', y') \<in> e_aff\<close> \<open>\<tau> (x', y') \<in> e_circ\<close> cc
                         \<open>x' * y' \<noteq> - x * y\<close> \<open>x' * y' \<noteq> x * y\<close> b(2)]  e_circ_def z3(1) z3(2) 
        using b(2) assms(3) apply blast  
        using \<open>fst (add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (add (x, y) (\<tau> (x', y'))) = 0 \<Longrightarrow> \<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)\<close> b(2) e_circ_def assms(3) z3(1) z3(2) by blast 
      then have 1: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} =
                 gluing `` {(\<tau> (add (x,y) (\<tau> (x',y'))),l+l')}"
        using gluing_inv closure_lem by force
      also have "... = gluing `` {(ext_add (x,y) (x',y'),l+l')}"
        using  add_ext_add cc(1) cc(2) curve_addition.commutativity ext_add_comm z3(1) z3(2) 
        using inversion_invariance_1 by presburger
      finally have gl_eq: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} = 
                           gluing `` {(ext_add (x,y) (x',y'),l+l')}" by blast
       have "{((x, y), l)} // gluing = {{((x, y), l)}}"
         using eq_class_simp[OF assms(5)] assms(1) by simp 
      then have ext_to_add: "False" 
        using gluing_class[OF z3 \<open>(x,y) \<in> e_aff\<close>] singleton_quotient
        by (simp add: singleton_quotient)  
      then show "the_elem(proj_add_class p q) = {(add (x, y) (\<tau> (x', y')),l+l'),(\<tau> (add (x, y) (\<tau> (x', y'))),l+l'+1)}"
        by argo}
    {assume bbb: "p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l) \<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff"
    then show "False" 
      using assms(1,3,5) e_proj_elim_1 z3(1,2) by auto
    }
    {assume ccc: "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<and> p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0
                   \<or> fst ((x, y), l) \<notin> e_aff \<or> fst (\<tau> (x', y'), l' + 1) \<notin> e_aff"
    then show "False" 
      using assms(1,3,5) e_proj_elim_1 z3(1,2) by blast
    }}}}
  
  {assume c: "((x, y), x', y') \<in> e_aff_1" "\<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))" "((x, y), x', y') \<notin> e_aff_0"
   then have ld_nz: "delta' x y x' y' \<noteq> 0" 
     unfolding e_aff_1_def by auto    
   {assume aa: "x' = 0"
     then show "False" using aa assms(2,4,6) e_proj_elim_2 by blast}
   {assume bb: "y' = 0"
   then show "False" using assms(2,4,6) bb e_proj_elim_2 by blast}
  {assume cc: "x' \<noteq> 0" "y' \<noteq> 0"
    have "delta x y x' y' = 0" 
      using \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> c
      unfolding e_aff_0_def by force
    have "(x',y') \<in> e_circ"
      unfolding e_circ_def using cc \<open>(x',y') \<in> e_aff\<close> by blast
    then have "\<tau> (x', y') \<in> e_circ" 
      using cc \<tau>_circ by blast
    then have "\<tau> (x', y') \<in> e_aff"
      unfolding e_circ_def by force
    have v1: "proj_add ((x, y), l) ((x', y'), l') = Some (ext_add (x, y) (x', y'), l + l')"
      by(simp add: proj_add.simps p_delta'_def p_delta_def \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> ld_nz \<open>delta x y x' y' = 0\<close>) 
    {assume z1: "x = 0"
    then have y_expr: "y = 1 \<or> y = -1"
      using \<open>(x,y) \<in> e_aff\<close> unfolding e_aff_def e'_def 
      by(simp,algebra)
    then have "y*y = 1" by auto
    have "ext_add (x, y) (x', y') = \<rho> (y*x',y*y')"
      by(simp add: z1 cc divide_simps y_expr \<open>y*y = 1\<close>)
    then have v1_def: "proj_add ((x, y), l) ((x', y'), l') = 
                       Some (\<rho> (y*x',y*y'), l + l')"
      using v1 by(simp)
    have "delta x y (fst (\<tau> (x',y'))) (snd (\<tau> (x',y'))) \<noteq> 0"
      unfolding delta_def delta_plus_def delta_minus_def
      using z1 by simp
    then have v2: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
               Some (ext_add (x, y) (\<tau> (x', y')), l+l'+1)"
      using \<open>delta x y x' y' = 0\<close> delta_def delta_minus_def delta_plus_def z1 by auto
    have "ext_add (x, y) (\<tau> (x', y')) = \<rho> (y*(fst (\<tau> (x', y'))),y*(snd (\<tau> (x', y'))))"
      by(simp add: z1 cc t_nz divide_simps \<open>y*y = 1\<close>)
    then have "ext_add (x, y) (\<tau> (x', y')) = (\<rho> \<circ> \<tau>) (y*x',y*y')"
      apply(simp)
      apply(rule conjI)
      by(simp add: divide_simps t_nz cc y_expr \<open>y*y = 1\<close>)+
    then have v2_def: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) =
                  Some (\<tau> (\<rho> (y*x',y*y')), l+l'+1)"
      using v2 rot_tau_com rotations_def by auto
    have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
          {(((0, y), l), (x', y'), l'),
           (((0, y), l), \<tau> (x', y'), l' + 1)}) = 
        {(((0, y), l), (x', y'), l'), (((0, y), l), \<tau> (x', y'), l' + 1)}" 
      using v1_def v2_def z1 by auto
    have rho_aff: "\<rho> (y * x', y * y') \<in> e_aff"
        using \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> unfolding e_aff_def e'_def
        apply(cases "y = 1")
        apply(simp add: z1,argo) 
        using y_expr by(simp add: z1,argo) 
    have eq: "{(\<rho> (y * x', y * y'), l + l'), (\<tau> (\<rho> (y * x', y * y')), l + l' + 1)}
              = gluing `` {(\<rho> (y * x', y * y'), l + l')}"
    proof -
      have coord: "fst (\<rho> (y * x', y * y')) \<noteq> 0" "snd (\<rho> (y * x', y * y')) \<noteq> 0" 
        using y_expr cc by auto
      show ?thesis
        using gluing_class[OF coord(1) coord(2)] rho_aff by simp
    qed
    have "ext_add (x, y) (\<tau> (x', y')) = \<tau> (\<rho> (y * x', y * y'))" 
         "\<tau> (ext_add (x, y) (\<tau> (x', y'))) = \<rho> (y * x', y * y')"
      using v2 v2_def apply auto
      by(simp add: t_nz)+
    then have "{(\<tau> (ext_add (x, y) (\<tau> (x', y'))), l + l'), (ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}
              = gluing `` {(\<tau> (ext_add (x, y) (\<tau> (x', y'))), l + l')}"
      using eq by presburger
    show "the_elem(proj_add_class p q) = {(\<tau> (ext_add (x, y) (\<tau> (x', y'))), l + l'), (ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}"
      unfolding assms(1,2) apply(simp add: t_nz z1 del: \<tau>.simps)
      unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
      apply(subst z1[symmetric])+
      apply(subst v1_def,subst v2_def,simp del: \<tau>.simps \<rho>.simps)
      apply(subst eq)
      using \<open>delta x y x' y' = 0\<close> add_cancel_right_right c_eq_1 delta_def delta_minus_def 
            delta_plus_def diff_0 z1 zero_neq_one by auto}

    {assume z2: "y = 0"
     then have x_expr: "x = 1 \<or> x = -1"
        using \<open>(x,y) \<in> e_aff\<close> unfolding e_aff_def e'_def 
        by(simp,algebra)
      then have "x*x = 1" by auto
      have "add (x, y) (x', y') = (x*x',x*y')"
        by(simp add: z2)
      then have v1_def: "proj_add ((x, y), l) ((x', y'), l') = 
                         Some ((x*x',x*y'), l + l')"
        using \<open>delta x y x' y' = 0\<close> delta_def delta_minus_def delta_plus_def z2 by auto
      have "delta x y (fst (\<tau> (x',y'))) (snd (\<tau> (x',y'))) \<noteq> 0"
        unfolding delta_def delta_plus_def delta_minus_def
        using z2 by simp
      then have v2: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
                 Some (add (x, y) (\<tau> (x', y')), l+l'+1)"
        using proj_add.simps p_delta_def 
        using \<open>\<tau> (x', y') \<in> e_aff\<close> assms(3) by auto 
      have "add (x, y) (\<tau> (x', y')) = (x*(fst (\<tau> (x', y'))),x*(snd (\<tau> (x', y'))))"
        by(simp add: z2)
      then have "add (x, y) (\<tau> (x', y')) = \<tau> (x*x',x*y')"
        apply(simp)
        apply(rule conjI)
        by(simp add: divide_simps t_nz cc x_expr \<open>x*x = 1\<close>)+
      then have v2_def: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) =
                    Some (\<tau> (x*x',x*y'), l+l'+1)"
        using v2 rot_tau_com rotations_def by auto
      have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
            {(((x, 0), l), (x', y'), l'),
             (((x, 0), l), \<tau> (x', y'), l' + 1)}) = 
          {(((x, 0), l), (x', y'), l'), (((x, 0), l), \<tau> (x', y'), l' + 1)}" 
        using v1_def v2_def z2 by auto
      have rho_aff: "(x * x', x * y') \<in> e_aff"
          using \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> unfolding e_aff_def e'_def
          apply(cases "x = 1")
          apply(simp)
          using x_expr by(simp add: z2)
      have eq: "{((x * x', x * y'), l + l'), (\<tau> (x * x', x * y'), l + l' + 1)}
                = gluing `` {((x * x', x * y'), l + l')}"
      proof -
        have coord: "fst ((x * x', x * y')) \<noteq> 0" "snd ((x * x', x * y')) \<noteq> 0" 
          using x_expr cc by auto
        show ?thesis
          using gluing_class[OF coord(1) coord(2)] rho_aff by simp
      qed
      have "\<tau> (add (x, y) (\<tau> (x', y'))) = (x * x', x * y')"
        using \<open>add (x, y) (\<tau> (x', y')) = \<tau> (x * x', x * y')\<close> pointfree_idE tau_idemp by force
      then have "{(\<tau> (add (x, y) (\<tau> (x', y'))), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)} = 
                  gluing `` {(\<tau> (add (x, y) (\<tau> (x', y'))), l + l')}"
        using \<open>add (x, y) (\<tau> (x', y')) = \<tau> (x * x', x * y')\<close> c_eq_1 eq by auto
      show "the_elem(proj_add_class p q) = {(\<tau> (add (x, y) (\<tau> (x', y'))), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}"
        unfolding assms(1,2) apply(simp add: t_nz z2 del: \<tau>.simps)
        unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
        apply(subst z2[symmetric])+
        apply(subst v1_def,subst v2_def,simp del: \<tau>.simps \<rho>.simps)
        apply(subst eq) 
        by (metis \<open>\<tau> (add (x, y) (\<tau> (x', y'))) = (x * x', x * y')\<close> \<open>add (x, y) (\<tau> (x', y')) = \<tau> (x * x', x * y')\<close> eq eq_class_image rho_aff the_elem_eq)}
      {assume z3: "x \<noteq> 0" "y \<noteq> 0"
        {assume aaa: "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l)\<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff"        
          show "False"
            using z3 cc aaa c 
            using assms(1,3,5) e_proj_elim_1 by blast
        }
        {assume bbb: "p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l) \<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff" 
          then show "False" using assms(1,5) e_proj_elim_1 z3(1,2) by auto          
        }
   
        {assume ccc: "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<and> p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0
                   \<or> fst ((x, y), l) \<notin> e_aff \<or> fst (\<tau> (x', y'), l' + 1) \<notin> e_aff" 
          then show "False" using assms(1,3,5) e_proj_elim_1 z3(1,2) by blast}}}}
qed

lemma well_defined_2:
  assumes "p = {((x, y), l)}" "q = {((x', y'), l'), (\<tau> (x', y'), l' + 1)}" 
          "(x,y) \<in> e_aff" "(x',y') \<in> e_aff" "p \<in> e_proj" "q \<in> e_proj"
  shows "the_elem (proj_add_class p q) \<in> e_proj"
proof -
    consider
        (a) "(x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))" |
        (b) "((x, y), x', y') \<in> e_aff_0" "\<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))" |
        (c) "((x, y), x', y') \<in> e_aff_1" "\<not> ((x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))" "((x, y), x', y') \<notin> e_aff_0"
        using dichotomy_1[OF \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close>] by fast
      then show ?thesis 
      proof(cases)
        case a
        then obtain g where "g \<in> symmetries" "(x', y') = (g \<circ> i) (x, y)" by auto        
        then have "delta x y x' y' = 0" "delta' x y x' y' = 0"
          using wd_d_nz wd_d'_nz a by auto 
        then have one_none: "proj_add ((x, y), l) ((x', y'), l') = None"
          using proj_add.simps unfolding p_delta_def p_delta'_def by auto
        have "(dom (\<lambda>(x, y). proj_add x y) \<inter> {((x, y), l)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}) \<noteq> {}"
          using covering[OF assms(5,6)] unfolding assms(1,2) proj_add_class_def by blast
        then have s_simp: 
          "(dom (\<lambda>(x, y). proj_add x y) \<inter> 
            {((x, y), l)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}) 
           = {(((x, y), l),(\<tau> (x', y'), l' + 1))}" 
          using one_none by auto
        show ?thesis
          unfolding proj_add_class_def assms(1,2)
          apply(subst s_simp) 
          using a assms(1,5) e_circ_def e_proj_elim_1  by auto
      next
        case b
        then have ld_nz: "delta x y x' y' \<noteq> 0" 
          unfolding e_aff_0_def by auto    
        consider 
          (aa) "x' = 0" |
          (bb) "y' = 0" |
          (cc) "x' \<noteq> 0" "y' \<noteq> 0" by blast
        then show ?thesis
        proof(cases)
          case aa
          have y_expr: "y' = 1 \<or> y' = -1"
            using e_aff_x0[OF aa \<open>(x',y') \<in> e_aff\<close>] by simp
          have "delta x y x' y' \<noteq> 0" 
            unfolding delta_def delta_plus_def delta_minus_def
            using aa by simp
          have d_0_nz: "delta x y 0 y' \<noteq> 0" 
            unfolding delta_def delta_plus_def delta_minus_def by auto
          have "(0, 1 / (t * y')) \<notin> e_aff"
            using \<open>(x',y') \<in> e_aff\<close> aa unfolding e_aff_def e'_def 
            apply(simp add: divide_simps t_sq_n1 t_nz,safe)
            by (simp add: power_mult_distrib t_sq_n1)
          have v1: "proj_add ((x, y), l) ((0, y'), l') = Some ((- (c * y * y'), x * y'), l + l')"
            apply(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> p_delta_def d_0_nz)
            using b aa unfolding e_aff_0_def by simp
          have v2: "proj_add ((x, y), l) (\<tau> (0, y'), l' + 1) = None"
            apply(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> p_delta_def d_0_nz)
            by(simp add: \<open>(0, 1 / (t * y')) \<notin> e_aff\<close>)
          have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                  {(((x, y), l), (0, y'), l'),
                   (((x, y), l), \<tau> (0, y'), l' + 1)}) = 
                {(((x, y), l), (0, y'), l')}" 
            using v1 v2 by auto
          show ?thesis 
            unfolding assms(1,2) apply(simp add: aa t_nz del: \<tau>.simps)
            unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
            using aa assms(2,4,6) e_proj_elim_2 by blast
        next
          case bb
          have x_expr: "x' = 1 \<or> x' = -1"
            using e_aff_y0[OF bb \<open>(x',y') \<in> e_aff\<close>] by simp
          have "delta x y x' y' \<noteq> 0" 
            unfolding delta_def delta_plus_def delta_minus_def
            using bb by simp
          have d_0_nz: "delta x y x' 0 \<noteq> 0" 
            unfolding delta_def delta_plus_def delta_minus_def by auto
          have "(1 / (t * x'),0) \<notin> e_aff"
            unfolding e_aff_def e'_def 
            using \<open>(x',y') \<in> e_aff\<close> bb unfolding e_aff_def e'_def 
            apply(simp add: divide_simps t_sq_n1 t_nz,safe)
            by (simp add: power_mult_distrib t_sq_n1)
          have v1: "proj_add ((x, y), l) ((x', 0), l') = Some ((x * x', y * x'), l + l')"
            apply(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> p_delta_def d_0_nz)
            using b bb unfolding e_aff_0_def by simp
          have v2: "proj_add ((x, y), l) (\<tau> (x', 0), l' + 1) = None"
            apply(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> p_delta_def d_0_nz)
            by(simp add: \<open>(1 / (t * x'),0) \<notin> e_aff\<close>)
          have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                  {(((x, y), l), (x', 0), l'),
                   (((x, y), l), \<tau> (x', 0), l' + 1)}) = 
                {(((x, y), l), (x', 0), l')}" 
            using v1 v2 by auto
          show ?thesis 
            unfolding assms(1,2) apply(simp add: bb t_nz del: \<tau>.simps)
            unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
            using assms(2,4,6) bb e_proj_elim_2 by blast
        next
          case cc
          
          have "(x',y') \<in> e_circ"
            unfolding e_circ_def using cc \<open>(x',y') \<in> e_aff\<close> by blast
          then have "\<tau> (x', y') \<in> e_circ" 
            using cc \<tau>_circ by blast
          then have "\<tau> (x', y') \<in> e_aff"
            unfolding e_circ_def by force
            
          have v1: "proj_add ((x, y), l) ((x', y'), l') = Some (add (x, y) (x', y'), l + l')"
            by(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> p_delta_def ld_nz del: add.simps)
          consider 
            (z1) "x = 0" |
            (z2) "y = 0" |
            (z3) "x \<noteq> 0" "y \<noteq> 0" by blast
          then show ?thesis
          proof(cases)
            case z1
            then have y_expr: "y = 1 \<or> y = -1"
              using \<open>(x,y) \<in> e_aff\<close> unfolding e_aff_def e'_def 
              by(simp,algebra)
            then have "y*y = 1" by auto
            have "add (x, y) (x', y') = \<rho> (y*x',y*y')"
              by(simp add: z1,simp add: c_eq_1)
            then have v1_def: "proj_add ((x, y), l) ((x', y'), l') = 
                               Some (\<rho> (y*x',y*y'), l + l')"
              using v1 by simp
            have "delta x y (fst (\<tau> (x',y'))) (snd (\<tau> (x',y'))) \<noteq> 0"
              unfolding delta_def delta_plus_def delta_minus_def
              using z1 by simp
            then have v2: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
                       Some (add (x, y) (\<tau> (x', y')), l+l'+1)"
              using proj_add.simps p_delta_def 
              using \<open>\<tau> (x', y') \<in> e_aff\<close> assms(3) by auto 
            have "add (x, y) (\<tau> (x', y')) = \<rho> (y*(fst (\<tau> (x', y'))),y*(snd (\<tau> (x', y'))))"
              by(simp add: z1, simp add: c_eq_1)
            then have "add (x, y) (\<tau> (x', y')) = (\<rho> \<circ> \<tau>) (y*x',y*y')"
              apply(simp)
              apply(rule conjI)
              by(simp add: divide_simps t_nz cc y_expr \<open>y*y = 1\<close>)+
            then have v2_def: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) =
                          Some (\<tau> (\<rho> (y*x',y*y')), l+l'+1)"
              using v2 rot_tau_com rotations_def by auto
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                  {(((0, y), l), (x', y'), l'),
                   (((0, y), l), \<tau> (x', y'), l' + 1)}) = 
                {(((0, y), l), (x', y'), l'), (((0, y), l), \<tau> (x', y'), l' + 1)}" 
              using v1_def v2_def z1 by auto
            have rho_aff: "\<rho> (y * x', y * y') \<in> e_aff"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> unfolding e_aff_def e'_def
                apply(cases "y = 1")
                apply(simp add: z1,argo) 
                using y_expr by(simp add: z1,argo) 
            have eq: "{(\<rho> (y * x', y * y'), l + l'), (\<tau> (\<rho> (y * x', y * y')), l + l' + 1)}
                      = gluing `` {(\<rho> (y * x', y * y'), l + l')}"
            proof -
              have coord: "fst (\<rho> (y * x', y * y')) \<noteq> 0" "snd (\<rho> (y * x', y * y')) \<noteq> 0" 
                using y_expr cc by auto
              show ?thesis
                using gluing_class[OF coord(1) coord(2)] rho_aff by simp
            qed
            show ?thesis
              unfolding assms(1,2) apply(simp add: t_nz z1 del: \<tau>.simps)
              unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
              apply(subst z1[symmetric])+
              apply(subst v1_def,subst v2_def,simp del: \<tau>.simps \<rho>.simps)
              apply(subst eq)  
              using e_points eq_class_image rho_aff by auto
          next
            case z2
            then have x_expr: "x = 1 \<or> x = -1"
              using \<open>(x,y) \<in> e_aff\<close> unfolding e_aff_def e'_def 
              by(simp,algebra)
            then have "x*x = 1" by auto
            have "add (x, y) (x', y') = (x*x',x*y')"
              by(simp add: z2)
            then have v1_def: "proj_add ((x, y), l) ((x', y'), l') = 
                               Some ((x*x',x*y'), l + l')"
              using v1 by simp
            have "delta x y (fst (\<tau> (x',y'))) (snd (\<tau> (x',y'))) \<noteq> 0"
              unfolding delta_def delta_plus_def delta_minus_def
              using z2 by simp
            then have v2: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
                       Some (add (x, y) (\<tau> (x', y')), l+l'+1)"
              using proj_add.simps p_delta_def 
              using \<open>\<tau> (x', y') \<in> e_aff\<close> assms(3) by auto 
            have "add (x, y) (\<tau> (x', y')) = (x*(fst (\<tau> (x', y'))),x*(snd (\<tau> (x', y'))))"
              by(simp add: z2)
            then have "add (x, y) (\<tau> (x', y')) = \<tau> (x*x',x*y')"
              apply(simp)
              apply(rule conjI)
              by(simp add: divide_simps t_nz cc x_expr \<open>x*x = 1\<close>)+
            then have v2_def: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) =
                          Some (\<tau> (x*x',x*y'), l+l'+1)"
              using v2 rot_tau_com rotations_def by auto
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                  {(((x, 0), l), (x', y'), l'),
                   (((x, 0), l), \<tau> (x', y'), l' + 1)}) = 
                {(((x, 0), l), (x', y'), l'), (((x, 0), l), \<tau> (x', y'), l' + 1)}" 
              using v1_def v2_def z2 by auto
            have rho_aff: "(x * x', x * y') \<in> e_aff"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> unfolding e_aff_def e'_def
                apply(cases "x = 1")
                apply(simp)
                using x_expr by(simp add: z2)
            have eq: "{((x * x', x * y'), l + l'), (\<tau> (x * x', x * y'), l + l' + 1)}
                      = gluing `` {((x * x', x * y'), l + l')}"
            proof -
              have coord: "fst ((x * x', x * y')) \<noteq> 0" "snd ((x * x', x * y')) \<noteq> 0" 
                using x_expr cc by auto
              show ?thesis
                using gluing_class[OF coord(1) coord(2)] rho_aff by simp
            qed
            show ?thesis
              unfolding assms(1,2) apply(simp add: t_nz z2 del: \<tau>.simps)
              unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
              apply(subst z2[symmetric])+
              apply(subst v1_def,subst v2_def,simp del: \<tau>.simps \<rho>.simps)
              apply(subst eq)  
              by (simp add: e_points eq_class_image rho_aff)
          next
            case z3    
            consider
            (aaa) "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l)\<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff" |
            (bbb) "p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l) \<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff" |
            (ccc) "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<and> p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0
                   \<or> fst ((x, y), l) \<notin> e_aff \<or> fst (\<tau> (x', y'), l' + 1) \<notin> e_aff" 
              by(simp add: proj_add.simps,blast) 
          then show ?thesis 
          proof(cases)
            case aaa            
            from aaa have aaa_simp: 
              "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
               Some (add (x, y) (\<tau> (x', y')), l+l'+1)" 
              using proj_add.simps by simp
            have "x' * y' \<noteq> - x * y" 
              using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
              apply(simp add: t_nz cc divide_simps)
              apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1) d_nz)
              by(simp add: ring_distribs(1)[symmetric] d_nz)               
            have "x' * y' \<noteq> x * y"
              using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
              apply(simp add: t_nz cc divide_simps)
              by(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1))

            have closure_lem: "add (x, y) (\<tau> (x', y')) \<in> e_aff"
            proof -
              obtain x1 y1 where z2_d: "\<tau> (x', y') = (x1,y1)" by fastforce
              define z3 where "z3 = add (x,y) (x1,y1)"
              obtain x2 y2 where z3_d: "z3 = (x2,y2)" by fastforce
              have "delta x y x1 y1 \<noteq> 0"
                using aaa z2_d unfolding p_delta_def by auto
              then have dpm: "delta_minus x y x1 y1 \<noteq> 0" "delta_plus x y x1 y1 \<noteq> 0"
                unfolding delta_def by auto
              have "(x1,y1) \<in> e_aff"
                unfolding z2_d[symmetric]
                using \<open>\<tau> (x', y') \<in> e_aff\<close> by auto
              have e_eq: "e x y = 0" "e x1 y1 = 0"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x1,y1) \<in> e_aff\<close> e_e'_iff  unfolding e_aff_def by(auto)
                
              have "e x2 y2 = 0" 
                using add_closure[OF z3_d z3_def dpm ] 
                using add_closure[OF z3_d z3_def dpm e_eq] by simp
              then show ?thesis 
                unfolding e_aff_def using e_e'_iff z3_d z3_def z2_d by simp
            qed      
                         
            have add_nz: 
              "fst (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              "snd (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              using b_cc_case[OF closure_lem assms(3) \<open>\<tau> (x', y') \<in> e_aff\<close> \<open>\<tau> (x', y') \<in> e_circ\<close> cc
                               \<open>x' * y' \<noteq> - x * y\<close> \<open>x' * y' \<noteq> x * y\<close> b(2)]  e_circ_def z3(1) z3(2) 
              using b(2) assms(3) apply blast  
              using \<open>fst (add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (add (x, y) (\<tau> (x', y'))) = 0 \<Longrightarrow> \<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)\<close> b(2) e_circ_def assms(3) z3(1) z3(2) by blast 
            then have 1: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} =
                       gluing `` {(\<tau> (add (x,y) (\<tau> (x',y'))),l+l')}"
              using gluing_inv closure_lem by force
            also have "... = gluing `` {(ext_add (x,y) (x',y'),l+l')}"
              using  add_ext_add cc(1) cc(2) curve_addition.commutativity ext_add_comm z3(1) z3(2) 
              using inversion_invariance_1 by presburger
            finally have gl_eq: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} = 
                                 gluing `` {(ext_add (x,y) (x',y'),l+l')}" by blast
             have "{((x, y), l)} // gluing = {{((x, y), l)}}"
               using eq_class_simp[OF assms(5)] assms(1) by simp 
            then have ext_to_add: "False" 
              using gluing_class[OF z3 \<open>(x,y) \<in> e_aff\<close>] singleton_quotient
              by (simp add: singleton_quotient)  
            then show ?thesis by blast
          next
            case bbb
            have "{((x, y), l)}  // gluing = {{((x, y), l)} }"
              using eq_class_simp[OF assms(5)] assms(1) by simp 
            from this bbb have aaa_simp:
              "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
               Some (ext_add (x, y) (\<tau> (x', y')), l+l'+1)" 
              apply(simp add: proj_add.simps del: ext_add.simps \<tau>.simps,safe) 
              using gluing_class[OF z3 \<open>(x,y) \<in> e_aff\<close>] eq_class_simp[OF assms(5)] assms(1) 
              by (simp add: singleton_quotient)   
            have "x' \<noteq> 0" "y' \<noteq> 0" 
             using bbb b using cc(1,2) by blast+
            have add_aff: "add (x,y) (x',y') \<in> e_aff"
              using bbb b cc unfolding p_delta'_def delta'_def delta_x_def delta_y_def 
                                       e_aff_def e'_def e_aff_0_def delta_def delta_plus_def 
                                       delta_minus_def
              apply(simp add: divide_simps t_nz cc)
              apply(simp add: c_eq_1 t_expr) by algebra
            have nz_add: "fst (add (x,y) (x',y')) \<noteq> 0" "snd (add (x,y) (x',y')) \<noteq> 0"
              using bbb b cc unfolding p_delta'_def delta'_def delta_x_def delta_y_def 
                                       e_aff_def e'_def e_aff_0_def delta_def delta_plus_def 
                                       delta_minus_def
              apply(auto simp add: divide_simps t_nz cc)
              by(auto simp add: c_eq_1 t_expr)
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                           {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1)}) =
                           {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1)} "
              using aaa_simp v1 by auto
            then have proj_eq: "{the (proj_add ((x, y), l) ((x', y'), l')),
                                 the (proj_add ((x, y), l) (\<tau> (x', y'), l' + 1))} =
                       {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1), (add (x, y) (x', y'), l + l')}"
              using aaa_simp v1 by auto          
            have "gluing `` {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)} =
                  gluing `` {(add (x, y) (x', y'), l + l')}" 
              using \<open>{((x, y), l)} // gluing = {{((x, y), l)}}\<close> gluing_class[OF z3 assms(3)] 
              by (simp add: singleton_quotient)            
            then show ?thesis
              unfolding assms(1,2) proj_add_class_def apply(simp add: dom_eq proj_eq del: add.simps \<tau>.simps ext_add.simps)
              using add_aff nz_add 
              using assms(1,3,5) e_proj_elim_1 z3(1) z3(2) by blast
          next
            case ccc
            from ccc have aaa_simp:
              "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = None"
              by(simp add: proj_add.simps assms(3),blast)
            then have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                {(((x, y), l), (x', y'), l'),(((x, y), l), \<tau> (x', y'), l' + 1)}) = 
                {(((x, y), l),((x', y'), l'))}" 
            using v1 by auto
            then show ?thesis 
              unfolding assms(1,2) proj_add_class_def 
              apply(simp add: dom_eq del: \<tau>.simps) 
              using assms(1,3,5) e_proj_elim_1 z3(1,2) by blast
          qed
        qed
      qed       
      next
        case c
        then have ld_nz: "delta' x y x' y' \<noteq> 0" 
          unfolding e_aff_1_def by auto    
        consider 
          (aa) "x' = 0" |
          (bb) "y' = 0" |
          (cc) "x' \<noteq> 0" "y' \<noteq> 0" by blast
        then show ?thesis
        proof(cases)
          case aa
          have y_expr: "y' = 1 \<or> y' = -1"
            using e_aff_x0[OF aa \<open>(x',y') \<in> e_aff\<close>] by simp
          have "delta x y x' y' \<noteq> 0" 
            unfolding delta_def delta_plus_def delta_minus_def
            using aa by simp
          have d_0_nz: "delta x y 0 y' \<noteq> 0" 
            unfolding delta_def delta_plus_def delta_minus_def by auto
          have "(0, 1 / (t * y')) \<notin> e_aff"
            using \<open>(x',y') \<in> e_aff\<close> aa unfolding e_aff_def e'_def 
            apply(simp add: divide_simps t_sq_n1 t_nz,safe)
            by (simp add: power_mult_distrib t_sq_n1)
          have v1: "proj_add ((x, y), l) ((0, y'), l') = Some ((- (c * y * y'), x * y'), l + l')"
            apply(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> p_delta_def d_0_nz)
            using c aa unfolding e_aff_1_def by blast
          have v2: "proj_add ((x, y), l) (\<tau> (0, y'), l' + 1) = None"
            apply(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> p_delta_def d_0_nz)
            by(simp add: \<open>(0, 1 / (t * y')) \<notin> e_aff\<close>)
          have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                  {(((x, y), l), (0, y'), l'),
                   (((x, y), l), \<tau> (0, y'), l' + 1)}) = 
                {(((x, y), l), (0, y'), l')}" 
            using v1 v2 by auto
          show ?thesis 
            unfolding assms(1,2) apply(simp add: aa t_nz del: \<tau>.simps)
            unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
            using aa assms(2,4,6) e_proj_elim_2 by blast
        next
          case bb
          have x_expr: "x' = 1 \<or> x' = -1"
            using e_aff_y0[OF bb \<open>(x',y') \<in> e_aff\<close>] by simp
          have "delta x y x' y' \<noteq> 0" 
            unfolding delta_def delta_plus_def delta_minus_def
            using bb by simp
          have d_0_nz: "delta x y x' 0 \<noteq> 0" 
            unfolding delta_def delta_plus_def delta_minus_def by auto
          have "(1 / (t * x'),0) \<notin> e_aff"
            unfolding e_aff_def e'_def 
            using \<open>(x',y') \<in> e_aff\<close> bb unfolding e_aff_def e'_def 
            apply(simp add: divide_simps t_sq_n1 t_nz,safe)
            by (simp add: power_mult_distrib t_sq_n1)
          have v1: "proj_add ((x, y), l) ((x', 0), l') = Some ((x * x', y * x'), l + l')"
            apply(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> p_delta_def d_0_nz)
            using c bb unfolding e_aff_1_def by simp
          have v2: "proj_add ((x, y), l) (\<tau> (x', 0), l' + 1) = None"
            apply(simp add: proj_add.simps \<open>(x,y) \<in> e_aff\<close> p_delta_def d_0_nz)
            by(simp add: \<open>(1 / (t * x'),0) \<notin> e_aff\<close>)
          have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                  {(((x, y), l), (x', 0), l'),
                   (((x, y), l), \<tau> (x', 0), l' + 1)}) = 
                {(((x, y), l), (x', 0), l')}" 
            using v1 v2 by auto
          show ?thesis 
            unfolding assms(1,2) apply(simp add: bb t_nz del: \<tau>.simps)
            unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
            using assms(2,4,6) bb e_proj_elim_2 by blast
        next
          case cc    
          have "delta x y x' y' = 0" 
            using \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> c
            unfolding e_aff_0_def by force
          have "(x',y') \<in> e_circ"
            unfolding e_circ_def using cc \<open>(x',y') \<in> e_aff\<close> by blast
          then have "\<tau> (x', y') \<in> e_circ" 
            using cc \<tau>_circ by blast
          then have "\<tau> (x', y') \<in> e_aff"
            unfolding e_circ_def by force
          have v1: "proj_add ((x, y), l) ((x', y'), l') = Some (ext_add (x, y) (x', y'), l + l')"
            by(simp add: proj_add.simps p_delta'_def p_delta_def \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> ld_nz \<open>delta x y x' y' = 0\<close>) 
            
          consider 
            (z1) "x = 0" |
            (z2) "y = 0" |
            (z3) "x \<noteq> 0" "y \<noteq> 0" by blast
          then show ?thesis
          proof(cases)
            case z1
            then have y_expr: "y = 1 \<or> y = -1"
              using \<open>(x,y) \<in> e_aff\<close> unfolding e_aff_def e'_def 
              by(simp,algebra)
            then have "y*y = 1" by auto
            have "ext_add (x, y) (x', y') = \<rho> (y*x',y*y')"
              by(simp add: z1 cc divide_simps y_expr \<open>y*y = 1\<close>)
            then have v1_def: "proj_add ((x, y), l) ((x', y'), l') = 
                               Some (\<rho> (y*x',y*y'), l + l')"
              using v1 by(simp)
            have "delta x y (fst (\<tau> (x',y'))) (snd (\<tau> (x',y'))) \<noteq> 0"
              unfolding delta_def delta_plus_def delta_minus_def
              using z1 by simp
            then have v2: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
                       Some (ext_add (x, y) (\<tau> (x', y')), l+l'+1)"
              using \<open>delta x y x' y' = 0\<close> delta_def delta_minus_def delta_plus_def z1 by auto
            have "ext_add (x, y) (\<tau> (x', y')) = \<rho> (y*(fst (\<tau> (x', y'))),y*(snd (\<tau> (x', y'))))"
              by(simp add: z1 cc t_nz divide_simps \<open>y*y = 1\<close>)
            then have "ext_add (x, y) (\<tau> (x', y')) = (\<rho> \<circ> \<tau>) (y*x',y*y')"
              apply(simp)
              apply(rule conjI)
              by(simp add: divide_simps t_nz cc y_expr \<open>y*y = 1\<close>)+
            then have v2_def: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) =
                          Some (\<tau> (\<rho> (y*x',y*y')), l+l'+1)"
              using v2 rot_tau_com rotations_def by auto
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                  {(((0, y), l), (x', y'), l'),
                   (((0, y), l), \<tau> (x', y'), l' + 1)}) = 
                {(((0, y), l), (x', y'), l'), (((0, y), l), \<tau> (x', y'), l' + 1)}" 
              using v1_def v2_def z1 by auto
            have rho_aff: "\<rho> (y * x', y * y') \<in> e_aff"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> unfolding e_aff_def e'_def
                apply(cases "y = 1")
                apply(simp add: z1,argo) 
                using y_expr by(simp add: z1,argo) 
            have eq: "{(\<rho> (y * x', y * y'), l + l'), (\<tau> (\<rho> (y * x', y * y')), l + l' + 1)}
                      = gluing `` {(\<rho> (y * x', y * y'), l + l')}"
            proof -
              have coord: "fst (\<rho> (y * x', y * y')) \<noteq> 0" "snd (\<rho> (y * x', y * y')) \<noteq> 0" 
                using y_expr cc by auto
              show ?thesis
                using gluing_class[OF coord(1) coord(2)] rho_aff by simp
            qed
            show ?thesis
              unfolding assms(1,2) apply(simp add: t_nz z1 del: \<tau>.simps)
              unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
              apply(subst z1[symmetric])+
              apply(subst v1_def,subst v2_def,simp del: \<tau>.simps \<rho>.simps)
              apply(subst eq)
              using e_points eq_class_image rho_aff by auto
          next
            case z2
            then have x_expr: "x = 1 \<or> x = -1"
              using \<open>(x,y) \<in> e_aff\<close> unfolding e_aff_def e'_def 
              by(simp,algebra)
            then have "x*x = 1" by auto
            have "add (x, y) (x', y') = (x*x',x*y')"
              by(simp add: z2)
            then have v1_def: "proj_add ((x, y), l) ((x', y'), l') = 
                               Some ((x*x',x*y'), l + l')"
              using \<open>delta x y x' y' = 0\<close> delta_def delta_minus_def delta_plus_def z2 by auto
            have "delta x y (fst (\<tau> (x',y'))) (snd (\<tau> (x',y'))) \<noteq> 0"
              unfolding delta_def delta_plus_def delta_minus_def
              using z2 by simp
            then have v2: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
                       Some (add (x, y) (\<tau> (x', y')), l+l'+1)"
              using proj_add.simps p_delta_def 
              using \<open>\<tau> (x', y') \<in> e_aff\<close> assms(3) by auto 
            have "add (x, y) (\<tau> (x', y')) = (x*(fst (\<tau> (x', y'))),x*(snd (\<tau> (x', y'))))"
              by(simp add: z2)
            then have "add (x, y) (\<tau> (x', y')) = \<tau> (x*x',x*y')"
              apply(simp)
              apply(rule conjI)
              by(simp add: divide_simps t_nz cc x_expr \<open>x*x = 1\<close>)+
            then have v2_def: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) =
                          Some (\<tau> (x*x',x*y'), l+l'+1)"
              using v2 rot_tau_com rotations_def by auto
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                  {(((x, 0), l), (x', y'), l'),
                   (((x, 0), l), \<tau> (x', y'), l' + 1)}) = 
                {(((x, 0), l), (x', y'), l'), (((x, 0), l), \<tau> (x', y'), l' + 1)}" 
              using v1_def v2_def z2 by auto
            have rho_aff: "(x * x', x * y') \<in> e_aff"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> unfolding e_aff_def e'_def
                apply(cases "x = 1")
                apply(simp)
                using x_expr by(simp add: z2)
            have eq: "{((x * x', x * y'), l + l'), (\<tau> (x * x', x * y'), l + l' + 1)}
                      = gluing `` {((x * x', x * y'), l + l')}"
            proof -
              have coord: "fst ((x * x', x * y')) \<noteq> 0" "snd ((x * x', x * y')) \<noteq> 0" 
                using x_expr cc by auto
              show ?thesis
                using gluing_class[OF coord(1) coord(2)] rho_aff by simp
            qed
            show ?thesis
              unfolding assms(1,2) apply(simp add: t_nz z2 del: \<tau>.simps)
              unfolding proj_add_class_def apply(simp add: dom_eq del: \<tau>.simps)
              apply(subst z2[symmetric])+
              apply(subst v1_def,subst v2_def,simp del: \<tau>.simps \<rho>.simps)
              apply(subst eq) 
              by (simp add: e_points eq_class_image rho_aff)
          next
            case z3    
            consider
            (aaa) "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l)\<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff" |
            (bbb) "p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<and> fst ((x, y), l) \<in> e_aff \<and> fst (\<tau> (x', y'), l' + 1) \<in> e_aff" |
            (ccc) "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<and> p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0
                   \<or> fst ((x, y), l) \<notin> e_aff \<or> fst (\<tau> (x', y'), l' + 1) \<notin> e_aff" 
              by(simp add: proj_add.simps,blast) 
          then show ?thesis 
          proof(cases)
            case aaa            
            from aaa have aaa_simp: 
              "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
               Some (add (x, y) (\<tau> (x', y')), l+l'+1)" 
              using proj_add.simps by simp
            have "x' * y' \<noteq> - x * y" 
              using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
              apply(simp add: t_nz cc divide_simps)
              apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1) d_nz)
              by(simp add: ring_distribs(1)[symmetric] d_nz)               
            have "x' * y' \<noteq> x * y"
              using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
              apply(simp add: t_nz cc divide_simps)
              by(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1))

            have closure_lem: "add (x, y) (\<tau> (x', y')) \<in> e_aff"
            proof -
              obtain x1 y1 where z2_d: "\<tau> (x', y') = (x1,y1)" by fastforce
              define z3 where "z3 = add (x,y) (x1,y1)"
              obtain x2 y2 where z3_d: "z3 = (x2,y2)" by fastforce
              have "delta x y x1 y1 \<noteq> 0"
                using aaa z2_d unfolding p_delta_def by auto
              then have dpm: "delta_minus x y x1 y1 \<noteq> 0" "delta_plus x y x1 y1 \<noteq> 0"
                unfolding delta_def by auto
              have "(x1,y1) \<in> e_aff"
                unfolding z2_d[symmetric]
                using \<open>\<tau> (x', y') \<in> e_aff\<close> by auto
              have e_eq: "e x y = 0" "e x1 y1 = 0"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x1,y1) \<in> e_aff\<close> e_e'_iff  unfolding e_aff_def by(auto)
                
              have "e x2 y2 = 0" 
                using add_closure[OF z3_d z3_def dpm ] 
                using add_closure[OF z3_d z3_def dpm e_eq] by simp
              then show ?thesis 
                unfolding e_aff_def using e_e'_iff z3_d z3_def z2_d by simp
            qed      
                         
            have add_nz: 
              "fst (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              "snd (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              using b_cc_case[OF closure_lem assms(3) \<open>\<tau> (x', y') \<in> e_aff\<close> \<open>\<tau> (x', y') \<in> e_circ\<close> cc
                               \<open>x' * y' \<noteq> - x * y\<close> \<open>x' * y' \<noteq> x * y\<close> c(2)]  e_circ_def z3(1) z3(2) 
              using c(2) assms(3) apply blast  
              using \<open>fst (add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (add (x, y) (\<tau> (x', y'))) = 0 \<Longrightarrow> \<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)\<close> c(2) e_circ_def assms(3) z3(1) z3(2) by blast 
            then have 1: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} =
                       gluing `` {(\<tau> (add (x,y) (\<tau> (x',y'))),l+l')}"
              using gluing_inv closure_lem by force
            also have "... = gluing `` {(ext_add (x,y) (x',y'),l+l')}"
              using add_ext_add cc(1) cc(2)  z3(1) z3(2)  inversion_invariance_1 by presburger
            finally have gl_eq: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} = 
                                 gluing `` {(ext_add (x,y) (x',y'),l+l')}" by blast
             have "{((x, y), l)} // gluing = {{((x, y), l)}}"
              using eq_class_simp[OF assms(5)] by(simp add: assms(1))
            then have ext_to_add: "(ext_add (x,y) (x',y'),l+l') = (add (x,y) (x',y'),l+l')" 
              using gluing_class[OF z3 \<open>(x,y) \<in> e_aff\<close>] 
              by (simp add: singleton_quotient)  
            then have def_gl_eq: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} = 
                                  gluing `` {(ext_add (x,y) (x',y'),l+l')}"
              using ext_to_add gl_eq by argo
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                           {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1)}) =
                           {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1)} "
              using aaa_simp v1 by auto
            then have proj_eq: "{the (proj_add ((x, y), l) ((x', y'), l')),
                                 the (proj_add ((x, y), l) (\<tau> (x', y'), l' + 1))} =
                       {(add (x, y) (\<tau> (x', y')), l + l' + 1), (ext_add (x, y) (x', y'), l + l')}"
              using aaa_simp v1 by auto          
            show ?thesis
              unfolding assms(1,2) proj_add_class_def apply(simp add: dom_eq proj_eq del: add.simps \<tau>.simps ext_add.simps)
              unfolding quotient_def using def_gl_eq 
              using assms(1,3,5) e_proj_elim_1 z3(1) z3(2) by blast
          next
            case bbb
            have "{((x, y), l)}  // gluing = {{((x, y), l)} }"
              using eq_class_simp[OF assms(5)] by (simp add: assms(1))
            from this bbb have aaa_simp:
              "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = 
               Some (ext_add (x, y) (\<tau> (x', y')), l+l'+1)" 
              apply(simp add: proj_add.simps del: ext_add.simps \<tau>.simps,safe) 
              using gluing_class[OF z3 \<open>(x,y) \<in> e_aff\<close>] 
              by (metis (no_types, lifting) assms(1) add_cancel_right_right doubleton_eq_iff insert_absorb2 singleton_quotient snd_conv zero_neq_one)
            have closure_lem: "ext_add (x, y) (\<tau> (x', y')) \<in> e_aff"
            proof -
              obtain x1 y1 where z2_d: "\<tau> (x', y') = (x1,y1)" by fastforce
              define z3 where "z3 = ext_add (x,y) (x1,y1)"
              obtain x2 y2 where z3_d: "z3 = (x2,y2)" by fastforce
              have d': "delta' x y x1 y1 \<noteq> 0"
                using bbb z2_d unfolding p_delta'_def by auto
              have "(x1,y1) \<in> e_aff"
                unfolding z2_d[symmetric]
                using \<open>\<tau> (x', y') \<in> e_aff\<close> by auto
              have e_eq: "e' x y = 0" "e' x1 y1 = 0"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x1,y1) \<in> e_aff\<close> unfolding e_aff_def by(auto)
                
              have "e' x2 y2 = 0" 
                using z3_d z3_def ext_add_closure[OF d' e_eq, of x2 y2] by blast
              then show ?thesis 
                unfolding e_aff_def using e_e'_iff z3_d z3_def z2_d by simp
            qed      
            
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                           {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1)}) =
                           {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1)} "
              using aaa_simp v1 by auto
            then have proj_eq: "{the (proj_add ((x, y), l) ((x', y'), l')),
                                 the (proj_add ((x, y), l) (\<tau> (x', y'), l' + 1))} =
                       {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1), (ext_add (x, y) (x', y'), l + l')}"
              using aaa_simp v1 by auto          
            have "gluing `` {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)} =
                  gluing `` {(ext_add (x, y) (x', y'), l + l')}" 
              using \<open>{((x, y), l)} // gluing = {{((x, y), l)}}\<close> gluing_class[OF z3 assms(3)] 
              by (simp add: singleton_quotient)            
            then show ?thesis
              unfolding assms(1,2) proj_add_class_def apply(simp add: dom_eq proj_eq del: add.simps \<tau>.simps ext_add.simps)
              using assms(1,3,5) e_proj_elim_1 z3(1) z3(2) by auto
          next
            case ccc
            from ccc have aaa_simp:
              "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = None"
              by(simp add: proj_add.simps assms(3),blast)
            then have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                {(((x, y), l), (x', y'), l'),(((x, y), l), \<tau> (x', y'), l' + 1)}) = 
                {(((x, y), l),((x', y'), l'))}" 
            using v1 by auto
            then show ?thesis 
              unfolding assms(1,2) proj_add_class_def 
              apply(simp add: dom_eq del: \<tau>.simps)
              using assms(1,3,5) e_proj_elim_1 z3(1,2) by blast
          qed
        qed
      qed    
    qed        
  qed

lemma hard_eq_1:
  fixes ga
  assumes a1: "x * y + x' * y' = 0"
  assumes a2: "x'\<^sup>2 + y'\<^sup>2 = 1 + d * (x' * (x' * y'\<^sup>2))"
  assumes a3: "d * (x * (x' * (y * y'))) = 1"
  shows "False"
proof -
  have "1 - d * (x' * (x' * (y' * - y'))) = x' * x' - y' * - y'"
    using a2 by (simp add: semiring_normalization_rules(29))
  then have "x' * x' - y' * - y' = 0"
    using a3 a1 by (metis diff_minus_eq_add mult.commute mult.left_commute mult_minus_right right_minus_eq)
  then show "False"
    using a3 by simp
qed

lemma hard_eq_2:
  assumes 0: "x \<noteq> 0" "y \<noteq> 0" "x' \<noteq> 0" "y' \<noteq> 0" "d \<noteq> 1" "d \<noteq> 0"
  assumes 1:  "d * x'\<^sup>2 + d * y'\<^sup>2 = d + x' * (x' * (y' * (y' * d\<^sup>2)))"
          "d * x'\<^sup>2 + d * y'\<^sup>2 = d + x' * (x' * (y' * (y' * d\<^sup>2)))"
          "d * x\<^sup>2 + d * y\<^sup>2 = d + x * (x * (y * (y * d\<^sup>2)))"
  assumes 2: "x'\<^sup>2 + y'\<^sup>2 = 1 + d * (x' * (x' * y'\<^sup>2))"
          "x\<^sup>2 + y\<^sup>2 = 1 + d * (x * (x * y\<^sup>2))"
  assumes 3: "x * y + x' * y' = 0" "x * y' + x' * y = 0"
          "d * (x * (x' * (y * y'))) = - 1"
  assumes 4: "x' * y - x * y' = 0 \<or> x * x' + y * y' = 0"
  shows "False" (* try to find the condition as in the hard_eq_3 *)
proof -
  have y_or: "y' = y \<or> y' = -y"
    using 3(1-2) 0 by algebra
  then consider (1) "y' = y" | (2) "y' = -y" by blast
  then have eq: "x\<^sup>2 * (d * y\<^sup>2 - 1) = x'\<^sup>2 * (d * y'\<^sup>2 - 1)"
    using 2 
    by(cases,algebra,algebra) 
  have "d * y\<^sup>2 - 1 \<noteq> 0"
    using 0 2 by algebra
  then have "x\<^sup>2 = x'\<^sup>2"    
    using eq by (metis (no_types, lifting) \<open>\<And>thesis. \<lbrakk>y' = y \<Longrightarrow> thesis; y' = - y \<Longrightarrow> thesis\<rbrakk> \<Longrightarrow> thesis\<close> nonzero_mult_div_cancel_right power2_eq_iff)
  then have x_or: "x' = x \<or> x' = -x" by algebra
  have "x\<^sup>2 + y\<^sup>2 = 0 \<or> x\<^sup>2 - y\<^sup>2 = 0" "x'\<^sup>2 + y\<^sup>2 = 0 \<or> x'\<^sup>2 - y\<^sup>2 = 0"
    using 4 x_or y_or 
     apply(cases "x' * y - x * y' = 0")
    using assms(13) assms(2) assms(3) apply auto[1]
     apply algebra
    by (smt "4" \<open>\<And>thesis. \<lbrakk>y' = y \<Longrightarrow> thesis; y' = - y \<Longrightarrow> thesis\<rbrakk> \<Longrightarrow> thesis\<close> assms(10) assms(12) assms(13) assms(14) mult.commute mult_cancel_right mult_minus_left mult_minus_right semiring_normalization_rules(29))
  then have "x\<^sup>2 - y\<^sup>2 = 0" "x'\<^sup>2 - y\<^sup>2 = 0"
    using 0 by simp+
  then have "x = y \<or> x = -y" "x' = y \<or> x' = -y"
    by algebra+
  then have "y = 0" 
    using 4 2(2) x_or y_or assms(12) d_n1 assms(14) apply(simp add: power2_eq_square algebra_simps) 
    by(smt assms(13) minus_mult_minus mult_cancel_right2 mult_minus_right no_zero_divisors semiring_normalization_rules(18))
  
  then show "False" using 0 by blast
qed

lemma hard_eq_3:
  assumes 0: "x \<noteq> 0" "y \<noteq> 0" "x' \<noteq> 0" "y' \<noteq> 0" "d \<noteq> 1" "d \<noteq> 0"
  assumes 1: "d * (x' * x') + d * (y' * y') = d + d * (d * (x' * (x' * (y' * y'))))"
             "d * (x * x) + d * (y * y) = d + d * (d * (x * (x * (y * y))))"
  assumes 2: "x' * x' + y' * y' = 1 + d * (x' * (x' * (y' * y')))"
          "x * x + y * y = 1 + d * (x * (x * (y * y)))"
          "d * (x * (x * (x' * x'))) = 1"
  assumes 3: "x' * y' = x * y" "y * y' = x * x'" "x' * y = x * y'"
  shows "False"
proof -
  from 3 have "(x' = x \<and> y' = y) \<or> (x' = -x \<and> y' = -y)" using 0 by algebra+
  from this 0 1 2 3 show ?thesis by fastforce
qed

lemma proj_add_eqs_4: (* TODO: eliminate code duplication with well-defined *)
  assumes "p = {((x, y), l), (\<tau> (x, y), l + 1)}"
          "q = {((x', y'), l'), (\<tau> (x', y'), l' + 1)}"
          "p \<in> e_proj" "q \<in> e_proj"
  shows "(x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)) \<Longrightarrow>
         p_delta ((x, y), l) (\<tau> (x', y'), l'+1) \<noteq> 0 \<Longrightarrow>   
         the_elem(proj_add_class p q) = {(add (x, y) (\<tau> (x', y')), l + l' + 1)}"
        "(x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)) \<Longrightarrow>
         p_delta' ((x, y), l) (\<tau> (x', y'), l'+1) \<noteq> 0 \<Longrightarrow> p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<Longrightarrow>   
         the_elem(proj_add_class p q) = {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}"
        "(x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)) \<Longrightarrow>
         p_delta' ((x, y), l) (\<tau> (x', y'), l'+1) = 0 \<Longrightarrow> p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<Longrightarrow>   
         False"
        "((x, y), x', y') \<in> e_aff_0 \<Longrightarrow> \<not> ((\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow>
         p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<Longrightarrow>
        the_elem(proj_add_class p q) = 
                {(add (x, y) (\<tau> (x', y')), l + l' + 1), (\<tau> (add (x, y) (\<tau> (x', y'))), l + l')}"
        "((x, y), x', y') \<in> e_aff_0 \<Longrightarrow> \<not> ((\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow>
         p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<Longrightarrow> p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<Longrightarrow>
          the_elem(proj_add_class p q) = 
          {(add (x, y) (x', y'), l + l'), (ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}"
        "((x, y), x', y') \<in> e_aff_0 \<Longrightarrow> \<not> ((\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow>
         p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<Longrightarrow>
                 p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<Longrightarrow>
          the_elem(proj_add_class p q) = {(add (x, y) (x', y'), l + l')}"
        "((x, y), x', y') \<in> e_aff_1 \<Longrightarrow> \<not> ((\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow>
         ((x, y), x', y') \<notin> e_aff_0 \<Longrightarrow>
         p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<Longrightarrow>
          the_elem(proj_add_class p q) = {(ext_add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}"
        "((x, y), x', y') \<in> e_aff_1 \<Longrightarrow> \<not> ((\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow>
         ((x, y), x', y') \<notin> e_aff_0 \<Longrightarrow>
         p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0 \<Longrightarrow> p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<Longrightarrow>
          False"
        "((x, y), x', y') \<in> e_aff_1 \<Longrightarrow> \<not> ((\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))) \<Longrightarrow>
         ((x, y), x', y') \<notin> e_aff_0 \<Longrightarrow>
         p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<Longrightarrow> p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<Longrightarrow>
          the_elem(proj_add_class p q) = {(ext_add (x, y) (x', y'), l + l')}"
  
(*
          (ccc) "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<and> 
                 p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0" 
*)

proof -
  from e_proj_eq[OF assms(3)] e_proj_eq[OF assms(4)]
  have p_q_expr: "(p = {((x, y), l)} \<or> p = {((x, y), l), (\<tau> (x, y), l + 1)})" 
              "(x, y) \<in> e_aff" 
              "(q = {((x', y'), l')} \<or> q = {((x', y'), l'), (\<tau> (x', y'), l' + 1)})"
              "(x', y') \<in> e_aff" 
    using assms(1) apply blast 
    using assms(1) assms(3) e_aff_bit_def e_proj_def eq_rel in_quotient_imp_subset apply force
    using assms(2) apply blast 
    using assms(2) assms(4) e_aff_bit_def e_proj_def eq_rel in_quotient_imp_subset by force
  have nz: "x \<noteq> 0" "y \<noteq> 0" "x' \<noteq> 0" "y' \<noteq> 0" 
    using assms e_proj_elim_2 p_q_expr apply fastforce   
    using assms e_proj_elim_2 p_q_expr apply fastforce  
    using assms(2) assms(4) e_proj_elim_2 p_q_expr(3) p_q_expr(4) apply fastforce
    using assms(2) assms(4) e_proj_elim_2 p_q_expr(3) p_q_expr(4) by fastforce    
  have non_taus: "(x,y) \<in> e_aff" "(x',y') \<in> e_aff"  "(x,y) \<in> e_circ" "(x',y') \<in> e_circ" 
     by(auto simp add: p_q_expr(2,4) \<open>x \<noteq> 0\<close> \<open>y \<noteq> 0\<close> \<open>x' \<noteq> 0\<close> \<open>y' \<noteq> 0\<close> e_circ_def) 
  have taus: "(\<tau> (x', y')) \<in> e_aff" "(\<tau> (x, y)) \<in> e_aff" "\<tau> (x', y') \<in> e_circ"
    using \<open>(x', y') \<in> e_circ\<close> \<tau>_circ e_circ_def apply auto[1]        
    using \<tau>_circ e_circ_def non_taus(3) apply auto[1]
    using \<tau>_circ non_taus(4) by blast

  {assume a: "(x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))"
  then obtain g where sym_expr: "g \<in> symmetries" "(x', y') = (g \<circ> i) (x, y)" by auto        
  then have ds: "delta x y x' y' = 0" "delta' x y x' y' = 0"
    using wd_d_nz wd_d'_nz a by auto 
  then have one_none: "proj_add ((x, y), l) ((x', y'), l') = None"
    using proj_add.simps unfolding p_delta_def p_delta'_def by auto   
  have ds': "p_delta (\<tau> (x, y), l) (\<tau> (x', y'), l'+1) = 0" 
            "p_delta' (\<tau> (x, y), l) (\<tau> (x', y'), l'+1) = 0" 
    unfolding p_delta_def using ds apply(simp del: \<tau>.simps)
    unfolding delta_def delta_plus_def delta_minus_def
    apply(simp add: t_nz nz algebra_simps power2_eq_square[symmetric] t_expr(1) d_nz power_one_over) 
    unfolding p_delta'_def using ds apply(simp del: \<tau>.simps)
    unfolding delta'_def delta_x_def delta_y_def
    by(simp add: t_nz nz divide_simps power2_eq_square[symmetric] t_expr,argo)           
    then have one_none': "proj_add (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) = None"
      using proj_add.simps unfolding p_delta_def p_delta'_def by auto   

    {assume ex_eq: "proj_add ((x, y), l) (\<tau> (x', y'), l'+1) = 
            proj_add (\<tau> (x, y), l+1) ((x', y'), l')"
    have dom_ne: "(dom (\<lambda>(x, y). proj_add x y) \<inter> {((x, y), l), (\<tau> (x, y), l + 1)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}) \<noteq> {}"
      using covering[OF assms(3,4)] unfolding assms proj_add_class_def by blast
    have out_list: "(((x, y), l),((x', y'), l')) \<notin> (dom (\<lambda>(x, y). proj_add x y))"
                  "((\<tau> (x, y), l+1),(\<tau> (x', y'), l'+1)) \<notin> (dom (\<lambda>(x, y). proj_add x y))"
      using one_none one_none' unfolding dom_def by fastforce+
    have in_list: "(((x, y), l), \<tau> (x', y'), l' + 1) \<in> dom (\<lambda>(x, y). proj_add x y)"
         "((\<tau> (x, y), l + 1), (x', y'), l') \<in> dom (\<lambda>(x, y). proj_add x y)"
      using dom_ne out_list ex_eq by(fastforce)+ 
    have dom_eq: 
      "(dom (\<lambda>(x, y). proj_add x y) \<inter> 
        {((x, y), l), (\<tau> (x, y), l + 1)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}
       = {(((x, y), l),(\<tau> (x', y'), l'+1)),((\<tau> (x, y), l+1),((x', y'), l'))})" 
      using in_list out_list by simp
    have "proj_add_class p q \<noteq> {}" 
      by (simp add: assms(3) assms(4) covering)
    then have add_eq: "((\<lambda>(x, y). the (proj_add x y)) `
           {(((x, y), l), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l')} ) = 
         {the (proj_add ((x, y), l) (\<tau> (x', y'), l' + 1))}" 
      using ex_eq unfolding proj_add_class_def assms by auto
    then obtain v where "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some v"
      using in_list(1) by auto
    have "the_elem (proj_add_class p q) = the_elem ({the (proj_add ((x, y), l) (\<tau> (x', y'), l' + 1))} // gluing)"
      unfolding proj_add_class_def assms
      by(subst dom_eq, subst add_eq,argo) 
  }
  note simp_proj_class = this
  {assume 1: "p_delta ((x, y), l) (\<tau> (x', y'), l'+1) \<noteq> 0"
  then have pd': "p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) \<noteq> 0"
    unfolding p_delta_def delta_def delta_plus_def delta_minus_def
    by(simp add: t_nz nz field_simps power2_eq_square[symmetric] t_expr d_nz)
  from 1 have proj_eq: "proj_add ((x, y), l) (\<tau> (x', y'), l'+1) = Some(add (x, y) (\<tau> (x', y')), l+l'+1)"   
    using proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x', y')) \<in> e_aff\<close> by auto
  have "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = Some(add (\<tau> (x, y)) (x', y'), l+l'+1)"
    using proj_add.simps pd' \<open>(\<tau> (x, y)) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> by (simp add: p_delta_def)
  then have "proj_add ((x, y), l) (\<tau> (x', y'), l'+1) = proj_add (\<tau> (x, y), l+1) ((x', y'), l')"
    using \<open>proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some (add (x, y) (\<tau> (x', y')), l + l' + 1)\<close> inversion_invariance_1 nz by auto
  then have elem_eq: "the_elem (proj_add_class p q) = the_elem ({the (proj_add ((x, y), l) (\<tau> (x', y'), l' + 1))} // gluing)" 
    using simp_proj_class by simp       
  have "\<tau> (add (x, y) (\<tau> (x', y'))) = ext_add (x, y) (x', y')"
    using add_ext_add ext_add_comm nz(1-4) 
    using inversion_invariance_1 by presburger
  have eq: "x' * y' \<noteq> x * y"  
    using a 1 unfolding e_circ_def e_aff_def e'_def p_delta_def delta_def
                          delta_plus_def delta_minus_def
    apply(simp_all add: nz t_nz algebra_simps)
    apply(simp_all add: power2_eq_square[symmetric] t_expr d_nz) 
    apply(simp_all add: power2_eq_square) by algebra

  have "fst (add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (add (x, y) (\<tau> (x', y'))) = 0" 
    apply(simp add: t_nz nz)
    apply(simp add: c_eq_1 divide_simps t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz eq)
    using delta'_def delta_x_def delta_y_def ds(2) by auto
  have "add (x, y) (\<tau> (x', y')) \<in> e_aff"
  proof -
    have ds: "delta_plus x y (fst (\<tau> (x', y'))) (snd (\<tau> (x', y'))) \<noteq> 0"
         "delta_minus x y (fst (\<tau> (x', y'))) (snd (\<tau> (x', y'))) \<noteq> 0"
      using "1" delta_def p_delta_def by auto
    have "e x y = 0" "e (fst (\<tau> (x', y'))) (snd (\<tau> (x', y'))) = 0"
      using e_e'_iff p_q_expr(2) e_aff_def apply blast
      using e_e'_iff taus(1) e_aff_def by fastforce
    then show ?thesis
      unfolding e_aff_def using e_e'_iff apply(simp del: \<tau>.simps add.simps)
      using ds add_closure[of _ _ _ x y "fst (\<tau> (x', y'))" "snd (\<tau> (x', y'))"] by auto
  qed
  have "gluing `` {(add (x, y) (\<tau> (x', y')), l + l' + 1)}  =
        {(add (x, y) (\<tau> (x', y')), l + l' + 1)}"
    by (metis \<open>add (x, y) (\<tau> (x', y')) \<in> e_aff\<close> \<open>fst (add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (add (x, y) (\<tau> (x', y'))) = 0\<close> e_proj_elim_1 eq_class_simp insert_not_empty prod.collapse singleton_quotient the_elem_eq)
  then show "the_elem(proj_add_class p q) = {(add (x, y) (\<tau> (x', y')), l + l' + 1)}"
    unfolding elem_eq proj_eq by (simp add: singleton_quotient)}

  {assume 2: "p_delta' ((x, y), l) (\<tau> (x', y'), l'+1) \<noteq> 0" "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0"
  then have pd': "p_delta' (\<tau> (x, y), l) ((x', y'), l' + 1) \<noteq> 0"
    unfolding p_delta'_def delta'_def delta_x_def delta_y_def
    by(simp add: t_nz nz field_simps power2_eq_square[symmetric] t_expr d_nz)
  from 2 have "p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) = 0" 
    unfolding p_delta_def delta_def delta_plus_def delta_minus_def
    by(simp add: t_nz nz field_simps power2_eq_square[symmetric] t_expr d_nz)
  from this 2 have proj_eq: "proj_add ((x, y), l) (\<tau> (x', y'), l'+1) = 
             Some(ext_add (x, y) (\<tau> (x', y')), l+l'+1)"   
    using proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x', y')) \<in> e_aff\<close> by simp
  have "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = 
        Some(ext_add (\<tau> (x, y)) (x', y'), l+l'+1)"
    using proj_add.simps pd' \<open>(\<tau> (x, y)) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close>
    using \<open>p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) = 0\<close> p_delta'_def p_delta_def by auto
  then have "proj_add ((x, y), l) (\<tau> (x', y'), l'+1) = proj_add (\<tau> (x, y), l+1) ((x', y'), l')"
    using \<open>proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some (ext_add (x, y) (\<tau> (x', y')), l + l' + 1)\<close> inversion_invariance_2 nz(1-4) by presburger
  then have elem_eq: "the_elem (proj_add_class p q) = the_elem ({the (proj_add ((x, y), l) (\<tau> (x', y'), l' + 1))} // gluing)"
    using simp_proj_class by argo
  
  from sym_expr obtain r where rot_expr: "\<tau> (x',y') = (r \<circ> i) (x,y)" "r \<in> rotations"
    unfolding symmetries_def rotations_def apply(simp)
    by (smt comp_apply id_comp tau_idemp)
  then consider (1) "r = id" | (2) "r = \<rho>" | (3) "r = \<rho> \<circ> \<rho>" | (4) "r = \<rho> \<circ> \<rho> \<circ> \<rho>" 
    unfolding rotations_def by fast
  from this rot_expr have "delta x y x' y' = 0"
  proof(cases)
    case 1
      have eq: "x * (x' * t) = 1" "y * (y' * t) = - 1"
        using rot_expr 1 unfolding rotations_def apply(simp_all del: \<tau>.simps)
        by(simp_all add: divide_simps t_nz nz algebra_simps)
      then have "d * x * x' = t" "d * y * y' = - t"
      proof -
        have "d * x * x' = t * (x * (x' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
        also have "... = t" using eq by fastforce
        finally show "d * x * x' = t" by blast
        have "d * y * y' = t * (y * (y' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
        also have "... = -t" using eq by force
        finally show "d * y * y' = -t" by blast
      qed 
      then have "d * x * x' * y * y' = -1"  
        by (simp add: eq(2) mult.commute mult.left_commute)            
      then show ?thesis 
        unfolding delta_def delta_plus_def delta_minus_def by algebra
  next
    case 2
      have eq: "x' * (y * t) = 1" "x * (y' * t) = 1"
        using rot_expr 2 unfolding rotations_def apply(simp_all del: \<tau>.simps)
        by(simp_all add: divide_simps t_nz nz algebra_simps) 
      then have "d * x' * y = t" "d * x * y' = t"
      proof -
        have "d * x' * y = t * (x' * (y * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
        also have "... = t" using eq by fastforce
        finally show "d * x' * y = t" by blast
        have "d * x * y' = t * (x * (y' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
        also have "... = t" using eq by force
        finally show "d * x * y' = t" by blast
      qed 
      then have "d * x * x' * y * y' = 1"  
        by (metis eq(1) mult.commute mult.left_commute)            
      then show ?thesis 
        unfolding delta_def delta_plus_def delta_minus_def by algebra
  next
    case 3
      have eq: "x * (x' * t) = -1" "y * (y' * t) = 1"
        using rot_expr 3 unfolding rotations_def apply(simp_all del: \<tau>.simps)
        by(simp_all add: divide_simps t_nz nz algebra_simps) 
      then have "d * x * x' = -t" "d * y * y' = t"
      proof -
        have "d * x * x' = t * (x * (x' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
        also have "... = -t" using eq by fastforce
        finally show "d * x * x' = -t" by blast
        have "d * y * y' = t * (y * (y' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
        also have "... = t" using eq by force
        finally show "d * y * y' = t" by blast
      qed 
      then have "d * x * x' * y * y' = -1"  
        by (metis c_eq_1 eq(2) mult.assoc mult.commute mult_minus_left mult_minus_right)         
      then show ?thesis 
        unfolding delta_def delta_plus_def delta_minus_def by algebra
  next
    case 4
      have eq: "x' * (y * t) = -1" "x * (y' * t) = -1"
        using rot_expr 4 unfolding rotations_def apply(simp_all del: \<tau>.simps)
        by(simp_all add: divide_simps t_nz nz algebra_simps) 
      then have "d * x' * y = -t" "d * x * y' = -t"
      proof -
        have "d * x' * y = t * (x' * (y * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
        also have "... = -t" using eq by fastforce
        finally show "d * x' * y = -t" by blast
        have "d * x * y' = t * (x * (y' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
        also have "... = -t" using eq by force
        finally show "d * x * y' = -t" by blast
      qed 
      then have "d * x * x' * y * y' = 1"  
        by (metis add.inverse_inverse eq(1) mult.commute mult.left_commute mult_minus_right)        
      then show ?thesis 
        unfolding delta_def delta_plus_def delta_minus_def by algebra
    qed
       
    then have eq: "d * (x * (x' * (y * y'))) = 1 \<or> 1 + d * (x * (x' * (y * y'))) = 0"
      unfolding delta_def delta_plus_def delta_minus_def by algebra
  
    have "fst (ext_add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (ext_add (x, y) (\<tau> (x', y'))) = 0"        
      apply(simp add: t_nz nz)
      apply(simp add: c_eq_1 divide_simps t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz)
      using eq by blast
  
    have "ext_add (x, y) (\<tau> (x', y')) \<in> e_aff"
      using 2 ext_add_closure(1) \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x',y')) \<in> e_aff\<close>
      unfolding p_delta'_def e_aff_def
      apply(simp del: \<tau>.simps)
      by(fastforce)
    then have "gluing `` {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)} = {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}"
      by (metis \<open>fst (ext_add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (ext_add (x, y) (\<tau> (x', y'))) = 0\<close> e_proj_elim_1 eq_class_simp insert_not_empty prod.collapse singleton_quotient the_elem_eq)
    then show "the_elem(proj_add_class p q) = {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}"
      unfolding elem_eq 
      by (metis option.sel proj_eq singleton_quotient the_elem_eq)}
       
  {assume 3: "p_delta' ((x, y), l) (\<tau> (x', y'), l'+1) = 0"
         "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0"
    from 3 have "p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) = 0" 
      unfolding p_delta_def delta_def delta_plus_def delta_minus_def
      by(simp add: t_nz nz field_simps power2_eq_square[symmetric] t_expr d_nz)
    from 3 have pd': "p_delta' (\<tau> (x, y), l) ((x', y'), l' + 1) = 0"
      unfolding p_delta'_def delta'_def delta_x_def delta_y_def
      by(simp add: t_nz nz field_simps power2_eq_square[symmetric] t_expr d_nz)
    from 3 have proj_eq: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = None"
      by (simp add: proj_add.simps)
    have "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = proj_add (\<tau> (x, y), l + 1) ((x', y'), l')"
      using \<open>p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) = 0\<close> \<open>proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = None\<close> p_delta'_def p_delta_def pd' proj_add.simps by auto
    then have elem_eq: "the_elem (proj_add_class p q) = the_elem ({the None} // gluing)"
      using simp_proj_class proj_eq by argo
    have deltas: "delta x y x' y' = 0" "delta' x y x' y' = 0"
      apply (simp add: ds(1))
      using delta'_def delta_x_def delta_y_def ds(2) by auto
    have eq: "t^2 * x * x' * y * y' = 1 \<or> t^2 * x * x' * y * y' = -1"
                  "x' * y - x * y' = 0 \<or> x * x' + y * y' = 0"
      using deltas unfolding delta_def delta_plus_def delta_minus_def t_expr apply algebra
      using deltas unfolding delta'_def delta_x_def delta_y_def by simp
    have eq2: "x * y + x' * y' = 0 \<or> x' * y' = x * y"
              "y * y' = x * x' \<or> x * y' + x' * y = 0"
      using 3
      unfolding e_circ_def e_aff_def e'_def
                p_delta_def p_delta'_def delta_def delta'_def
                delta_plus_def delta_minus_def delta_x_def delta_y_def
       apply(simp_all add: t_nz nz divide_simps algebra_simps power2_eq_square[symmetric] t_expr d_nz)
       by algebra+
    from eq2 a eq(1) taus non_taus show "False"
      unfolding e_circ_def e_aff_def e'_def
                p_delta_def p_delta'_def delta_def delta'_def
                delta_plus_def delta_minus_def delta_x_def delta_y_def
      apply(simp add: nz t_nz divide_simps) 
      apply(simp add: power2_eq_square algebra_simps)
      apply(simp add: power2_eq_square[symmetric] t_expr algebra_simps) 
      apply(safe) 
      using hard_eq_1 apply blast
      apply (metis (no_types, hide_lams) cancel_comm_monoid_add_class.diff_cancel curve_addition.delta_plus_def delta_plus_self diff_minus_eq_add mult.left_neutral mult_minus1_right power2_minus semiring_normalization_rules(18) semiring_normalization_rules(29))
      using hard_eq_1 apply blast
      using hard_eq_2[OF nz d_n1 d_nz] eq(2) apply blast
      using eq(2) apply(simp add: algebra_simps t_expr(1) t_sq_n1 power2_eq_square nz)
      using hard_eq_3[OF nz d_n1 d_nz] apply blast
      apply (metis add_neg_numeral_special(7) c_eq_1 mult.left_commute nz(3) semiring_normalization_rules(18) semiring_normalization_rules(29) sum_squares_eq_zero_iff)
      apply (smt mult_minus_right no_zero_divisors nz(2) nz(4) zero_le_mult_iff)
      by(metis add_neg_numeral_special(7) c_eq_1 mult.left_commute nz(3) semiring_normalization_rules(18) semiring_normalization_rules(29) sum_squares_eq_zero_iff)}}

     {assume b: "((x, y), x', y') \<in> e_aff_0"
            "\<not> ((\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))"
      {
        then have ld_nz: "delta x y x' y' \<noteq> 0" 
          unfolding e_aff_0_def by auto    
        then have "p_delta (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) \<noteq> 0" 
          unfolding p_delta_def delta_def delta_plus_def delta_minus_def 
          by(simp add: t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz power_one_over)
        have v1: "proj_add ((x, y), l) ((x', y'), l') = Some (add (x, y) (x', y'), l + l')"
          using ld_nz p_delta_def proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> by simp
        have v2: "proj_add (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) = Some (add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
          using \<open>p_delta (\<tau> (x, y), l + 1) (\<tau> (x', y'), l' + 1) \<noteq> 0\<close> proj_add.simps taus(1) taus(2) by auto
        have v1_eq_v2: "Some (add (x, y) (x', y'), l + l') = Some (add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
          using inversion_invariance_1 nz tau_idemp 
          by (simp add: c_eq_1 t_nz)
        {assume aaa: "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0"    
          from aaa have v3: 
            "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some (add (x, y) (\<tau> (x', y')), l+l'+1)" 
            using proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x', y')) \<in> e_aff\<close> by simp
          have "p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) \<noteq> 0"
            using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
            apply(simp add: t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz)
            by (metis (no_types, lifting) eq_divide_eq_1 power_divide)
          then have v4: "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = Some (add (\<tau> (x, y)) (x', y'), l+l'+1)" 
            using proj_add.simps \<open>\<tau> (x,y) \<in> e_aff\<close> \<open>(x', y') \<in> e_aff\<close> p_delta_def by auto
          have v3_eq_v4: "Some (add (x, y) (\<tau> (x', y')), l+l'+1) = Some (add (\<tau> (x, y)) (x', y'), l+l'+1)" 
            using inversion_invariance_1 nz by auto
          have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
              {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
              {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}"
            using v1 v2 v3 v4 by auto
          have add_eq: "((\<lambda>(x, y). the (proj_add x y)) `
      {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
          {(add (x, y) (x', y'), l + l'),(add (x, y) (\<tau> (x', y')), l + l' + 1)}" 
            using v1 v2 v3 v4 v1_eq_v2 v3_eq_v4 by force

          have "x' * y' \<noteq> - x * y"
             using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
             apply(simp add: t_nz nz divide_simps)
             apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1) d_nz)
             by(simp add: ring_distribs(1)[symmetric] d_nz)               
          have "x' * y' \<noteq> x * y"
             using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
             apply(simp add: t_nz nz divide_simps)
             by(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1))

            have closure_lem: "add (x, y) (\<tau> (x', y')) \<in> e_aff"
            proof -
              obtain x1 y1 where z2_d: "\<tau> (x', y') = (x1,y1)" by fastforce
              define z3 where "z3 = add (x,y) (x1,y1)"
              obtain x2 y2 where z3_d: "z3 = (x2,y2)" by fastforce
              have "delta x y x1 y1 \<noteq> 0"
                using aaa z2_d unfolding p_delta_def by auto
              then have dpm: "delta_minus x y x1 y1 \<noteq> 0" "delta_plus x y x1 y1 \<noteq> 0"
                unfolding delta_def by auto
              have "(x1,y1) \<in> e_aff"
                unfolding z2_d[symmetric]
                using \<open>\<tau> (x', y') \<in> e_aff\<close> by auto
              have e_eq: "e x y = 0" "e x1 y1 = 0"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x1,y1) \<in> e_aff\<close> e_e'_iff  unfolding e_aff_def by(auto)
                
              have "e x2 y2 = 0" 
                using add_closure[OF z3_d z3_def dpm ] 
                using add_closure[OF z3_d z3_def dpm e_eq] by simp
              then show ?thesis 
                unfolding e_aff_def using e_e'_iff z3_d z3_def z2_d by simp
            qed      
                         
            have add_nz: 
              "fst (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              "snd (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              using b_cc_case[OF closure_lem \<open>(x,y) \<in> e_aff\<close> \<open>\<tau> (x',y') \<in> e_aff\<close>
                                 \<open>\<tau> (x',y') \<in> e_circ\<close> \<open>x' \<noteq> 0\<close> \<open>y' \<noteq> 0\<close>] 
              using \<open>x' * y' \<noteq> - x * y\<close> \<open>x' * y' \<noteq> x * y\<close> b(2) by blast+
            then have 1: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} =
                       gluing `` {(\<tau> (add (x,y) (\<tau> (x',y'))),l+l')}"
              using gluing_inv closure_lem by force
            also have "... = gluing `` {(ext_add (x,y) (x',y'),l+l')}"
              using  add_ext_add nz curve_addition.commutativity ext_add_comm 
              using inversion_invariance_1 by presburger
            finally have gl_eq: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} = 
                                 gluing `` {(ext_add (x,y) (x',y'),l+l')}" by blast

          have gl_class: "{(add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)} // gluing =
                  {gluing `` {(add (x, y) (\<tau> (x', y')), l + l'+1)}}"
          proof(cases "delta' x y x' y' = 0")
            case True
            then have "\<exists> v. (ext_add (x,y) (x',y')) = (v,0) \<or>
                             (ext_add (x,y) (x',y')) = (0,v)" 
              unfolding delta'_def delta_x_def delta_y_def by auto
            then have "\<exists> v. (add (x,y) (\<tau> (x',y'))) = (v,0) \<or>
                             (add (x,y) (\<tau> (x',y'))) = (0,v)"
            proof -
              show ?thesis
                by (metis (no_types) \<open>\<exists>v. ext_add (x, y) (x', y') = (v, 0) \<or> ext_add (x, y) (x', y') = (0, v)\<close> \<tau>.simps add_ext_add comp_apply division_ring_divide_zero id_apply inversion_invariance_1 mult_eq_0_iff nz(1) nz(2) nz(3) nz(4) tau_idemp)
            qed
            then show ?thesis using add_nz by force
          next
            case False
            then have "(ext_add (x,y) (x',y'),l+l') = (add (x,y) (x',y'),l+l')" 
              using coherence e_aff_def ld_nz p_q_expr(2,4) by auto
            then have "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} = 
                       gluing `` {(add (x,y) (x',y'),l+l')}" using gl_eq by argo
            have "gluing `` {(add (x, y) (x', y'), l + l')} = 
                   {(add (x,y) (x',y'),l+l'),((add (x,y) (\<tau> (x',y'))),l+l'+1)}"
              by (smt assms(2) \<open>(ext_add (x, y) (x', y'), l + l') = (add (x, y) (x', y'), l + l')\<close> add.commute add_cancel_right_left add_ext_add[OF nz] add_nz(1) add_nz(2) assms(2) bit_not_1_iff closure_lem doubleton_eq_iff gluing_class gluing_inv inversion_invariance_1[OF nz] nz(1) nz(2) nz(3) p_q_expr(4) prod.collapse)
            then show "{(add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)} // gluing =
                  {gluing `` {(add (x, y) (\<tau> (x', y')), l + l'+1)}}" 
              by (metis \<open>gluing `` {(add (x, y) (\<tau> (x', y')), l + l' + 1)} = gluing `` {(add (x, y) (x', y'), l + l')}\<close> closure_lem eq_class_image prod.collapse)
          qed
          have "gluing `` {(add (x, y) (\<tau> (x', y')), l + l' + 1)} = 
                {(add (x, y) (\<tau> (x', y')), l + l' + 1), (\<tau> (add (x, y) (\<tau> (x', y'))), l + l')}"
            using add_nz closure_lem gluing_class by auto
          then show "the_elem (proj_add_class p q) =
    {(add (x, y) (\<tau> (x', y')), l + l' + 1), (\<tau> (add (x, y) (\<tau> (x', y'))), l + l')}"
            unfolding assms proj_add_class_def 
            by(simp del: \<tau>.simps,subst dom_eq,subst add_eq,subst gl_class,simp)}
        {assume bbb: "p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0" 
                    "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0"
            from bbb have v3: 
              "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some (ext_add (x, y) (\<tau> (x', y')), l+l'+1)" 
                using proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x', y')) \<in> e_aff\<close> by simp
            have pd: "p_delta (\<tau> (x, y), l+1) ((x', y'), l') = 0"
              using bbb unfolding p_delta_def delta_def delta_plus_def delta_minus_def
                                  p_delta'_def delta'_def delta_x_def delta_y_def 
              apply(simp add: t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz)
              by (metis eq_divide_eq_1 power_divide)
            have pd': "p_delta' (\<tau> (x, y), l+1) ((x', y'), l') \<noteq> 0"
              using bbb unfolding p_delta'_def delta'_def delta_x_def delta_y_def
              by(simp add: t_nz nz divide_simps algebra_simps power2_eq_square[symmetric] t_expr d_nz)
            then have pd'': "p_delta' ((x, y), l) (\<tau> (x', y'), l'+1) \<noteq> 0"
              unfolding p_delta'_def delta'_def delta_x_def delta_y_def
              by(simp add: divide_simps t_nz nz,argo) 
            have v4: "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = Some (ext_add (\<tau> (x, y)) (x', y'), l+l'+1)"
              using proj_add.simps \<open>\<tau> (x,y) \<in> e_aff\<close> \<open>(x', y') \<in> e_aff\<close> pd pd' by simp
            have v3_eq_v4: "Some (ext_add (x, y) (\<tau> (x', y')), l+l'+1) = Some (ext_add (\<tau> (x, y)) (x', y'), l+l'+1)" 
              using inversion_invariance_2 nz by auto
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
       {((x, y), l), (\<tau> (x, y), l + 1)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)})  = 
              {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}"
              using v1 v2 v3 v4 by auto
            have add_eq: "((\<lambda>(x, y). the (proj_add x y)) `
      {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
          {(add (x, y) (x', y'), l + l'),(ext_add (x, y) (\<tau> (x', y')), l+l'+1)}"
              using v1 v2 v3 v4 v1_eq_v2 v3_eq_v4 by auto
            have trans_add: "\<tau> (add (x, y) (x', y')) = (ext_add (x, y) (\<tau> (x', y')))" 
              using add_ext_add_2 inversion_invariance_2 nz pointfree_idE by auto
            
            have closure_lem: "ext_add (x, y) (\<tau> (x', y')) \<in> e_aff"
            proof -
              obtain x1 y1 where z2_d: "\<tau> (x', y') = (x1,y1)" by fastforce
              define z3 where "z3 = ext_add (x,y) (x1,y1)"
              obtain x2 y2 where z3_d: "z3 = (x2,y2)" by fastforce
              have d': "delta' x y x1 y1 \<noteq> 0"
                using bbb z2_d unfolding p_delta'_def by auto
              have "(x1,y1) \<in> e_aff"
                unfolding z2_d[symmetric]
                using \<open>\<tau> (x', y') \<in> e_aff\<close> by auto
              have e_eq: "e' x y = 0" "e' x1 y1 = 0"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x1,y1) \<in> e_aff\<close> unfolding e_aff_def by(auto)
                
              have "e' x2 y2 = 0" 
                using z3_d z3_def ext_add_closure[OF d' e_eq, of x2 y2] by blast
              then show ?thesis 
                unfolding e_aff_def using e_e'_iff z3_d z3_def z2_d by simp
            qed     

            have eq: "x * y' + y * x' \<noteq> 0"  "y * y' \<noteq> x * x'"
              using bbb unfolding p_delta'_def delta'_def delta_x_def delta_y_def
              by(simp add: t_nz nz divide_simps)+

            have nz1: "fst(ext_add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr)
              apply(simp add: divide_simps d_nz t_nz nz)
              apply(rule conjI)
              using ld_nz unfolding delta_def delta_minus_def apply algebra
              using eq by blast
                        
            have nz2: "snd(ext_add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr)
              apply(simp add: divide_simps d_nz t_nz nz)
              apply(rule conjI)
              using ld_nz unfolding delta_def delta_plus_def apply algebra
              using eq by simp
            
            have "gluing `` {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)} \<in> e_proj"
              using e_points closure_lem by fastforce
            then have "gluing `` {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)} = {(add (x, y) (x', y'), l + l'), (ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}"
              using gluing_cases_explicit e_proj_elim_2 nz1 nz2 
              by (smt \<tau>.simps doubleton_eq_iff e_proj_eq gluing_class gluing_inv old.prod.inject pointfree_idE prod.collapse singleton_insert_inj_eq' tau_idemp trans_add)
            show "the_elem(proj_add_class p q) = {(add (x, y) (x', y'), l + l'), (ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}"
              unfolding assms proj_add_class_def
              apply(subst dom_eq,subst add_eq) 
              using \<open>gluing `` {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)} = {(add (x, y) (x', y'), l + l'), (ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}\<close> \<open>gluing `` {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)} \<in> e_proj\<close> eq_class_simp by auto}
          {assume ccc: "p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0" 
                    "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0"
        from ccc have v3: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = None"
              by(simp add: proj_add.simps)
            from ccc have "p_delta (\<tau> (x, y), l+1) ((x', y'), l') = 0 \<and> 
                           p_delta' (\<tau> (x, y), l+1) ((x', y'), l') = 0"
              unfolding p_delta_def delta_def delta_plus_def delta_minus_def
                        p_delta'_def delta'_def delta_x_def delta_y_def 
              by(simp add: t_nz nz divide_simps algebra_simps power2_eq_square[symmetric] t_expr d_nz)               
            then have v4: "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = None" 
              by(simp add: proj_add.simps)
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                {((x, y), l), (\<tau> (x, y), l + 1)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}) = 
                {(((x, y), l),((x', y'), l')),((\<tau> (x, y), l+1),(\<tau> (x', y'), l'+1))}" 
              using v1 v2 v3 v4 by fastforce
            have add_eq: " ((\<lambda>(x, y). the (proj_add x y)) `
      {(((x, y), l), (x', y'), l'), ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
                {(add (x, y) (x', y'), l + l'),(add (\<tau> (x, y)) (\<tau> (x', y')), l + l')}"
              using v1 v2 by force
            have add_eqs: "(add (x, y) (x', y'), l + l') = (add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
              using v1_eq_v2 by blast
            have "fst (add (x, y) (x', y')) = 0 \<or> snd (add (x, y) (x', y')) = 0"
              using b ccc unfolding e_aff_0_def p_delta_def p_delta'_def
                                       delta_def delta'_def delta_plus_def delta_minus_def
                                       delta_x_def delta_y_def e_aff_def e'_def
              apply(simp add: t_nz nz algebra_simps)
              apply(simp add: c_eq_1 power2_eq_square[symmetric] t_expr d_nz)
              apply(simp add: divide_simps d_nz nz) 
              by algebra

            have "add (x, y) (x', y') \<in> e_aff"
              using b(1) \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> add_closure e_e'_iff
              unfolding e_aff_0_def delta_def e_aff_def by(simp del: add.simps,blast)
            have "gluing `` {(add (x, y) (x', y'), l + l')} = {(add (x, y) (x', y'), l + l')}"
              by (metis \<open>add (x, y) (x', y') \<in> e_aff\<close> \<open>fst (add (x, y) (x', y')) = 0 \<or> snd (add (x, y) (x', y')) = 0\<close> e_points e_proj_elim_2 gluing_cases_explicit prod.collapse)
            then show "the_elem(proj_add_class p q) = {(add (x, y) (x', y'), l + l')}"
              unfolding assms proj_add_class_def 
              apply(subst dom_eq,subst add_eq,simp add: add_eqs[symmetric] del: add.simps \<tau>.simps)
              using \<open>add (x, y) (x', y') \<in> e_aff\<close> \<open>fst (add (x, y) (x', y')) = 0 \<or> snd (add (x, y) (x', y')) = 0\<close> eq_class_simp projective_curve.e_proj_elim_1 projective_curve_axioms by auto}}}

        {assume c: "((x, y), x', y') \<in> e_aff_1"
                  "\<not> ((\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))"
                  "((x, y), x', y') \<notin> e_aff_0"
        then have ld_nz: "delta' x y x' y' \<noteq> 0" "delta x y x' y' = 0" 
          unfolding e_aff_1_def e_aff_0_def \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> by auto    
        then have p_deltas: "p_delta' (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) \<noteq> 0" "p_delta (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) = 0" 
          unfolding p_delta'_def delta'_def delta_x_def delta_y_def 
          apply(simp add: t_nz algebra_simps power2_eq_square[symmetric] t_expr)
          apply(simp add: divide_simps nz d_nz power2_eq_square,algebra)   
          unfolding p_delta_def delta_def delta_plus_def delta_minus_def 
          using ld_nz unfolding delta_def delta_plus_def delta_minus_def
                                delta'_def delta_x_def delta_y_def
          by(simp add: t_nz nz divide_simps algebra_simps power2_eq_square[symmetric] t_expr d_nz)
        have v1: "proj_add ((x, y), l) ((x', y'), l') = Some (ext_add (x, y) (x', y'), l + l')"
          using ld_nz p_delta'_def p_delta_def proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> by force           
        have v2: "proj_add (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) = Some (ext_add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
          using p_deltas proj_add.simps taus(1) taus(2) by auto
        have v1_eq_v2: "Some (add (x, y) (x', y'), l + l') = Some (add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
          using inversion_invariance_1 nz tau_idemp 
          by (simp add: c_eq_1 t_nz)

        {assume aaa: "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0"         
          from aaa have v3: 
            "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some (add (x, y) (\<tau> (x', y')), l+l'+1)" 
            using proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x', y')) \<in> e_aff\<close> by simp
          have "p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) \<noteq> 0"
            using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
            apply(simp add: t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz)
            by (metis (no_types, lifting) eq_divide_eq_1 power_divide)
          then have v4: "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = Some (add (\<tau> (x, y)) (x', y'), l+l'+1)" 
            using proj_add.simps \<open>\<tau> (x,y) \<in> e_aff\<close> \<open>(x', y') \<in> e_aff\<close> p_delta_def by auto
          have v3_eq_v4: "Some (add (x, y) (\<tau> (x', y')), l+l'+1) = Some (add (\<tau> (x, y)) (x', y'), l+l'+1)" 
            using inversion_invariance_1 nz by auto
          have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
              {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
              {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}"
            using v1 v2 v3 v4 by auto
          have dups: "ext_add (x, y) (x', y') = ext_add (\<tau> (x, y)) (\<tau> (x', y'))"
                     "add (x, y) (\<tau> (x', y')) = add (\<tau> (x, y)) (x', y')"
            apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr)
            apply(simp add: divide_simps nz d_nz,argo) 
            using inversion_invariance_1 nz by presburger
          have add_eq: "((\<lambda>(x, y). the (proj_add x y)) `
      {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
          {(ext_add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}" 
            using v1 v2 v3 v4 v1_eq_v2 v3_eq_v4 dups by force

          have "x' * y' \<noteq> - x * y"
             using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
             apply(simp add: t_nz nz divide_simps)
             apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1) d_nz)
             by(simp add: ring_distribs(1)[symmetric] d_nz)               
          have "x' * y' \<noteq> x * y"
             using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
             apply(simp add: t_nz nz divide_simps)
             by(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1))

            have closure_lem: "add (x, y) (\<tau> (x', y')) \<in> e_aff"
            proof -
              obtain x1 y1 where z2_d: "\<tau> (x', y') = (x1,y1)" by fastforce
              define z3 where "z3 = add (x,y) (x1,y1)"
              obtain x2 y2 where z3_d: "z3 = (x2,y2)" by fastforce
              have "delta x y x1 y1 \<noteq> 0"
                using aaa z2_d unfolding p_delta_def by auto
              then have dpm: "delta_minus x y x1 y1 \<noteq> 0" "delta_plus x y x1 y1 \<noteq> 0"
                unfolding delta_def by auto
              have "(x1,y1) \<in> e_aff"
                unfolding z2_d[symmetric]
                using \<open>\<tau> (x', y') \<in> e_aff\<close> by auto
              have e_eq: "e x y = 0" "e x1 y1 = 0"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x1,y1) \<in> e_aff\<close> e_e'_iff  unfolding e_aff_def by(auto)
                
              have "e x2 y2 = 0" 
                using add_closure[OF z3_d z3_def dpm ] 
                using add_closure[OF z3_d z3_def dpm e_eq] by simp
              then show ?thesis 
                unfolding e_aff_def using e_e'_iff z3_d z3_def z2_d by simp
            qed      
                         
            have add_nz: 
              "fst (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              "snd (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              using b_cc_case[OF closure_lem \<open>(x,y) \<in> e_aff\<close> \<open>\<tau> (x',y') \<in> e_aff\<close>
                                 \<open>\<tau> (x',y') \<in> e_circ\<close> \<open>x' \<noteq> 0\<close> \<open>y' \<noteq> 0\<close>] 
              using \<open>x' * y' \<noteq> - x * y\<close> \<open>x' * y' \<noteq> x * y\<close> c(2) by blast+
            then have 1: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} =
                       gluing `` {(\<tau> (add (x,y) (\<tau> (x',y'))),l+l')}"
              using gluing_inv closure_lem by force
            also have "... = gluing `` {(ext_add (x,y) (x',y'),l+l')}"
              using  add_ext_add nz curve_addition.commutativity ext_add_comm 
              using inversion_invariance_1 by presburger
            finally have gl_eq: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} = 
                                 gluing `` {(ext_add (x,y) (x',y'),l+l')}" by blast

            have "\<tau> (add (x, y) (\<tau> (x', y'))) = ext_add (x, y) (x', y')"
              using add_ext_add ext_add_comm nz dups(2) by auto
            then have "gluing `` {(ext_add (x,y) (x',y'),l+l')} = {(ext_add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}"
              by (smt add.assoc add.commute add_nz(1) add_nz(2) closure_lem fst_conv gl_eq gluing_class insert_commute option.inject p_deltas(1) prod.collapse proj_add.simps snd_conv taus(1) taus(2) v2)
 
         show "the_elem(proj_add_class p q) = {(ext_add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}"
            unfolding assms proj_add_class_def          
            apply(simp del: \<tau>.simps ext_add.simps add.simps,subst dom_eq,subst add_eq)
            by (metis \<open>gluing `` {(ext_add (x, y) (x', y'), l + l')} = {(ext_add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}\<close> closure_lem e_points eq_class_simp gl_eq insert_not_empty prod.collapse the_elem_eq)}
        
        {assume bbb: "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0"
                    "p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0" 
        from c bbb have "False"
          unfolding e_aff_1_def e_aff_0_def e_aff_def e'_def
                    p_delta_def p_delta'_def delta_def delta'_def
                    delta_plus_def delta_minus_def delta_x_def delta_y_def
          apply(simp add: algebra_simps divide_simps nz t_nz d_nz power2_eq_square[symmetric] t_expr)
          by algebra           
        then show "False" by blast}
      {assume ccc: "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0"
                    "p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0" 
            from ccc have v3: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = None"
              by(simp add: proj_add.simps)
            from ccc have "p_delta (\<tau> (x, y), l+1) ((x', y'), l') = 0 \<and> 
                           p_delta' (\<tau> (x, y), l+1) ((x', y'), l') = 0"
              unfolding p_delta_def delta_def delta_plus_def delta_minus_def
                        p_delta'_def delta'_def delta_x_def delta_y_def 
              by(simp add: t_nz nz divide_simps algebra_simps power2_eq_square[symmetric] t_expr d_nz)               
            then have v4: "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = None" 
              by(simp add: proj_add.simps)
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                {((x, y), l), (\<tau> (x, y), l + 1)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}) = 
                {(((x, y), l),((x', y'), l')),((\<tau> (x, y), l+1),(\<tau> (x', y'), l'+1))}" 
              using v1 v2 v3 v4 by fastforce
            have add_eq: " ((\<lambda>(x, y). the (proj_add x y)) `
      {(((x, y), l), (x', y'), l'), ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
                {(ext_add (x, y) (x', y'), l + l'),(ext_add (\<tau> (x, y)) (\<tau> (x', y')), l + l')}"
              using v1 v2 by force
            have gl_class: "(ext_add (x, y) (x', y'), l + l') = (ext_add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
            proof -
              have f1: "\<forall>p. \<tau> (\<tau> p) = p"
                by (metis comp_apply id_apply tau_idemp)
              then have "\<forall>r ra. (ra::real, r::real) = (1 / 0, 0) \<or> t \<noteq> 0"
                by force
              then show ?thesis
                using f1 by (metis \<tau>.simps divide_eq_0_iff inversion_invariance_2 mult_eq_0_iff nz(1) nz(2) nz(3) nz(4))
            qed
            have "ext_add (x, y) (x', y') \<in> e_aff"
              using c ccc unfolding e_aff_1_def e_aff_0_def e_aff_def e'_def
                                    delta_def delta'_def p_delta_def p_delta'_def
                                    delta_plus_def delta_minus_def delta_x_def delta_y_def  
              apply(simp add: power2_eq_square)
              apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr) 
              by(simp add: divide_simps nz d_nz t_nz,algebra) 
            have "fst (ext_add (x, y) (x', y')) = 0 \<or> snd (ext_add (x, y) (x', y')) = 0"
              apply(simp)
              using c ccc ld_nz  unfolding
                                    e_aff_1_def e_aff_0_def e_aff_def e'_def
                                    delta_def delta'_def p_delta_def p_delta'_def
                                    delta_plus_def delta_minus_def delta_x_def delta_y_def
              apply(simp add: t_nz nz d_nz algebra_simps divide_simps)
              by(simp add: power2_eq_square[symmetric] t_expr d_nz,algebra)    
            have "gluing `` {(ext_add (x, y) (x', y'), l + l')} = {(ext_add (x, y) (x', y'), l + l')}"
              by (metis \<open>ext_add (x, y) (x', y') \<in> e_aff\<close> \<open>fst (ext_add (x, y) (x', y')) = 0 \<or> snd (ext_add (x, y) (x', y')) = 0\<close> e_points e_proj_elim_2 gluing_cases_explicit prod.collapse) 
            then show "the_elem(proj_add_class p q) = {(ext_add (x, y) (x', y'), l + l')}"
              unfolding assms proj_add_class_def 
              apply(subst dom_eq,subst add_eq)
              apply(subst gl_class[symmetric],simp del: ext_add.simps \<tau>.simps)  
              using \<open>ext_add (x, y) (x', y') \<in> e_aff\<close> \<open>fst (ext_add (x, y) (x', y')) = 0 \<or> snd (ext_add (x, y) (x', y')) = 0\<close> eq_class_simp projective_curve.e_proj_elim_1 projective_curve_axioms by auto}}
          
qed

lemma well_defined_4:
  assumes "p = {((x, y), l), (\<tau> (x, y), l + 1)}"
          "q = {((x', y'), l'), (\<tau> (x', y'), l' + 1)}"
          "p \<in> e_proj" "q \<in> e_proj"  
  shows "the_elem (proj_add_class p q) \<in> e_proj"
proof -
  from e_proj_eq[OF assms(3)] e_proj_eq[OF assms(4)]
  have p_q_expr: "(p = {((x, y), l)} \<or> p = {((x, y), l), (\<tau> (x, y), l + 1)})" 
              "(x, y) \<in> e_aff" 
              "(q = {((x', y'), l')} \<or> q = {((x', y'), l'), (\<tau> (x', y'), l' + 1)})"
              "(x', y') \<in> e_aff" 
    using assms(1) apply blast 
    using assms(1) assms(3) e_aff_bit_def e_proj_def eq_rel in_quotient_imp_subset apply force
    using assms(2) apply blast 
    using assms(2) assms(4) e_aff_bit_def e_proj_def eq_rel in_quotient_imp_subset by force
  have nz: "x \<noteq> 0" "y \<noteq> 0" "x' \<noteq> 0" "y' \<noteq> 0" 
    using assms e_proj_elim_2 p_q_expr apply fastforce   
    using assms e_proj_elim_2 p_q_expr apply fastforce  
    using assms(2) assms(4) e_proj_elim_2 p_q_expr(3) p_q_expr(4) apply fastforce
    using assms(2) assms(4) e_proj_elim_2 p_q_expr(3) p_q_expr(4) by fastforce    
  have non_taus: "(x,y) \<in> e_aff" "(x',y') \<in> e_aff"  "(x,y) \<in> e_circ" "(x',y') \<in> e_circ" 
     by(auto simp add: p_q_expr(2,4) \<open>x \<noteq> 0\<close> \<open>y \<noteq> 0\<close> \<open>x' \<noteq> 0\<close> \<open>y' \<noteq> 0\<close> e_circ_def) 
  have taus: "(\<tau> (x', y')) \<in> e_aff" "(\<tau> (x, y)) \<in> e_aff" "\<tau> (x', y') \<in> e_circ"
    using \<open>(x', y') \<in> e_circ\<close> \<tau>_circ e_circ_def apply auto[1]        
    using \<tau>_circ e_circ_def non_taus(3) apply auto[1]
    using \<tau>_circ non_taus(4) by blast

  consider
    (a) "(x, y) \<in> e_circ \<and> (\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y))" |
    (b) "((x, y), x', y') \<in> e_aff_0" "\<not> ((\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))" |
    (c) "((x, y), x', y') \<in> e_aff_1" "\<not> ((\<exists>g\<in>symmetries. (x', y') = (g \<circ> i) (x, y)))" "((x, y), x', y') \<notin> e_aff_0"
    using dichotomy_1[OF \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close>] \<open>(x,y) \<in> e_circ\<close> by blast
  then show ?thesis 
  proof(cases)
    case a
      then obtain g where sym_expr: "g \<in> symmetries" "(x', y') = (g \<circ> i) (x, y)" by auto        
      then have ds: "delta x y x' y' = 0" "delta' x y x' y' = 0"
        using wd_d_nz wd_d'_nz a by auto 
      then have one_none: "proj_add ((x, y), l) ((x', y'), l') = None"
        using proj_add.simps unfolding p_delta_def p_delta'_def by auto   
      have ds': "p_delta (\<tau> (x, y), l) (\<tau> (x', y'), l'+1) = 0" 
                "p_delta' (\<tau> (x, y), l) (\<tau> (x', y'), l'+1) = 0" 
        unfolding p_delta_def using ds apply(simp del: \<tau>.simps)
        unfolding delta_def delta_plus_def delta_minus_def
        apply(simp add: t_nz nz algebra_simps power2_eq_square[symmetric] t_expr(1) d_nz power_one_over) 
        unfolding p_delta'_def using ds apply(simp del: \<tau>.simps)
        unfolding delta'_def delta_x_def delta_y_def
        by(simp add: t_nz nz divide_simps power2_eq_square[symmetric] t_expr,argo)           
      then have one_none': "proj_add (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) = None"
        using proj_add.simps unfolding p_delta_def p_delta'_def by auto   

      {assume ex_eq: "proj_add ((x, y), l) (\<tau> (x', y'), l'+1) = 
              proj_add (\<tau> (x, y), l+1) ((x', y'), l')"
      have dom_ne: "(dom (\<lambda>(x, y). proj_add x y) \<inter> {((x, y), l), (\<tau> (x, y), l + 1)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}) \<noteq> {}"
        using covering[OF assms(3,4)] unfolding assms proj_add_class_def by blast
      have out_list: "(((x, y), l),((x', y'), l')) \<notin> (dom (\<lambda>(x, y). proj_add x y))"
                    "((\<tau> (x, y), l+1),(\<tau> (x', y'), l'+1)) \<notin> (dom (\<lambda>(x, y). proj_add x y))"
        using one_none one_none' unfolding dom_def by fastforce+
      have in_list: "(((x, y), l), \<tau> (x', y'), l' + 1) \<in> dom (\<lambda>(x, y). proj_add x y)"
           "((\<tau> (x, y), l + 1), (x', y'), l') \<in> dom (\<lambda>(x, y). proj_add x y)"
        using dom_ne out_list ex_eq by(fastforce)+ 
      have dom_eq: 
        "(dom (\<lambda>(x, y). proj_add x y) \<inter> 
          {((x, y), l), (\<tau> (x, y), l + 1)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}
         = {(((x, y), l),(\<tau> (x', y'), l'+1)),((\<tau> (x, y), l+1),((x', y'), l'))})" 
        using in_list out_list by simp
      have "proj_add_class p q \<noteq> {}" 
        by (simp add: assms(3) assms(4) covering)
      then have add_eq: "((\<lambda>(x, y). the (proj_add x y)) `
             {(((x, y), l), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l')} ) = 
           {the (proj_add ((x, y), l) (\<tau> (x', y'), l' + 1))}" 
        using ex_eq unfolding proj_add_class_def assms by auto
      then obtain v where "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some v"
        using in_list(1) by auto
      have "the_elem (proj_add_class p q) = the_elem ({the (proj_add ((x, y), l) (\<tau> (x', y'), l' + 1))} // gluing)"
        unfolding proj_add_class_def assms
        by(subst dom_eq, subst add_eq,argo) 
    }
    note simp_proj_class = this

    consider (1) "p_delta ((x, y), l) (\<tau> (x', y'), l'+1) \<noteq> 0" |
             (2) "p_delta' ((x, y), l) (\<tau> (x', y'), l'+1) \<noteq> 0" "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0" |
             (3) "p_delta ((x, y), l) (\<tau> (x', y'), l'+1) = 0"
                 "p_delta' ((x, y), l) (\<tau> (x', y'), l'+1) = 0" 
      using proj_add.simps by blast
    then show ?thesis
    proof(cases)
      case 1 
        then have pd': "p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) \<noteq> 0"
          unfolding p_delta_def delta_def delta_plus_def delta_minus_def
          by(simp add: t_nz nz field_simps power2_eq_square[symmetric] t_expr d_nz)
        from 1 have proj_eq: "proj_add ((x, y), l) (\<tau> (x', y'), l'+1) = Some(add (x, y) (\<tau> (x', y')), l+l'+1)"   
          using proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x', y')) \<in> e_aff\<close> by auto
        have "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = Some(add (\<tau> (x, y)) (x', y'), l+l'+1)"
          using proj_add.simps pd' \<open>(\<tau> (x, y)) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> by (simp add: p_delta_def)
        then have "proj_add ((x, y), l) (\<tau> (x', y'), l'+1) = proj_add (\<tau> (x, y), l+1) ((x', y'), l')"
          using \<open>proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some (add (x, y) (\<tau> (x', y')), l + l' + 1)\<close> inversion_invariance_1 nz by auto
        then have elem_eq: "the_elem (proj_add_class p q) = the_elem ({the (proj_add ((x, y), l) (\<tau> (x', y'), l' + 1))} // gluing)" 
          using simp_proj_class by simp       
        have "\<tau> (add (x, y) (\<tau> (x', y'))) = ext_add (x, y) (x', y')"
          using add_ext_add ext_add_comm nz(1-4) 
          using inversion_invariance_1 by presburger
        have eq: "x' * y' \<noteq> x * y"  
          using a 1 unfolding e_circ_def e_aff_def e'_def p_delta_def delta_def
                                delta_plus_def delta_minus_def
          apply(simp_all add: nz t_nz algebra_simps)
          apply(simp_all add: power2_eq_square[symmetric] t_expr d_nz) 
          apply(simp_all add: power2_eq_square) by algebra
      
        have "fst (add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (add (x, y) (\<tau> (x', y'))) = 0" 
          apply(simp add: t_nz nz)
          apply(simp add: c_eq_1 divide_simps t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz eq)
          using delta'_def delta_x_def delta_y_def ds(2) by auto
        have "add (x, y) (\<tau> (x', y')) \<in> e_aff"
        proof -
          have ds: "delta_plus x y (fst (\<tau> (x', y'))) (snd (\<tau> (x', y'))) \<noteq> 0"
               "delta_minus x y (fst (\<tau> (x', y'))) (snd (\<tau> (x', y'))) \<noteq> 0"
            using "1" delta_def p_delta_def by auto
          have "e x y = 0" "e (fst (\<tau> (x', y'))) (snd (\<tau> (x', y'))) = 0"
            using e_e'_iff p_q_expr(2) e_aff_def apply blast
            using e_e'_iff taus(1) e_aff_def by fastforce
          then show ?thesis
            unfolding e_aff_def using e_e'_iff apply(simp del: \<tau>.simps add.simps)
            using ds add_closure[of _ _ _ x y "fst (\<tau> (x', y'))" "snd (\<tau> (x', y'))"] by auto
        qed
        show ?thesis unfolding elem_eq proj_eq apply(simp del: add.simps \<tau>.simps)
          using e_proj_elim_1 
          using \<open>add (x, y) (\<tau> (x', y')) \<in> e_aff\<close> \<open>fst (add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (add (x, y) (\<tau> (x', y'))) = 0\<close> eq_class_simp by auto 
    next
      case 2
        then have pd': "p_delta' (\<tau> (x, y), l) ((x', y'), l' + 1) \<noteq> 0"
          unfolding p_delta'_def delta'_def delta_x_def delta_y_def
          by(simp add: t_nz nz field_simps power2_eq_square[symmetric] t_expr d_nz)
        from 2 have "p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) = 0" 
          unfolding p_delta_def delta_def delta_plus_def delta_minus_def
          by(simp add: t_nz nz field_simps power2_eq_square[symmetric] t_expr d_nz)
        from this 2 have proj_eq: "proj_add ((x, y), l) (\<tau> (x', y'), l'+1) = 
                   Some(ext_add (x, y) (\<tau> (x', y')), l+l'+1)"   
          using proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x', y')) \<in> e_aff\<close> by simp
        have "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = 
              Some(ext_add (\<tau> (x, y)) (x', y'), l+l'+1)"
          using proj_add.simps pd' \<open>(\<tau> (x, y)) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close>
          using \<open>p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) = 0\<close> p_delta'_def p_delta_def by auto
        then have "proj_add ((x, y), l) (\<tau> (x', y'), l'+1) = proj_add (\<tau> (x, y), l+1) ((x', y'), l')"
          using \<open>proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some (ext_add (x, y) (\<tau> (x', y')), l + l' + 1)\<close> inversion_invariance_2 nz(1-4) by presburger
        then have elem_eq: "the_elem (proj_add_class p q) = the_elem ({the (proj_add ((x, y), l) (\<tau> (x', y'), l' + 1))} // gluing)"
          using simp_proj_class by argo
        
        from sym_expr obtain r where rot_expr: "\<tau> (x',y') = (r \<circ> i) (x,y)" "r \<in> rotations"
          unfolding symmetries_def rotations_def apply(simp)
          by (smt comp_apply id_comp tau_idemp)
        then consider (1) "r = id" | (2) "r = \<rho>" | (3) "r = \<rho> \<circ> \<rho>" | (4) "r = \<rho> \<circ> \<rho> \<circ> \<rho>" 
          unfolding rotations_def by fast
        from this rot_expr have "delta x y x' y' = 0"
        proof(cases)
          case 1
            have eq: "x * (x' * t) = 1" "y * (y' * t) = - 1"
              using rot_expr 1 unfolding rotations_def apply(simp_all del: \<tau>.simps)
              by(simp_all add: divide_simps t_nz nz algebra_simps)
            then have "d * x * x' = t" "d * y * y' = - t"
            proof -
              have "d * x * x' = t * (x * (x' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
              also have "... = t" using eq by fastforce
              finally show "d * x * x' = t" by blast
              have "d * y * y' = t * (y * (y' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
              also have "... = -t" using eq by force
              finally show "d * y * y' = -t" by blast
            qed 
            then have "d * x * x' * y * y' = -1"  
              by (simp add: eq(2) mult.commute mult.left_commute)            
            then show ?thesis 
              unfolding delta_def delta_plus_def delta_minus_def by algebra
        next
          case 2
            have eq: "x' * (y * t) = 1" "x * (y' * t) = 1"
              using rot_expr 2 unfolding rotations_def apply(simp_all del: \<tau>.simps)
              by(simp_all add: divide_simps t_nz nz algebra_simps) 
            then have "d * x' * y = t" "d * x * y' = t"
            proof -
              have "d * x' * y = t * (x' * (y * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
              also have "... = t" using eq by fastforce
              finally show "d * x' * y = t" by blast
              have "d * x * y' = t * (x * (y' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
              also have "... = t" using eq by force
              finally show "d * x * y' = t" by blast
            qed 
            then have "d * x * x' * y * y' = 1"  
              by (metis eq(1) mult.commute mult.left_commute)            
            then show ?thesis 
              unfolding delta_def delta_plus_def delta_minus_def by algebra
        next
          case 3
            have eq: "x * (x' * t) = -1" "y * (y' * t) = 1"
              using rot_expr 3 unfolding rotations_def apply(simp_all del: \<tau>.simps)
              by(simp_all add: divide_simps t_nz nz algebra_simps) 
            then have "d * x * x' = -t" "d * y * y' = t"
            proof -
              have "d * x * x' = t * (x * (x' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
              also have "... = -t" using eq by fastforce
              finally show "d * x * x' = -t" by blast
              have "d * y * y' = t * (y * (y' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
              also have "... = t" using eq by force
              finally show "d * y * y' = t" by blast
            qed 
            then have "d * x * x' * y * y' = -1"  
              by (metis c_eq_1 eq(2) mult.assoc mult.commute mult_minus_left mult_minus_right)         
            then show ?thesis 
              unfolding delta_def delta_plus_def delta_minus_def by algebra
        next
          case 4
            have eq: "x' * (y * t) = -1" "x * (y' * t) = -1"
              using rot_expr 4 unfolding rotations_def apply(simp_all del: \<tau>.simps)
              by(simp_all add: divide_simps t_nz nz algebra_simps) 
            then have "d * x' * y = -t" "d * x * y' = -t"
            proof -
              have "d * x' * y = t * (x' * (y * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
              also have "... = -t" using eq by fastforce
              finally show "d * x' * y = -t" by blast
              have "d * x * y' = t * (x * (y' * t))" by(simp add: t_expr nz power2_eq_square[symmetric])
              also have "... = -t" using eq by force
              finally show "d * x * y' = -t" by blast
            qed 
            then have "d * x * x' * y * y' = 1"  
              by (metis add.inverse_inverse eq(1) mult.commute mult.left_commute mult_minus_right)        
            then show ?thesis 
              unfolding delta_def delta_plus_def delta_minus_def by algebra
          qed
             
          then have eq: "d * (x * (x' * (y * y'))) = 1 \<or> 1 + d * (x * (x' * (y * y'))) = 0"
            unfolding delta_def delta_plus_def delta_minus_def by algebra
  
          have "fst (ext_add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (ext_add (x, y) (\<tau> (x', y'))) = 0"        
            apply(simp add: t_nz nz)
            apply(simp add: c_eq_1 divide_simps t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz)
            using eq by blast
  
          have "ext_add (x, y) (\<tau> (x', y')) \<in> e_aff"
            using 2 ext_add_closure(1) \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x',y')) \<in> e_aff\<close>
            unfolding p_delta'_def e_aff_def
            apply(simp del: \<tau>.simps)
            by(fastforce)
  
          show ?thesis
            unfolding elem_eq apply(simp add: proj_eq del: \<tau>.simps)
            using \<open>ext_add (x, y) (\<tau> (x', y')) \<in> e_aff\<close> \<open>fst (ext_add (x, y) (\<tau> (x', y'))) = 0 \<or> snd (ext_add (x, y) (\<tau> (x', y'))) = 0\<close> eq_class_simp projective_curve.e_proj_elim_1 projective_curve_axioms by auto
      next
        case 3
          from 3 have "p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) = 0" 
            unfolding p_delta_def delta_def delta_plus_def delta_minus_def
            by(simp add: t_nz nz field_simps power2_eq_square[symmetric] t_expr d_nz)
          from 3 have pd': "p_delta' (\<tau> (x, y), l) ((x', y'), l' + 1) = 0"
            unfolding p_delta'_def delta'_def delta_x_def delta_y_def
            by(simp add: t_nz nz field_simps power2_eq_square[symmetric] t_expr d_nz)
          from 3 have proj_eq: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = None"
            by (simp add: proj_add.simps)
          have "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = proj_add (\<tau> (x, y), l + 1) ((x', y'), l')"
            using \<open>p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) = 0\<close> \<open>proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = None\<close> p_delta'_def p_delta_def pd' proj_add.simps by auto
          then have elem_eq: "the_elem (proj_add_class p q) = the_elem ({the None} // gluing)"
            using simp_proj_class proj_eq by argo
          have deltas: "delta x y x' y' = 0" "delta' x y x' y' = 0"
            apply (simp add: ds(1))
            using delta'_def delta_x_def delta_y_def ds(2) by auto
          have eq: "t^2 * x * x' * y * y' = 1 \<or> t^2 * x * x' * y * y' = -1"
                        "x' * y - x * y' = 0 \<or> x * x' + y * y' = 0"
            using deltas unfolding delta_def delta_plus_def delta_minus_def t_expr apply algebra
            using deltas unfolding delta'_def delta_x_def delta_y_def by simp
          have eq2: "x * y + x' * y' = 0 \<or> x' * y' = x * y"
                    "y * y' = x * x' \<or> x * y' + x' * y = 0"
            using 3
            unfolding e_circ_def e_aff_def e'_def
                      p_delta_def p_delta'_def delta_def delta'_def
                      delta_plus_def delta_minus_def delta_x_def delta_y_def
             apply(simp_all add: t_nz nz divide_simps algebra_simps power2_eq_square[symmetric] t_expr d_nz)
             by algebra+
          from eq2 a eq(1) taus non_taus have "False"
            unfolding e_circ_def e_aff_def e'_def
                      p_delta_def p_delta'_def delta_def delta'_def
                      delta_plus_def delta_minus_def delta_x_def delta_y_def
            apply(simp add: nz t_nz divide_simps) 
            apply(simp add: power2_eq_square algebra_simps)
            apply(simp add: power2_eq_square[symmetric] t_expr algebra_simps) 
            apply(safe) 
            using hard_eq_1 apply blast
            apply (metis (no_types, hide_lams) cancel_comm_monoid_add_class.diff_cancel curve_addition.delta_plus_def delta_plus_self diff_minus_eq_add mult.left_neutral mult_minus1_right power2_minus semiring_normalization_rules(18) semiring_normalization_rules(29))
            using hard_eq_1 apply blast
            using hard_eq_2[OF nz d_n1 d_nz] eq(2) apply blast
            using eq(2) apply(simp add: algebra_simps t_expr(1) t_sq_n1 power2_eq_square nz)
            using hard_eq_3[OF nz d_n1 d_nz] apply blast
            apply (metis add_neg_numeral_special(7) c_eq_1 mult.left_commute nz(3) semiring_normalization_rules(18) semiring_normalization_rules(29) sum_squares_eq_zero_iff)
            apply (smt mult_minus_right no_zero_divisors nz(2) nz(4) zero_le_mult_iff)
            by(metis add_neg_numeral_special(7) c_eq_1 mult.left_commute nz(3) semiring_normalization_rules(18) semiring_normalization_rules(29) sum_squares_eq_zero_iff)
          then show ?thesis by blast
        qed
      next
        case b
        then have ld_nz: "delta x y x' y' \<noteq> 0" 
          unfolding e_aff_0_def by auto    
        then have "p_delta (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) \<noteq> 0" 
          unfolding p_delta_def delta_def delta_plus_def delta_minus_def 
          by(simp add: t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz power_one_over)
        have v1: "proj_add ((x, y), l) ((x', y'), l') = Some (add (x, y) (x', y'), l + l')"
          using ld_nz p_delta_def proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> by simp
        have v2: "proj_add (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) = Some (add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
          using \<open>p_delta (\<tau> (x, y), l + 1) (\<tau> (x', y'), l' + 1) \<noteq> 0\<close> proj_add.simps taus(1) taus(2) by auto
        have v1_eq_v2: "Some (add (x, y) (x', y'), l + l') = Some (add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
          using inversion_invariance_1 nz tau_idemp 
          by (simp add: c_eq_1 t_nz)
        consider
          (aaa) "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0" |
          (bbb) "p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0" 
                "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0"|
          (ccc) "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<and> 
                 p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0" 
          by(simp add: proj_add.simps,blast)        
        then show ?thesis 
        proof(cases)
          case aaa         
          from aaa have v3: 
            "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some (add (x, y) (\<tau> (x', y')), l+l'+1)" 
            using proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x', y')) \<in> e_aff\<close> by simp
          have "p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) \<noteq> 0"
            using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
            apply(simp add: t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz)
            by (metis (no_types, lifting) eq_divide_eq_1 power_divide)
          then have v4: "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = Some (add (\<tau> (x, y)) (x', y'), l+l'+1)" 
            using proj_add.simps \<open>\<tau> (x,y) \<in> e_aff\<close> \<open>(x', y') \<in> e_aff\<close> p_delta_def by auto
          have v3_eq_v4: "Some (add (x, y) (\<tau> (x', y')), l+l'+1) = Some (add (\<tau> (x, y)) (x', y'), l+l'+1)" 
            using inversion_invariance_1 nz by auto
          have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
              {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
              {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}"
            using v1 v2 v3 v4 by auto
          have add_eq: "((\<lambda>(x, y). the (proj_add x y)) `
      {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
          {(add (x, y) (x', y'), l + l'),(add (x, y) (\<tau> (x', y')), l + l' + 1)}" 
            using v1 v2 v3 v4 v1_eq_v2 v3_eq_v4 by force

          have "x' * y' \<noteq> - x * y"
             using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
             apply(simp add: t_nz nz divide_simps)
             apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1) d_nz)
             by(simp add: ring_distribs(1)[symmetric] d_nz)               
          have "x' * y' \<noteq> x * y"
             using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
             apply(simp add: t_nz nz divide_simps)
             by(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1))

            have closure_lem: "add (x, y) (\<tau> (x', y')) \<in> e_aff"
            proof -
              obtain x1 y1 where z2_d: "\<tau> (x', y') = (x1,y1)" by fastforce
              define z3 where "z3 = add (x,y) (x1,y1)"
              obtain x2 y2 where z3_d: "z3 = (x2,y2)" by fastforce
              have "delta x y x1 y1 \<noteq> 0"
                using aaa z2_d unfolding p_delta_def by auto
              then have dpm: "delta_minus x y x1 y1 \<noteq> 0" "delta_plus x y x1 y1 \<noteq> 0"
                unfolding delta_def by auto
              have "(x1,y1) \<in> e_aff"
                unfolding z2_d[symmetric]
                using \<open>\<tau> (x', y') \<in> e_aff\<close> by auto
              have e_eq: "e x y = 0" "e x1 y1 = 0"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x1,y1) \<in> e_aff\<close> e_e'_iff  unfolding e_aff_def by(auto)
                
              have "e x2 y2 = 0" 
                using add_closure[OF z3_d z3_def dpm ] 
                using add_closure[OF z3_d z3_def dpm e_eq] by simp
              then show ?thesis 
                unfolding e_aff_def using e_e'_iff z3_d z3_def z2_d by simp
            qed      
                         
            have add_nz: 
              "fst (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              "snd (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              using b_cc_case[OF closure_lem \<open>(x,y) \<in> e_aff\<close> \<open>\<tau> (x',y') \<in> e_aff\<close>
                                 \<open>\<tau> (x',y') \<in> e_circ\<close> \<open>x' \<noteq> 0\<close> \<open>y' \<noteq> 0\<close>] 
              using \<open>x' * y' \<noteq> - x * y\<close> \<open>x' * y' \<noteq> x * y\<close> b(2) by blast+
            then have 1: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} =
                       gluing `` {(\<tau> (add (x,y) (\<tau> (x',y'))),l+l')}"
              using gluing_inv closure_lem by force
            also have "... = gluing `` {(ext_add (x,y) (x',y'),l+l')}"
              using  add_ext_add nz curve_addition.commutativity ext_add_comm 
              using inversion_invariance_1 by presburger
            finally have gl_eq: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} = 
                                 gluing `` {(ext_add (x,y) (x',y'),l+l')}" by blast

          have gl_class: "{(add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)} // gluing =
                  {gluing `` {(add (x, y) (\<tau> (x', y')), l + l'+1)}}"
          proof(cases "delta' x y x' y' = 0")
            case True
            then have "\<exists> v. (ext_add (x,y) (x',y')) = (v,0) \<or>
                             (ext_add (x,y) (x',y')) = (0,v)" 
              unfolding delta'_def delta_x_def delta_y_def by auto
            then have "\<exists> v. (add (x,y) (\<tau> (x',y'))) = (v,0) \<or>
                             (add (x,y) (\<tau> (x',y'))) = (0,v)"
            proof -
              show ?thesis
                by (metis (no_types) \<open>\<exists>v. ext_add (x, y) (x', y') = (v, 0) \<or> ext_add (x, y) (x', y') = (0, v)\<close> \<tau>.simps add_ext_add comp_apply division_ring_divide_zero id_apply inversion_invariance_1 mult_eq_0_iff nz(1) nz(2) nz(3) nz(4) tau_idemp)
            qed
            then show ?thesis using add_nz by force
          next
            case False
            then have "(ext_add (x,y) (x',y'),l+l') = (add (x,y) (x',y'),l+l')" 
              using coherence e_aff_def ld_nz p_q_expr(2,4) by auto
            then have "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} = 
                       gluing `` {(add (x,y) (x',y'),l+l')}" using gl_eq by argo
            have "gluing `` {(add (x, y) (x', y'), l + l')} = 
                   {(add (x,y) (x',y'),l+l'),((add (x,y) (\<tau> (x',y'))),l+l'+1)}"
              by (smt assms(2) \<open>(ext_add (x, y) (x', y'), l + l') = (add (x, y) (x', y'), l + l')\<close> add.commute add_cancel_right_left add_ext_add[OF nz] add_nz(1) add_nz(2) assms(2) bit_not_1_iff closure_lem doubleton_eq_iff gluing_class gluing_inv inversion_invariance_1[OF nz] nz(1) nz(2) nz(3) p_q_expr(4) prod.collapse)
            then show "{(add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)} // gluing =
                  {gluing `` {(add (x, y) (\<tau> (x', y')), l + l'+1)}}" 
              by (metis \<open>gluing `` {(add (x, y) (\<tau> (x', y')), l + l' + 1)} = gluing `` {(add (x, y) (x', y'), l + l')}\<close> closure_lem eq_class_image prod.collapse)
          qed

          show ?thesis
            unfolding assms proj_add_class_def 
            apply(simp del: \<tau>.simps,subst dom_eq,subst add_eq,subst gl_class)
            apply(simp del: \<tau>.simps add.simps)
            using closure_lem e_points by auto
        next
          case bbb
            from bbb have v3: 
              "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some (ext_add (x, y) (\<tau> (x', y')), l+l'+1)" 
                using proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x', y')) \<in> e_aff\<close> by simp
            have pd: "p_delta (\<tau> (x, y), l+1) ((x', y'), l') = 0"
              using bbb unfolding p_delta_def delta_def delta_plus_def delta_minus_def
                                  p_delta'_def delta'_def delta_x_def delta_y_def 
              apply(simp add: t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz)
              by (metis eq_divide_eq_1 power_divide)
            have pd': "p_delta' (\<tau> (x, y), l+1) ((x', y'), l') \<noteq> 0"
              using bbb unfolding p_delta'_def delta'_def delta_x_def delta_y_def
              by(simp add: t_nz nz divide_simps algebra_simps power2_eq_square[symmetric] t_expr d_nz)
            then have pd'': "p_delta' ((x, y), l) (\<tau> (x', y'), l'+1) \<noteq> 0"
              unfolding p_delta'_def delta'_def delta_x_def delta_y_def
              by(simp add: divide_simps t_nz nz,argo) 
            have v4: "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = Some (ext_add (\<tau> (x, y)) (x', y'), l+l'+1)"
              using proj_add.simps \<open>\<tau> (x,y) \<in> e_aff\<close> \<open>(x', y') \<in> e_aff\<close> pd pd' by simp
            have v3_eq_v4: "Some (ext_add (x, y) (\<tau> (x', y')), l+l'+1) = Some (ext_add (\<tau> (x, y)) (x', y'), l+l'+1)" 
              using inversion_invariance_2 nz by auto
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
       {((x, y), l), (\<tau> (x, y), l + 1)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)})  = 
              {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}"
              using v1 v2 v3 v4 by auto
            have add_eq: "((\<lambda>(x, y). the (proj_add x y)) `
      {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
          {(add (x, y) (x', y'), l + l'),(ext_add (x, y) (\<tau> (x', y')), l+l'+1)}"
              using v1 v2 v3 v4 v1_eq_v2 v3_eq_v4 by auto
            have trans_add: "\<tau> (add (x, y) (x', y')) = (ext_add (x, y) (\<tau> (x', y')))" 
              using add_ext_add_2 inversion_invariance_2 nz pointfree_idE by auto
            
            have closure_lem: "ext_add (x, y) (\<tau> (x', y')) \<in> e_aff"
            proof -
              obtain x1 y1 where z2_d: "\<tau> (x', y') = (x1,y1)" by fastforce
              define z3 where "z3 = ext_add (x,y) (x1,y1)"
              obtain x2 y2 where z3_d: "z3 = (x2,y2)" by fastforce
              have d': "delta' x y x1 y1 \<noteq> 0"
                using bbb z2_d unfolding p_delta'_def by auto
              have "(x1,y1) \<in> e_aff"
                unfolding z2_d[symmetric]
                using \<open>\<tau> (x', y') \<in> e_aff\<close> by auto
              have e_eq: "e' x y = 0" "e' x1 y1 = 0"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x1,y1) \<in> e_aff\<close> unfolding e_aff_def by(auto)
                
              have "e' x2 y2 = 0" 
                using z3_d z3_def ext_add_closure[OF d' e_eq, of x2 y2] by blast
              then show ?thesis 
                unfolding e_aff_def using e_e'_iff z3_d z3_def z2_d by simp
            qed     

            have eq: "x * y' + y * x' \<noteq> 0"  "y * y' \<noteq> x * x'"
              using bbb unfolding p_delta'_def delta'_def delta_x_def delta_y_def
              by(simp add: t_nz nz divide_simps)+

            have nz1: "fst(ext_add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr)
              apply(simp add: divide_simps d_nz t_nz nz)
              apply(rule conjI)
              using ld_nz unfolding delta_def delta_minus_def apply algebra
              using eq by blast
                        
            have nz2: "snd(ext_add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr)
              apply(simp add: divide_simps d_nz t_nz nz)
              apply(rule conjI)
              using ld_nz unfolding delta_def delta_plus_def apply algebra
              using eq by simp
            
            have "gluing `` {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)} \<in> e_proj"
              using e_points closure_lem by fastforce
            then have "gluing `` {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)} = {(add (x, y) (x', y'), l + l'), (ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}"
              using gluing_cases_explicit e_proj_elim_2 nz1 nz2 
              by (smt \<tau>.simps doubleton_eq_iff e_proj_eq gluing_class gluing_inv old.prod.inject pointfree_idE prod.collapse singleton_insert_inj_eq' tau_idemp trans_add)
            show ?thesis
              unfolding assms proj_add_class_def
              apply(subst dom_eq,subst add_eq) 
              using \<open>gluing `` {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)} = {(add (x, y) (x', y'), l + l'), (ext_add (x, y) (\<tau> (x', y')), l + l' + 1)}\<close> \<open>gluing `` {(ext_add (x, y) (\<tau> (x', y')), l + l' + 1)} \<in> e_proj\<close> eq_class_simp by auto
        next
          case ccc
            from ccc have v3: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = None"
              by(simp add: proj_add.simps)
            from ccc have "p_delta (\<tau> (x, y), l+1) ((x', y'), l') = 0 \<and> 
                           p_delta' (\<tau> (x, y), l+1) ((x', y'), l') = 0"
              unfolding p_delta_def delta_def delta_plus_def delta_minus_def
                        p_delta'_def delta'_def delta_x_def delta_y_def 
              by(simp add: t_nz nz divide_simps algebra_simps power2_eq_square[symmetric] t_expr d_nz)               
            then have v4: "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = None" 
              by(simp add: proj_add.simps)
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                {((x, y), l), (\<tau> (x, y), l + 1)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}) = 
                {(((x, y), l),((x', y'), l')),((\<tau> (x, y), l+1),(\<tau> (x', y'), l'+1))}" 
              using v1 v2 v3 v4 by fastforce
            have add_eq: " ((\<lambda>(x, y). the (proj_add x y)) `
      {(((x, y), l), (x', y'), l'), ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
                {(add (x, y) (x', y'), l + l'),(add (\<tau> (x, y)) (\<tau> (x', y')), l + l')}"
              using v1 v2 by force
            have add_eqs: "(add (x, y) (x', y'), l + l') = (add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
              using v1_eq_v2 by blast
            have "fst (add (x, y) (x', y')) = 0 \<or> snd (add (x, y) (x', y')) = 0"
              using b ccc unfolding e_aff_0_def p_delta_def p_delta'_def
                                       delta_def delta'_def delta_plus_def delta_minus_def
                                       delta_x_def delta_y_def e_aff_def e'_def
              apply(simp add: t_nz nz algebra_simps)
              apply(simp add: c_eq_1 power2_eq_square[symmetric] t_expr d_nz)
              apply(simp add: divide_simps d_nz nz) 
              by algebra

            have "add (x, y) (x', y') \<in> e_aff"
              using b(1) \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> add_closure e_e'_iff
              unfolding e_aff_0_def delta_def e_aff_def by(simp del: add.simps,blast)
                  
            show ?thesis
              unfolding assms proj_add_class_def 
              apply(subst dom_eq,subst add_eq,simp add: add_eqs[symmetric] del: add.simps \<tau>.simps)
              using \<open>add (x, y) (x', y') \<in> e_aff\<close> \<open>fst (add (x, y) (x', y')) = 0 \<or> snd (add (x, y) (x', y')) = 0\<close> eq_class_simp projective_curve.e_proj_elim_1 projective_curve_axioms by auto
          qed
      next
        case c
        then have ld_nz: "delta' x y x' y' \<noteq> 0" "delta x y x' y' = 0" 
          unfolding e_aff_1_def e_aff_0_def \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> by auto    
        then have p_deltas: "p_delta' (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) \<noteq> 0" "p_delta (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) = 0" 
          unfolding p_delta'_def delta'_def delta_x_def delta_y_def 
          apply(simp add: t_nz algebra_simps power2_eq_square[symmetric] t_expr)
          apply(simp add: divide_simps nz d_nz power2_eq_square,algebra)   
          unfolding p_delta_def delta_def delta_plus_def delta_minus_def 
          using ld_nz unfolding delta_def delta_plus_def delta_minus_def
                                delta'_def delta_x_def delta_y_def
          by(simp add: t_nz nz divide_simps algebra_simps power2_eq_square[symmetric] t_expr d_nz)
        have v1: "proj_add ((x, y), l) ((x', y'), l') = Some (ext_add (x, y) (x', y'), l + l')"
          using ld_nz p_delta'_def p_delta_def proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(x',y') \<in> e_aff\<close> by force           
        have v2: "proj_add (\<tau> (x, y), l+1) (\<tau> (x', y'), l'+1) = Some (ext_add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
          using p_deltas proj_add.simps taus(1) taus(2) by auto
        have v1_eq_v2: "Some (add (x, y) (x', y'), l + l') = Some (add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
          using inversion_invariance_1 nz tau_idemp 
          by (simp add: c_eq_1 t_nz)
        consider
          (aaa) "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0" |
          (bbb) "p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) \<noteq> 0" 
                "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0"|
          (ccc) "p_delta ((x, y), l) (\<tau> (x', y'), l' + 1) = 0 \<and> 
                 p_delta' ((x, y), l) (\<tau> (x', y'), l' + 1) = 0" 
          by(simp add: proj_add.simps,blast)        
        then show ?thesis 
        proof(cases)
          case aaa         
          from aaa have v3: 
            "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = Some (add (x, y) (\<tau> (x', y')), l+l'+1)" 
            using proj_add.simps \<open>(x,y) \<in> e_aff\<close> \<open>(\<tau> (x', y')) \<in> e_aff\<close> by simp
          have "p_delta (\<tau> (x, y), l) ((x', y'), l' + 1) \<noteq> 0"
            using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
            apply(simp add: t_nz nz algebra_simps power2_eq_square[symmetric] t_expr d_nz)
            by (metis (no_types, lifting) eq_divide_eq_1 power_divide)
          then have v4: "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = Some (add (\<tau> (x, y)) (x', y'), l+l'+1)" 
            using proj_add.simps \<open>\<tau> (x,y) \<in> e_aff\<close> \<open>(x', y') \<in> e_aff\<close> p_delta_def by auto
          have v3_eq_v4: "Some (add (x, y) (\<tau> (x', y')), l+l'+1) = Some (add (\<tau> (x, y)) (x', y'), l+l'+1)" 
            using inversion_invariance_1 nz by auto
          have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
              {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
              {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
               ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}"
            using v1 v2 v3 v4 by auto
          have dups: "ext_add (x, y) (x', y') = ext_add (\<tau> (x, y)) (\<tau> (x', y'))"
                     "add (x, y) (\<tau> (x', y')) = add (\<tau> (x, y)) (x', y')"
            apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr)
            apply(simp add: divide_simps nz d_nz,argo) 
            using inversion_invariance_1 nz by presburger
          have add_eq: "((\<lambda>(x, y). the (proj_add x y)) `
      {(((x, y), l), (x', y'), l'), (((x, y), l), \<tau> (x', y'), l' + 1),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1), ((\<tau> (x, y), l + 1), (x', y'), l'),
       ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
          {(ext_add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}" 
            using v1 v2 v3 v4 v1_eq_v2 v3_eq_v4 dups by force

          have "x' * y' \<noteq> - x * y"
             using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
             apply(simp add: t_nz nz divide_simps)
             apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1) d_nz)
             by(simp add: ring_distribs(1)[symmetric] d_nz)               
          have "x' * y' \<noteq> x * y"
             using aaa unfolding p_delta_def delta_def delta_plus_def delta_minus_def
             apply(simp add: t_nz nz divide_simps)
             by(simp add: algebra_simps power2_eq_square[symmetric] t_expr(1))

            have closure_lem: "add (x, y) (\<tau> (x', y')) \<in> e_aff"
            proof -
              obtain x1 y1 where z2_d: "\<tau> (x', y') = (x1,y1)" by fastforce
              define z3 where "z3 = add (x,y) (x1,y1)"
              obtain x2 y2 where z3_d: "z3 = (x2,y2)" by fastforce
              have "delta x y x1 y1 \<noteq> 0"
                using aaa z2_d unfolding p_delta_def by auto
              then have dpm: "delta_minus x y x1 y1 \<noteq> 0" "delta_plus x y x1 y1 \<noteq> 0"
                unfolding delta_def by auto
              have "(x1,y1) \<in> e_aff"
                unfolding z2_d[symmetric]
                using \<open>\<tau> (x', y') \<in> e_aff\<close> by auto
              have e_eq: "e x y = 0" "e x1 y1 = 0"
                using \<open>(x,y) \<in> e_aff\<close> \<open>(x1,y1) \<in> e_aff\<close> e_e'_iff  unfolding e_aff_def by(auto)
                
              have "e x2 y2 = 0" 
                using add_closure[OF z3_d z3_def dpm ] 
                using add_closure[OF z3_d z3_def dpm e_eq] by simp
              then show ?thesis 
                unfolding e_aff_def using e_e'_iff z3_d z3_def z2_d by simp
            qed      
                         
            have add_nz: 
              "fst (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              "snd (add (x, y) (\<tau> (x', y'))) \<noteq> 0"
              using b_cc_case[OF closure_lem \<open>(x,y) \<in> e_aff\<close> \<open>\<tau> (x',y') \<in> e_aff\<close>
                                 \<open>\<tau> (x',y') \<in> e_circ\<close> \<open>x' \<noteq> 0\<close> \<open>y' \<noteq> 0\<close>] 
              using \<open>x' * y' \<noteq> - x * y\<close> \<open>x' * y' \<noteq> x * y\<close> c(2) by blast+
            then have 1: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} =
                       gluing `` {(\<tau> (add (x,y) (\<tau> (x',y'))),l+l')}"
              using gluing_inv closure_lem by force
            also have "... = gluing `` {(ext_add (x,y) (x',y'),l+l')}"
              using  add_ext_add nz curve_addition.commutativity ext_add_comm 
              using inversion_invariance_1 by presburger
            finally have gl_eq: "gluing `` {((add (x,y) (\<tau> (x',y'))),l+l'+1)} = 
                                 gluing `` {(ext_add (x,y) (x',y'),l+l')}" by blast

            have "\<tau> (add (x, y) (\<tau> (x', y'))) = ext_add (x, y) (x', y')"
              using add_ext_add ext_add_comm nz dups(2) by auto
            then have "gluing `` {(ext_add (x,y) (x',y'),l+l')} = {(ext_add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}"
              by (smt add.assoc add.commute add_nz(1) add_nz(2) closure_lem fst_conv gl_eq gluing_class insert_commute option.inject p_deltas(1) prod.collapse proj_add.simps snd_conv taus(1) taus(2) v2)
          then have "card ({(ext_add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)} // gluing) = Suc 0"
            by (metis card_Suc_eq card_empty closure_lem empty_iff eq_class_image gl_eq prod.collapse)            
          show ?thesis
            unfolding assms proj_add_class_def
            apply(simp del: \<tau>.simps,subst dom_eq,subst add_eq)
            by (metis \<open>gluing `` {(ext_add (x, y) (x', y'), l + l')} = {(ext_add (x, y) (x', y'), l + l'), (add (x, y) (\<tau> (x', y')), l + l' + 1)}\<close> closure_lem e_points eq_class_simp gl_eq insert_not_empty prod.collapse the_elem_eq)
        next
          case bbb
            from c bbb have "False"
              unfolding e_aff_1_def e_aff_0_def e_aff_def e'_def
                        p_delta_def p_delta'_def delta_def delta'_def
                        delta_plus_def delta_minus_def delta_x_def delta_y_def
              apply(simp add: algebra_simps divide_simps nz t_nz d_nz power2_eq_square[symmetric] t_expr)
              by algebra           
            then show ?thesis by blast
        next
          case ccc
            from ccc have v3: "proj_add ((x, y), l) (\<tau> (x', y'), l' + 1) = None"
              by(simp add: proj_add.simps)
            from ccc have "p_delta (\<tau> (x, y), l+1) ((x', y'), l') = 0 \<and> 
                           p_delta' (\<tau> (x, y), l+1) ((x', y'), l') = 0"
              unfolding p_delta_def delta_def delta_plus_def delta_minus_def
                        p_delta'_def delta'_def delta_x_def delta_y_def 
              by(simp add: t_nz nz divide_simps algebra_simps power2_eq_square[symmetric] t_expr d_nz)               
            then have v4: "proj_add (\<tau> (x, y), l+1) ((x', y'), l') = None" 
              by(simp add: proj_add.simps)
            have dom_eq: "(dom (\<lambda>(x, y). proj_add x y) \<inter>
                {((x, y), l), (\<tau> (x, y), l + 1)} \<times> {((x', y'), l'), (\<tau> (x', y'), l' + 1)}) = 
                {(((x, y), l),((x', y'), l')),((\<tau> (x, y), l+1),(\<tau> (x', y'), l'+1))}" 
              using v1 v2 v3 v4 by fastforce
            have add_eq: " ((\<lambda>(x, y). the (proj_add x y)) `
      {(((x, y), l), (x', y'), l'), ((\<tau> (x, y), l + 1), \<tau> (x', y'), l' + 1)}) = 
                {(ext_add (x, y) (x', y'), l + l'),(ext_add (\<tau> (x, y)) (\<tau> (x', y')), l + l')}"
              using v1 v2 by force
            have gl_class: "(ext_add (x, y) (x', y'), l + l') = (ext_add (\<tau> (x, y)) (\<tau> (x', y')), l + l')"
            proof -
              have f1: "\<forall>p. \<tau> (\<tau> p) = p"
                by (metis comp_apply id_apply tau_idemp)
              then have "\<forall>r ra. (ra::real, r::real) = (1 / 0, 0) \<or> t \<noteq> 0"
                by force
              then show ?thesis
                using f1 by (metis \<tau>.simps divide_eq_0_iff inversion_invariance_2 mult_eq_0_iff nz(1) nz(2) nz(3) nz(4))
            qed
            have "ext_add (x, y) (x', y') \<in> e_aff"
              using c ccc unfolding e_aff_1_def e_aff_0_def e_aff_def e'_def
                                    delta_def delta'_def p_delta_def p_delta'_def
                                    delta_plus_def delta_minus_def delta_x_def delta_y_def  
              apply(simp add: power2_eq_square)
              apply(simp add: algebra_simps power2_eq_square[symmetric] t_expr) 
              by(simp add: divide_simps nz d_nz t_nz,algebra) 
            have "fst (ext_add (x, y) (x', y')) = 0 \<or> snd (ext_add (x, y) (x', y')) = 0"
              apply(simp)
              using c ccc ld_nz  unfolding
                                    e_aff_1_def e_aff_0_def e_aff_def e'_def
                                    delta_def delta'_def p_delta_def p_delta'_def
                                    delta_plus_def delta_minus_def delta_x_def delta_y_def
              apply(simp add: t_nz nz d_nz algebra_simps divide_simps)
              by(simp add: power2_eq_square[symmetric] t_expr d_nz,algebra)            
            show ?thesis 
              unfolding assms proj_add_class_def 
              apply(subst dom_eq,subst add_eq)
              apply(subst gl_class[symmetric],simp del: ext_add.simps \<tau>.simps)  
              using \<open>ext_add (x, y) (x', y') \<in> e_aff\<close> \<open>fst (ext_add (x, y) (x', y')) = 0 \<or> snd (ext_add (x, y) (x', y')) = 0\<close> eq_class_simp projective_curve.e_proj_elim_1 projective_curve_axioms by auto
qed qed qed

theorem well_defined:
  assumes "p \<in> e_proj" "q \<in> e_proj"
  shows "the_elem (proj_add_class p q) \<in> e_proj"
proof -
  from e_proj_eq[OF assms(1)] e_proj_eq[OF assms(2)]
  obtain x y l x' y' l' where 
    p_q_expr: "(p = {((x, y), l)} \<or> p = {((x, y), l), (\<tau> (x, y), l + 1)})" 
              "(x, y) \<in> e_aff" 
              "(q = {((x', y'), l')} \<or> q = {((x', y'), l'), (\<tau> (x', y'), l' + 1)})"
              "(x', y') \<in> e_aff" by blast
  then consider
           (1) "p = {((x, y), l)}" "q = {((x', y'), l')}" |
           (2) "p = {((x, y), l)}" "q = {((x', y'), l'), (\<tau> (x', y'), l' + 1)}" |
           (3) "p = {((x, y), l), (\<tau> (x, y), l + 1)}" "q = {((x', y'), l')}" |
           (4) "p = {((x, y), l), (\<tau> (x, y), l + 1)}" "q = {((x', y'), l'), (\<tau> (x', y'), l' + 1)}" by argo 
    then show ?thesis
    proof(cases)
      case 1 then show ?thesis using well_defined_1 assms by blast
    next
      case 2 then show ?thesis using well_defined_2 assms by (simp add: p_q_expr(2) p_q_expr(4))
    next
      case 3 then show ?thesis using assms(1,2) p_q_expr(2,4) proj_add_class_comm well_defined_2 by auto
    next
      case 4 then show ?thesis using assms(1,2) p_q_expr(2,4) proj_add_class_comm well_defined_4 by auto      
    qed
qed     


definition tf  where
  "tf g = image (\<lambda> p. (g (fst p), snd p))"

lemma
  assumes "g \<in> rotations"
  shows "proj_addition (tf g (gluing `` {(p1,l)})) (gluing `` {(p2,j)}) =
         tf g (proj_addition (gluing `` {(p1,l)}) (gluing `` {(p2,j)}))"
proof -
  assume as: "g = \<rho>"
  have ?thesis
    apply(simp add: as)
    unfolding t_def image_def
    apply(standard) 
  proof -

    oops

(* in the appropiate localizations means we can use delta \<noteq> 0 *)
lemma add_add_assoc:
  assumes "(x1,y1) \<in> e_aff" "(x2,y2) \<in> e_aff" "(x3,y3) \<in> e_aff"
  assumes "delta x1 y1 x2 y2 \<noteq> 0" "delta x2 y2 x3 y3 \<noteq> 0"
          "delta (fst (add (x1,y1) (x2,y2))) (snd (add (x1,y1) (x2,y2))) x3 y3 \<noteq> 0"
          "delta x1 y1 (fst (add (x2,y2) (x3,y3))) (snd (add (x2,y2) (x3,y3))) \<noteq> 0"
        shows "add (add (x1,y1) (x2,y2)) (x3,y3) = add (x1,y1) (add (x2,y2) (x3,y3))"
  using assms unfolding e_aff_def delta_def apply(simp)
  using associativity e_e'_iff by fastforce

lemma ext_add_hard_1:
  "x2 \<noteq> 0 \<Longrightarrow>
    y2 = 0 \<Longrightarrow>
    x3 \<noteq> 0 \<Longrightarrow>
    y3 \<noteq> 0 \<Longrightarrow>
    y1 \<noteq> 0 \<Longrightarrow>
    x1 \<noteq> 0 \<Longrightarrow>
    x1 * (x1 * (x2 * (x3 * y1))) + x1 * (x2 * (y1 * (y1 * y3))) \<noteq> 0 \<Longrightarrow>
    - (x1 * (x2 * (x3 * (x3 * y3)))) \<noteq> x2 * (x3 * (y1 * (y3 * y3))) \<Longrightarrow>
    x1 * x1 + y1 * y1 = 1 + d * (x1 * (x1 * (y1 * y1))) \<Longrightarrow>
    x2 * x2 = 1 \<Longrightarrow>
    x3 * x3 + y3 * y3 = 1 + d * (x3 * (x3 * (y3 * y3))) \<Longrightarrow>
    x3 * y1 \<noteq> x1 * y3 \<and> x1 * x3 + y1 * y3 \<noteq> 0 \<Longrightarrow>
    x1 * (x1 * (x2 * (x3 * (x3 * (x3 * (y1 * (y3 * y3))))))) +
    (x1 * (x2 * (x3 * (x3 * (y1 * (y1 * (y3 * (y3 * y3))))))) +
     (x1 * (x1 * (x1 * (x2 * (x2 * (x2 * (x3 * (x3 * (y1 * (y1 * y3))))))))) +
      x1 * (x1 * (x2 * (x2 * (x2 * (x3 * (y1 * (y1 * (y1 * (y3 * y3))))))))))) =
    x1 * (x1 * (x1 * (x2 * (x3 * (x3 * (y1 * (y1 * y3))))))) +
    (x1 * (x1 * (x2 * (x3 * (y1 * (y1 * (y1 * (y3 * y3))))))) +
     (x1 * (x1 * (x2 * (x2 * (x2 * (x3 * (x3 * (x3 * (y1 * (y3 * y3))))))))) +
      x1 * (x2 * (x2 * (x2 * (x3 * (x3 * (y1 * (y1 * (y3 * (y3 * y3)))))))))))"
proof -
    assume a1: "x2 * x2 = 1"
    have f2: "\<forall>r ra. (ra::real) * r = r * ra"
      by auto
    have "\<forall>r. x2 * (r * x2) = r"
      using a1 by auto
    then have "x1 * (x1 * (y1 * (x3 * (x3 * (x3 * (y3 * (x2 * y3))))))) + (x1 * (y1 * (y1 * (x3 * (x3 * (y3 * (y3 * (x2 * y3))))))) + (x1 * (x1 * (x1 * (y1 * (y1 * (x3 * (x3 * (x2 * (x2 * (x2 * y3))))))))) + x1 * (x1 * (y1 * (y1 * (y1 * (x3 * (y3 * (x2 * (x2 * (x2 * y3))))))))))) = x1 * (x1 * (x1 * (y1 * (y1 * (x3 * (x3 * (x2 * y3))))))) + (x1 * (x1 * (y1 * (y1 * (y1 * (x3 * (y3 * (x2 * y3))))))) + (x1 * (x1 * (y1 * (x3 * (x3 * (x3 * (y3 * (x2 * (x2 * (x2 * y3))))))))) + x1 * (y1 * (y1 * (x3 * (x3 * (y3 * (y3 * (x2 * (x2 * (x2 * y3)))))))))))"
      using f2 
      apply(simp add: algebra_simps) 
      by (simp add: a1 semiring_normalization_rules(18))
then show "x1 * (x1 * (x2 * (x3 * (x3 * (x3 * (y1 * (y3 * y3))))))) + (x1 * (x2 * (x3 * (x3 * (y1 * (y1 * (y3 * (y3 * y3))))))) + (x1 * (x1 * (x1 * (x2 * (x2 * (x2 * (x3 * (x3 * (y1 * (y1 * y3))))))))) + x1 * (x1 * (x2 * (x2 * (x2 * (x3 * (y1 * (y1 * (y1 * (y3 * y3))))))))))) = x1 * (x1 * (x1 * (x2 * (x3 * (x3 * (y1 * (y1 * y3))))))) + (x1 * (x1 * (x2 * (x3 * (y1 * (y1 * (y1 * (y3 * y3))))))) + (x1 * (x1 * (x2 * (x2 * (x2 * (x3 * (x3 * (x3 * (y1 * (y3 * y3))))))))) + x1 * (x2 * (x2 * (x2 * (x3 * (x3 * (y1 * (y1 * (y3 * (y3 * y3)))))))))))"
  by (simp add: mult.left_commute)
qed

lemma ext_add_assoc: 
  assumes "z1' = (x1',y1')" "z3' = (x3',y3')"
  assumes "z1' = ext_add (x1,y1) (x2,y2)" "z3' = ext_add (x2,y2) (x3,y3)"
  assumes "delta_x x1 y1 x2 y2 \<noteq> 0" "delta_y x1 y1 x2 y2 \<noteq> 0"
          "delta_x x2 y2 x3 y3 \<noteq> 0" "delta_y x2 y2 x3 y3 \<noteq> 0"
          "delta_x x1' y1' x3 y3 \<noteq> 0" "delta_y x1' y1' x3 y3 \<noteq> 0"
          "delta_x x1 y1 x3' y3' \<noteq> 0" "delta_y x1 y1 x3' y3' \<noteq> 0"
  assumes "e' x1 y1 = 0" "e' x2 y2 = 0" "e' x3 y3 = 0" 
  shows "ext_add (ext_add (x1,y1) (x2,y2)) (x3,y3) = ext_add (x1,y1) (ext_add (x2,y2) (x3,y3))" 
proof -
  define e1 where "e1 = e' x1 y1"
  define e2 where "e2 = e' x2 y2"
  define e3 where "e3 = e' x3 y3"
  define Delta\<^sub>x where "Delta\<^sub>x = 
   (delta_x x1' y1' x3 y3)*(delta_x x1 y1 x3' y3')*
   (delta' x1 y1 x2 y2)*(delta' x2 y2 x3 y3)" 
  define Delta\<^sub>y where "Delta\<^sub>y =
   (delta_y x1' y1' x3 y3)*(delta_y x1 y1 x3' y3')*
   (delta' x1 y1 x2 y2)*(delta' x2 y2 x3 y3)" 
  define g\<^sub>x :: real where "g\<^sub>x = fst(ext_add z1' (x3,y3)) - fst(ext_add (x1,y1) z3')"
  define g\<^sub>y where "g\<^sub>y = snd(ext_add z1' (x3,y3)) - snd(ext_add (x1,y1) z3')"
  define gxpoly where "gxpoly = g\<^sub>x * Delta\<^sub>x"
  define gypoly where "gypoly = g\<^sub>y * Delta\<^sub>y"

  define gxpoly_expr where "gxpoly_expr = 
    ((x1 * y1 - x2 * y2) * (x1 * y1 + x2 * y2) -
     x3 * y3 * ((x2 * y1 - x1 * y2) * (x1 * x2 + y1 * y2))) *
    ((x2 * y2 - x3 * y3) * y1 * (x2 * x3 + y2 * y3) -
     x1 * (x2 * y2 + x3 * y3) * (x3 * y2 - x2 * y3)) -
    (x1 * y1 * ((x3 * y2 - x2 * y3) * (x2 * x3 + y2 * y3)) -
     (x2 * y2 - x3 * y3) * (x2 * y2 + x3 * y3)) *
    (x3 * (x1 * y1 + x2 * y2) * (x2 * y1 - x1 * y2) -
     (x1 * y1 - x2 * y2) * y3 * (x1 * x2 + y1 * y2))"
  define gypoly_expr where "gypoly_expr = 
   ((x1 * y1 - x2 * y2) * (x1 * y1 + x2 * y2) +
     x3 * y3 * ((x2 * y1 - x1 * y2) * (x1 * x2 + y1 * y2))) *
    (x1 * (x2 * y2 - x3 * y3) * (x2 * x3 + y2 * y3) +
     y1 * (x2 * y2 + x3 * y3) * (x3 * y2 - x2 * y3)) -
    (x1 * y1 * ((x3 * y2 - x2 * y3) * (x2 * x3 + y2 * y3)) +
     (x2 * y2 - x3 * y3) * (x2 * y2 + x3 * y3)) *
    ((x1 * y1 - x2 * y2) * x3 * (x1 * x2 + y1 * y2) +
     (x1 * y1 + x2 * y2) * y3 * (x2 * y1 - x1 * y2))"

  have x1'_expr: "x1' = (x1 * y1 - x2 * y2) / (x2 * y1 - x1 * y2)"
    using assms(1,3) by simp
  have y1'_expr: "y1' = (x1 * y1 + x2 * y2) / (x1 * x2 + y1 * y2)"
    using assms(1,3) by simp
  have x3'_expr: "x3' = (x2 * y2 - x3 * y3) / (x3 * y2 - x2 * y3)"
    using assms(2,4) by simp
  have y3'_expr: "y3' = (x2 * y2 + x3 * y3) / (x2 * x3 + y2 * y3)"
    using assms(2,4) by simp
  
  have non_unfolded_adds:
      "delta' x1 y1 x2 y2 \<noteq> 0" using delta'_def assms(5,6) by auto
  
  have gx_div: "\<exists> r1 r2 r3. gxpoly_expr = r1 * e1 + r2 * e2 + r3 * e3"
    unfolding gxpoly_expr_def e1_def e2_def e3_def e'_def by algebra

  have gy_div: "\<exists> r1 r2 r3. gypoly_expr = r1 * e1 + r2 * e2 + r3 * e3"
    unfolding gypoly_expr_def e1_def e2_def e3_def e'_def 
    by algebra

  have simp1gx: "
    (x1' * y1' - x3 * y3) * delta_x x1 y1 x3' y3' * (delta' x1 y1 x2 y2 * delta' x2 y2 x3 y3) = 
     ((x1 * y1 - x2 * y2) * (x1 * y1 + x2 * y2) -
     x3 * y3 * (delta_x x1 y1 x2 y2 * delta_y x1 y1 x2 y2)) *
    ((x2 * y2 - x3 * y3) * y1 * delta_y x2 y2 x3 y3 -
     x1 * (x2 * y2 + x3 * y3) * delta_x x2 y2 x3 y3)
  "
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply(subst (2 3 5) delta_x_def[symmetric])
    apply(subst (2 4) delta_y_def[symmetric])
    apply(subst (2 4) delta_x_def)
    unfolding delta'_def
    by(simp add: divide_simps assms(5-8))

  have simp2gx:
    "(x1 * y1 - x3' * y3') * delta_x x1' y1' x3 y3 * (delta' x1 y1 x2 y2 * delta' x2 y2 x3 y3) = 
     (x1 * y1 * (delta_x x2 y2 x3 y3 * delta_y x2 y2 x3 y3) -
     (x2 * y2 - x3 * y3) * (x2 * y2 + x3 * y3)) *
    (x3 * (x1 * y1 + x2 * y2) * delta_x x1 y1 x2 y2 -
     (x1 * y1 - x2 * y2) * y3 * delta_y x1 y1 x2 y2)"
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply(subst (3 5) delta_x_def[symmetric])    
    apply(subst (2 4) delta_y_def[symmetric])    
    apply(subst (3) delta_x_def)
    unfolding delta'_def
    by(simp add: divide_simps assms(5-8))

  have "gxpoly = gxpoly_expr"
    unfolding gxpoly_def g\<^sub>x_def Delta\<^sub>x_def 
    apply(simp add: assms(1,2))
    apply(subst (2 4) delta_x_def[symmetric])+
    apply(simp add: divide_simps assms(9,11))
    apply(subst (3) left_diff_distrib)
    apply(simp add: simp1gx simp2gx)
    unfolding delta_x_def delta_y_def delta'_def 
    unfolding gxpoly_expr_def by blast

  obtain r1x r2x r3x where "gxpoly = r1x * e1 + r2x * e2 + r3x * e3"
    using \<open>gxpoly = gxpoly_expr\<close> gx_div by auto
  then have "gxpoly = 0" 
    using e1_def assms(13-15) e2_def e3_def by auto
  have "Delta\<^sub>x \<noteq> 0" 
    using Delta\<^sub>x_def delta'_def assms(7-11) non_unfolded_adds by auto
  then have "g\<^sub>x = 0" 
    using \<open>gxpoly = 0\<close> gxpoly_def by auto

  have simp1gy: "delta_y x1' x3 y1' y3 * delta_y x1 y1 x3' y3' * (delta' x1 y1 x2 y2 * delta' x2 y2 x3 y3) = 
     ((x1 * y1 - x2 * y2) * (x1 * y1 + x2 * y2) +
     x3 * y3 * (delta_x x1 y1 x2 y2 * delta_y x1 y1 x2 y2)) *
    (x1 * (x2 * y2 - x3 * y3) * delta_y x2 y2 x3 y3 +
     y1 * (x2 * y2 + x3 * y3) * delta_x x2 y2 x3 y3)"
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply(subst (2 4) delta_x_def[symmetric])
    apply(subst (2 4) delta_y_def[symmetric])
    apply(subst (2 3) delta_y_def)
    unfolding delta'_def
    by(simp add: divide_simps assms(5-8))

  have simp2gy: "delta_y x1 x3' y1 y3' * delta_y x1' y1' x3 y3 * (delta' x1 y1 x2 y2 * delta' x2 y2 x3 y3) = 
     (x1 * y1 * (delta_x x2 y2 x3 y3 * delta_y x2 y2 x3 y3) +
     (x2 * y2 - x3 * y3) * (x2 * y2 + x3 * y3)) *
    ((x1 * y1 - x2 * y2) * x3 * delta_y x1 y1 x2 y2 +
     (x1 * y1 + x2 * y2) * y3 * delta_x x1 y1 x2 y2)"
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply(subst (2 4) delta_x_def[symmetric])
    apply(subst (2 4) delta_y_def[symmetric])
    apply(subst (1 4) delta_y_def)
    unfolding delta'_def
    by(simp add: divide_simps assms(5-8))

  have "gypoly = gypoly_expr"
    unfolding gypoly_def g\<^sub>y_def Delta\<^sub>y_def 
    apply(simp add: assms(1,2))
    apply(subst delta_y_def[symmetric])+
    apply(simp add: divide_simps assms(10,12))
    apply(subst left_diff_distrib)
    apply(simp add: simp1gy simp2gy)
    unfolding delta_x_def delta_y_def 
    unfolding gypoly_expr_def by blast

  obtain r1y r2y r3y where "gypoly = r1y * e1 + r2y * e2 + r3y * e3"
    using \<open>gypoly = gypoly_expr\<close> gy_div by auto
  then have "gypoly = 0" 
    using e1_def assms(13-15) e2_def e3_def by auto
  have "Delta\<^sub>y \<noteq> 0" 
    using Delta\<^sub>y_def delta'_def assms(7-12) non_unfolded_adds by auto
  then have "g\<^sub>y = 0" 
    using \<open>gypoly = 0\<close> gypoly_def by auto

  show ?thesis 
    using \<open>g\<^sub>y = 0\<close> \<open>g\<^sub>x = 0\<close> 
    unfolding g\<^sub>x_def g\<^sub>y_def assms(3,4)
    by (simp add: prod_eq_iff)
qed

lemma ext_add_assoc_1: 
  assumes "z1' = (x1',y1')" "z3' = (x3',y3')"
  assumes "z1' = add (x1,y1) (x2,y2)" "z3' = ext_add (x2,y2) (x3,y3)"
  assumes "delta_minus x1 y1 x2 y2 \<noteq> 0" "delta_plus x1 y1 x2 y2 \<noteq> 0"
          "delta_x x2 y2 x3 y3 \<noteq> 0" "delta_y x2 y2 x3 y3 \<noteq> 0"
          "delta_x x1' y1' x3 y3 \<noteq> 0" "delta_y x1' y1' x3 y3 \<noteq> 0"
          "delta_x x1 y1 x3' y3' \<noteq> 0" "delta_y x1 y1 x3' y3' \<noteq> 0"
  assumes "e' x1 y1 = 0" "e' x2 y2 = 0" "e' x3 y3 = 0" 
  shows "ext_add (add (x1,y1) (x2,y2)) (x3,y3) = ext_add (x1,y1) (ext_add (x2,y2) (x3,y3))" 
proof -
  define e1 where "e1 = e' x1 y1"
  define e2 where "e2 = e' x2 y2"
  define e3 where "e3 = e' x3 y3"
  define Delta\<^sub>x where "Delta\<^sub>x = 
   (delta_x x1' y1' x3 y3)*(delta_x x1 y1 x3' y3')*
   (delta x1 y1 x2 y2)*(delta' x2 y2 x3 y3)" 
  define Delta\<^sub>y where "Delta\<^sub>y =
   (delta_y x1' y1' x3 y3)*(delta_y x1 y1 x3' y3')*
   (delta x1 y1 x2 y2)*(delta' x2 y2 x3 y3)" 
  define g\<^sub>x :: real where "g\<^sub>x = fst(ext_add z1' (x3,y3)) - fst(ext_add (x1,y1) z3')"
  define g\<^sub>y where "g\<^sub>y = snd(ext_add z1' (x3,y3)) - snd(ext_add (x1,y1) z3')"

  have x1'_expr: "x1' = (x1 * x2 - c * y1 * y2) / (1 - d * x1 * y1 * x2 * y2)" using assms(1,3) by simp
  have y1'_expr: "y1' = (x1 * y2 + y1 * x2) / (1 + d * x1 * y1 * x2 * y2)" using assms(1,3) by simp
  have x3'_expr: "x3' = (x2 * y2 - x3 * y3) / (x3 * y2 - x2 * y3)" using assms(2,4) by simp
  have y3'_expr: "y3' = (x2 * y2 + x3 * y3) / (x2 * x3 + y2 * y3)" using assms(2,4) by simp
  
  have non_unfolded_adds:
      "delta x1 y1 x2 y2 \<noteq> 0" using delta_def assms(5,6) by auto

  have simp1gx: "
    (x1' * y1' - x3 * y3) * delta_x x1 y1 x3' y3' * (delta x1 y1 x2 y2 * delta' x2 y2 x3 y3) = 
    ((x1 * x2 - c * y1 * y2) * (x1 * y2 + y1 * x2) -
     x3 * y3 * (delta_minus x1 y1 x2 y2 * delta_plus x1 y1 x2 y2)) *
    ((x2 * y2 - x3 * y3) * y1 * delta_y x2 y2 x3 y3 -
     x1 * (x2 * y2 + x3 * y3) * delta_x x2 y2 x3 y3)
  "
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply(subst delta_plus_def[symmetric])
    apply(subst delta_minus_def[symmetric])
    apply(subst (4) delta_x_def[symmetric])
    apply(subst (3) delta_y_def[symmetric])
    apply(subst (2) delta_x_def)
    unfolding delta'_def delta_def
    by(simp add: divide_simps assms(5-8))

  have simp2gx:
    "(x1 * y1 - x3' * y3') * delta_x x1' y1' x3 y3 * (delta x1 y1 x2 y2 * delta' x2 y2 x3 y3) =
      (x1 * y1 * (delta_x x2 y2 x3 y3 * delta_y x2 y2 x3 y3) -
     (x2 * y2 - x3 * y3) * (x2 * y2 + x3 * y3)) *
    (x3 * (x1 * y2 + y1 * x2) * delta_minus x1 y1 x2 y2 -
     (x1 * x2 - c * y1 * y2) * y3 * delta_plus x1 y1 x2 y2)"
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply(subst delta_plus_def[symmetric])
    apply(subst delta_minus_def[symmetric])
    apply(subst (3) delta_x_def[symmetric])    
    apply(subst (2) delta_y_def[symmetric])    
    apply(subst (2) delta_x_def)
    unfolding delta'_def delta_def
    by(simp add: divide_simps assms(5-8))

  have "\<exists> r1 r2 r3. g\<^sub>x * Delta\<^sub>x = r1 * e1 + r2 * e2 + r3 * e3"
    unfolding g\<^sub>x_def Delta\<^sub>x_def 
    apply(simp add: assms(1,2))
    apply(subst (2 4) delta_x_def[symmetric])
    apply(simp add: divide_simps assms(9,11))
    apply(subst (3) left_diff_distrib)
    apply(simp add: simp1gx simp2gx)
    unfolding delta_x_def delta_y_def delta'_def delta_plus_def delta_minus_def delta_def
              e1_def e2_def e3_def e'_def   
    by(simp add:  t_expr c_eq_1,algebra) 
  then have "g\<^sub>x * Delta\<^sub>x = 0" "Delta\<^sub>x \<noteq> 0" 
    using e1_def assms(13-15) e2_def e3_def apply auto
    using Delta\<^sub>x_def delta'_def assms(7-11) non_unfolded_adds by auto
  then have "g\<^sub>x = 0" by auto

  have simp1gy: " delta_y x1' x3 y1' y3 * delta_y x1 y1 x3' y3' * (delta x1 y1 x2 y2 * delta' x2 y2 x3 y3) = 
     ((x1 * x2 - c * y1 * y2) * (x1 * y2 + y1 * x2) +
     x3 * y3 * (delta_minus x1 y1 x2 y2 * delta_plus x1 y1 x2 y2)) *
    (x1 * (x2 * y2 - x3 * y3) * delta_y x2 y2 x3 y3 +
     y1 * (x2 * y2 + x3 * y3) * delta_x x2 y2 x3 y3)"
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply(subst delta_plus_def[symmetric])
    apply(subst delta_minus_def[symmetric])
    apply(subst (3) delta_x_def[symmetric])
    apply(subst (3) delta_y_def[symmetric])
    apply(subst (1 2) delta_y_def)
    unfolding delta'_def delta_def
    by(simp add: divide_simps assms(5-8))
   
  have simp2gy: " delta_y x1 x3' y1 y3' * delta_y x1' y1' x3 y3 * (delta x1 y1 x2 y2 * delta' x2 y2 x3 y3) = 
    (x1 * y1 * (delta_x x2 y2 x3 y3 * delta_y x2 y2 x3 y3) +
     (x2 * y2 - x3 * y3) * (x2 * y2 + x3 * y3)) *
    ((x1 * x2 - c * y1 * y2) * x3 * delta_plus x1 y1 x2 y2 +
     (x1 * y2 + y1 * x2) * y3 * delta_minus x1 y1 x2 y2)"
    apply((subst x1'_expr)+, (subst y1'_expr)+,(subst x3'_expr)+,(subst y3'_expr)+)
    apply(subst delta_minus_def[symmetric])
    apply(subst delta_plus_def[symmetric])
    apply(subst (2) delta_x_def[symmetric])
    apply(subst (2) delta_y_def[symmetric])
    apply(subst (1 3) delta_y_def)
    unfolding delta'_def delta_def
    by(simp add: divide_simps assms(5-8))
    
  have "\<exists> r1 r2 r3. g\<^sub>y * Delta\<^sub>y = r1 * e1 + r2 * e2 + r3 * e3"
    unfolding g\<^sub>y_def Delta\<^sub>y_def 
    apply(simp add: assms(1,2))
    apply(subst delta_y_def[symmetric])+
    apply(simp add: divide_simps assms(10,12))
    apply(subst left_diff_distrib)
    apply(simp add: simp1gy simp2gy)
    unfolding delta_x_def delta_y_def delta_minus_def delta_plus_def
              e1_def e2_def e3_def e'_def
    by(simp add: c_eq_1 t_expr,algebra) 

  then have "g\<^sub>y * Delta\<^sub>y = 0" "Delta\<^sub>y \<noteq> 0" 
    using e1_def assms(13-15) e2_def e3_def apply auto
    using Delta\<^sub>y_def delta'_def assms(7-12) non_unfolded_adds by auto
  then have "g\<^sub>y = 0" by auto

  show ?thesis 
    using \<open>g\<^sub>y = 0\<close> \<open>g\<^sub>x = 0\<close> unfolding g\<^sub>x_def g\<^sub>y_def assms(3,4) by (simp add: prod_eq_iff)
qed

lemma 
  assumes "gluing `` {((x1,y1),0)} \<in> e_proj" "gluing `` {((x2,y2),0)} \<in> e_proj" "gluing `` {(i (x2,y2),0)} \<in> e_proj"
  shows "proj_addition (proj_addition (gluing `` {((x1,y1),0)}) (gluing `` {((x2,y2),0)})) (gluing `` {(i (x2,y2),0)}) = 
         gluing `` {((x1,y1),0)}"
proof -
  have in_aff: "(x1,y1) \<in> e_aff" "(x2,y2) \<in> e_aff" "i (x2,y2) \<in> e_aff" 
    using assms(1,2,3) e_class by auto
  then consider (1) "(x1,y1) \<in> e_circ" "(\<exists>g\<in>symmetries. (x2,y2) = (g \<circ> i) (x1,y1))" 
                    "((x1,y1), (x2,y2)) \<notin> e_aff_0" "((x1,y1), (x2,y2)) \<notin> e_aff_1" |
                (2) "((x1,y1), (x2,y2)) \<in> e_aff_0" |
                (3) "((x1,y1), (x2,y2)) \<in> e_aff_1" using dichotomy_1 by blast
  then show ?thesis
  proof(cases)
    case 1
    from 1 have x1nz: "x1 \<noteq> 0" "y1 \<noteq> 0" unfolding e_circ_def by(simp)+
    then have g1_expr: "gluing `` {((x1,y1),0)} = {((x1,y1),0), (\<tau> (x1,y1),1)}"
      using e_proj_elim_2 \<open>(x1,y1) \<in> e_aff\<close> gluing_class by force    
    from 1 obtain g where g_expr: "g \<in> symmetries" "(x2,y2) = (g \<circ> i) (x1,y1)" by blast
    then have x2nz: "x2 \<noteq> 0" "y2 \<noteq> 0"
      using x1nz unfolding symmetries_def apply(simp_all)
      by(safe,(simp add: t_nz)+)
    then have g2_expr: "gluing `` {((x2,y2),0)} = {((x2,y2),0), (\<tau> (x2,y2),1)}"
      using e_proj_elim_2 \<open>(x2,y2) \<in> e_aff\<close> gluing_class by force
    have g2'_expr: "gluing `` {(i (x2,y2),0)} = {(i (x2,y2),0), (\<tau> (i (x2,y2)),1)}"
      using e_proj_elim_2 \<open>i (x2,y2) \<in> e_aff\<close> gluing_class assms(3) 
      by (simp add: \<open>x2 \<noteq> 0\<close> \<open>y2 \<noteq> 0\<close>)
    have taus: "\<tau> (x2,y2) \<in> e_aff" "\<tau> (i (x2,y2)) \<in> e_aff" "fst (\<tau> (x2,y2)) \<noteq> 0" "snd (\<tau> (x2,y2)) \<noteq> 0" 
      apply(metis \<open>x2 \<noteq> 0\<close> \<open>y2 \<noteq> 0\<close> assms(2) e_class gluing_inv)
      apply (metis \<open>x2 \<noteq> 0\<close> \<open>y2 \<noteq> 0\<close> add.inverse_inverse add.inverse_neutral assms(3) e_class gluing_inv i.simps)
      by(simp add: \<open>x2 \<noteq> 0\<close> \<open>y2 \<noteq> 0\<close> t_nz)+
      
    consider (a) "p_delta ((x1, y1), 0) (\<tau> (x2, y2), 1) \<noteq> 0" |
             (b) "p_delta' ((x1, y1), 0) (\<tau> (x2, y2), 1) \<noteq> 0"
                 "p_delta ((x1, y1), 0) (\<tau> (x2, y2), 1) = 0" |
             (c) "p_delta' ((x1, y1), 0) (\<tau> (x2, y2), 1) = 0"
                 "p_delta ((x1, y1), 0) (\<tau> (x2, y2), 1) = 0" by blast
    then show ?thesis 
    proof(cases,simp_all add: g1_expr g2_expr g2'_expr del: \<tau>.simps i.simps)
      case a

      have fs: "proj_addition {((x1, y1), 0), (\<tau> (x1, y1), 1)} {((x2, y2), 0), (\<tau> (x2, y2), 1)} =
             {(add (x1, y1) (\<tau> (x2, y2)), 1)}"
        by (metis (no_types, lifting) "1"(1) \<open>(x2, y2) \<in> e_aff\<close> \<open>x2 \<noteq> 0\<close> \<open>y2 \<noteq> 0\<close> a add_cancel_right_left assms(1) e_proj_elim_2 g1_expr g_expr(1) g_expr(2) proj_add_eqs_4(1) projective_curve.proj_addition_def projective_curve_axioms)
      have nz: "fst (add (x1, y1) (\<tau> (x2, y2))) = 0 \<or> snd (add (x1, y1) (\<tau> (x2, y2))) = 0"
           "fst (i (x2,y2)) \<noteq> 0" "snd (i (x2,y2)) \<noteq> 0"
         apply(smt \<open>x2 \<noteq> 0\<close> \<open>y2 \<noteq> 0\<close> add_cancel_right_left assms(1) e_class e_proj_elim_2 eq_class_simp fs g1_expr in_aff(2) insert_not_empty prod.collapse proj_addition_def projective_curve.e_proj_elim_1 projective_curve_axioms singleton_quotient the_elem_eq well_defined_4)
         using \<open>x2 \<noteq> 0\<close> \<open>y2 \<noteq> 0\<close> by auto 
      then have circ_cond: "(add (x1, y1) (\<tau> (x2, y2))) \<notin> e_circ"
        using e_circ_def by auto
      have aff_cond: "add (x1, y1) (\<tau> (x2, y2)) \<in> e_aff" "i (x2, y2) \<in> e_aff"
        apply(metis \<open>x2 \<noteq> 0\<close> \<open>y2 \<noteq> 0\<close> add_cancel_right_left assms(1) e_class e_proj_elim_2 eq_class_simp fs g1_expr in_aff(2) insert_not_empty proj_addition_def singleton_quotient the_elem_eq well_defined_4)
        using in_aff(3) by auto
      have delta_cond: "delta (fst (add (x1, y1) (\<tau> (x2, y2)))) (snd (add (x1, y1) (\<tau> (x2, y2))))
                  (fst (i (x2, y2))) (snd (i (x2, y2))) \<noteq> 0"
        using \<open>fst (add (x1, y1) (\<tau> (x2, y2))) = 0 \<or> snd (add (x1, y1) (\<tau> (x2, y2))) = 0\<close> c_eq_1 mult_1 delta_def delta_minus_def delta_plus_def by auto
      have e_0_cond: "(add (x1, y1) (\<tau> (x2, y2)),i (x2, y2)) \<in> e_aff_0"
        unfolding e_aff_0_def using aff_cond delta_cond by auto
      have proj_cond: "{(add (x1, y1) (\<tau> (x2, y2)), 1)} \<in> e_proj" "{(i (x2, y2), 0), (\<tau> (i (x2, y2)), 1)} \<in> e_proj"
        using \<open>fst (add (x1, y1) (\<tau> (x2, y2))) = 0 \<or> snd (add (x1, y1) (\<tau> (x2, y2))) = 0\<close> aff_cond(1) e_proj_elim_1 apply force
        using e_proj_elim_2 assms(3) g2'_expr by argo

      have add_assoc: "add (add (x1, y1) (\<tau> (x2, y2))) (\<tau> (i (x2, y2))) = (x1,y1)"
        apply(subst (3) prod.collapse[symmetric])
        apply(subst (9) prod.collapse[symmetric])
        apply(subst add_add_assoc)
        apply (simp add: in_aff(1))
        using taus(1) apply force
        apply(simp add: taus del: \<tau>.simps i.simps)
        using a p_delta_def apply simp
           defer 1
        unfolding delta_def delta_plus_def delta_minus_def 
        using add.commute add_cancel_right_left c_eq_1 fst_def i.simps nz(1) apply force
        apply simp 
        using delta_plus_self e_aff_def e_e'_iff inverse taus(2) apply fastforce
        using g_expr a unfolding symmetries_def p_delta_def 
                                 delta_def delta_plus_def delta_minus_def   
           apply(simp) 
           apply(safe)      
        apply(simp_all add: t_nz)
        by argo+

      have proj_simp: "proj_addition {(add (x1, y1) (\<tau> (x2, y2)), 1)} {(i (x2, y2), 0), (\<tau> (i (x2, y2)), 1)} =
            {(add (add (x1, y1) (\<tau> (x2, y2))) (\<tau> (i (x2, y2))), 0), (\<tau> (add (add (x1, y1) (\<tau> (x2, y2))) (\<tau> (i (x2, y2)))), 1)}"
      proof(cases "fst (add (x1, y1) (\<tau> (x2, y2))) = 0")
        case True
        show ?thesis 
          unfolding proj_addition_def
          apply(subst proj_add_eqs_2(4)) 
          apply force 
                    apply auto[1]
          using aff_cond circ_cond proj_cond e_0_cond x2nz apply simp_all

          apply(simp add: c_eq_1 divide_simps t_nz power2_eq_square[symmetric] algebra_simps t_expr d_nz)
           using g_expr a unfolding symmetries_def p_delta_def 
                                 delta_def delta_plus_def delta_minus_def   
           apply(simp)
           apply(safe)
           unfolding e_aff_def e'_def
           apply(simp add: t_nz x1nz)
           apply(simp add: divide_simps t_nz x1nz algebra_simps) 
          
          sorry
      next
        case False
        then have hyp: "snd (add (x1, y1) (\<tau> (x2, y2))) = 0" using nz(1) by blast
        then show ?thesis 
          using proj_add_eqs_2(5)[OF _ _ _ _ _ _ _ _ nz(2-3) hyp] aff_cond circ_cond proj_cond e_0_cond
          sorry
      qed

      show "proj_addition (proj_addition {((x1, y1), 0), (\<tau> (x1, y1), 1)} {((x2, y2), 0), (\<tau> (x2, y2), 1)})
                  {(i (x2, y2), 0), (\<tau> (i (x2, y2)), 1)} = {((x1, y1), 0), (\<tau> (x1, y1), 1)}"
        apply(simp add: fs del: \<tau>.simps i.simps)
        by(simp add: proj_simp add_assoc del: \<tau>.simps i.simps)
    next
      case b
      thm proj_add_eqs_2(9) proj_add_eqs_2(10)
      then have "False" sorry
      then show "proj_addition (proj_addition {((x1, y1), 0), (\<tau> (x1, y1), 1)} {((x2, y2), 0), (\<tau> (x2, y2), 1)}) {(i (x2, y2), 0), (\<tau> (i (x2, y2)), 1)} =
                {((x1, y1), 0), (\<tau> (x1, y1), 1)}" by argo
    next
      case c
      
      then show "proj_addition (proj_addition {((x1, y1), 0), (\<tau> (x1, y1), 1)} {((x2, y2), 0), (\<tau> (x2, y2), 1)}) {(i (x2, y2), 0), (\<tau> (i (x2, y2)), 1)} =
                {((x1, y1), 0), (\<tau> (x1, y1), 1)} " sorry
    qed
  next
    case 2
    then show ?thesis sorry
  next
    case 3
    then show ?thesis sorry
  qed

  
qed
  

lemma projective_group_law:
  shows "comm_group \<lparr>carrier = e_proj, mult = proj_addition, one = gluing `` {((1,0),0)}\<rparr>" 
proof(unfold_locales,simp_all)
  show one_in: "gluing `` {((1, 0), 0)} \<in> e_proj"
    unfolding e_proj_def 
    apply(rule quotientI)
    unfolding e_aff_bit_def Bits_def e_aff_def e'_def 
    apply(simp) 
    using zero_bit_def by blast

  show comm: "\<And>x y. x \<in> e_proj \<Longrightarrow>
           y \<in> e_proj \<Longrightarrow> proj_addition x y = proj_addition y x"
    unfolding proj_addition_def using proj_add_class_comm by auto
  
  show id_1: "\<And>x. x \<in> e_proj \<Longrightarrow> proj_addition (gluing `` {((1, 0), 0)}) x = x"
    unfolding proj_addition_def using proj_add_class_identity by simp
  
  show id_2: "\<And>x. x \<in> e_proj \<Longrightarrow> proj_addition x (gluing `` {((1, 0), 0)}) = x"
     using comm id_1 one_in by simp

  show "e_proj \<subseteq> Units \<lparr>carrier = e_proj, mult = proj_addition, one = gluing `` {((1, 0), 0)}\<rparr>"
    unfolding Units_def 
  proof(simp,standard)
    fix x
    assume as: "x \<in> e_proj"
    then obtain y where "y \<in> e_proj" "proj_add_class x y = {gluing `` {((1, 0), 0)}}" 
      using proj_add_class_inv[OF as] by auto
    then have "proj_add_class y x = {gluing `` {((1, 0), 0)}}" 
      using proj_add_class_comm by auto
    then show " x \<in> {y \<in> e_proj.
               \<exists>x\<in>e_proj.
                  proj_addition x y = gluing `` {((1, 0), 0)} \<and>
                  proj_addition y x = gluing `` {((1, 0), 0)}}"
      apply(simp add: as) 
      by (metis \<open>proj_add_class x y = {gluing `` {((1, 0), 0)}}\<close> \<open>y \<in> e_proj\<close> projective_curve.proj_addition_def projective_curve_axioms the_elem_eq)
  qed

  show "\<And>x y. x \<in> e_proj \<Longrightarrow> y \<in> e_proj \<Longrightarrow> proj_addition x y \<in> e_proj"
    using well_defined unfolding proj_addition_def by blast

  show "\<And>x y z.
       x \<in> e_proj \<Longrightarrow>
       y \<in> e_proj \<Longrightarrow>
       z \<in> e_proj \<Longrightarrow> proj_addition (proj_addition x y) z = proj_addition x (proj_addition y z)"

    sorry
qed

end

end