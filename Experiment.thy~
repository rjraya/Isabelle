theory Scratch 
  imports FOL
begin

ML_val \<open>Thm.lift_rule @{cterm "A \<and> B \<Longrightarrow> C \<longrightarrow> A \<and> C"} @{thm impI}\<close>
thm disjI1
lemma "\<And> z. G(z) \<or> H(z)"
  thm disjI1
  ML_val \<open>Thm.lift_rule (Thm.cprem_of (#goal @{Isar.goal}) 1) @{thm disjI1}\<close>
  sorry

lemma metar:
  shows "(\<And> x. PROP P x)"
  by(rule \<open>\<And>x. PROP P x\<close>)

lemma all_elim: "ALL z. B z \<Longrightarrow> (B b \<Longrightarrow> C) \<Longrightarrow> C" by blast

lemma "EX y. ALL x. P y --> P x"
  apply (rule exCI)
  apply (rule allI)
  apply (rule impI)
  ML_val \<open>Thm.cterm_of (Thm.prop_of (#goal @{Isar.goal}))\<close>
  ML_val \<open>Thm.lift_rule (Thm.term_of (#goal @{Isar.goal}) 1) @{thm all_elim}\<close>

  ML_val \<open>Thm.lift_rule (Thm.cprem_of (#goal @{Isar.goal}) 1) @{thm all_elim}\<close>
  apply (erule allE)
  apply (erule allI [THEN [2] swap])
  apply (rule impI)
  apply (erule notE)
  apply assumption
  done

end

term "A \<Longrightarrow> B"
term "(A \<Longrightarrow> B) \<Longrightarrow> (A \<longrightarrow> B)"
lemma my:
  shows "(A \<Longrightarrow> B) \<Longrightarrow>   (A \<longrightarrow> B)"
  by simp
term "Trueprop (A \<and> B)" 
ML \<open> 
Thm.lift_rule @{cterm "Trueprop (A1 \<and> B1)"} @{thm my}
\<close>

end