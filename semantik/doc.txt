(*lemma lib_theorem: "termip step s ? terminating step s"
  apply(rule iffI)
  apply (smt accp_induct conversep.intros terminating.simps)
  apply(induction rule: terminating.induct)
  by (simp add: accp.intros)

lemma set_version: "termip step s ? s ? termi {(x,y).step x y}"
  by (simp add: accp_eq_acc converse_unfold)

lemma multi_step: "terminating step s ? (? s'. step?+?+ s s' ? terminating step s')"
  by (metis accp_downwards lib_theorem reflclp_tranclp rtranclp_converseI 
            sup2CI terminating.intros tranclp.r_into_trancl)

lemma first_step: "terminating step s ?
       (? x. step?*?* s x) ?
       wfP (step¯¯)"
  by (meson accp_downwards lib_theorem rtranclp_converseI wfP_accp_iff)

lemma second_step:  "terminating step s ?
       (? x. step?*?* s x) ?
       (?Q x. x ? Q ? (?z?Q. ?y. step z y ? y ? Q))"
proof -
  assume 0: "terminating step s"
  assume 1: "(? x. step?*?* s x)"
  from 0 1 have "wfP (step¯¯)" by (meson first_step)
  from this have 
   "(?Q x. x ? Q ? (?z?Q. ?y. (y, z) ? {(x,y).(step¯¯) x y} ? y ? Q))" 
    by (simp add: wfP_def wf_eq_minimal)
  from this have
   "(?Q x. x ? Q ? (?z?Q. ?y. step z y ? y ? Q))" 
    by simp
  then show ?thesis by auto
qed

lemma wfE_min:
  assumes wf: "wf R" and Q: "x ? Q"
  obtains z where "z ? Q" "?y. (y, z) ? R ? y ? Q"
  using Q wfE_pf[OF wf, of Q] by blast


lemma third_step:  
 "terminating step' b ? R a b ?
  (? x. step'?*?* b x) ?
  Q = {e.? a. R a e} ?
  (?z ? Q. ?y. step' z y ? y ? Q)"
  by (metis mem_Collect_eq second_step)

lemma liber:
 "terminating step' b ? R a b ?
  Q = {e.(? a. R a e) ? step'?*?* b e} ?
  (?z ? Q. ?y. (step'?*?* b y ? step' z y) ? y ? Q)"
proof(cases "? x. step'?*?* b x") 
  case True
  note 0 = this
  assume 1: "terminating step' b" 
  assume 2: "R a b" 
  assume 3: "Q = {e.(? a. R a e) ? step'?*?* b e}"       
  from 0 3 have 4: "Q = {e.? a. R a e}" by auto
  from 0 1 2 4 have 5: "(?z ? Q. ?y. step' z y ? y ? Q)" 
    by (metis mem_Collect_eq second_step)
  from 0 5 have "(?z ? Q. ?y. (step'?*?* b y ? step' z y) ? y ? Q)" by auto
  from this show ?thesis by simp
next
  case False
  assume 1: "terminating step' b" 
  assume 2: "R a b" 
  assume 3: "Q = {e.(? a. R a e) ? step'?*?* b e}"
  from 3 have 4: "? x ? Q. step'?*?* b x" by auto
  from 1 2 3 4 have "(?z ? Q. ?y. step' z y ? y ? Q)" 
  then show ?thesis  sorry
qed*)


(*
  (* Some code to find the invariant: *)
  apply auto[1]
  subgoal for s n?0
    apply (cases "s ''i'' = 1")
    apply simp
    apply(smt char.inject factorial.simps fun_upd_apply list.inject mult.commute mult_nonneg_nonneg)
    done
  apply auto
*)